<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>LitFarms Product List</title>
  <!-- Replace favicon with inline SVG -->
  <link rel="icon" href="data:image/svg+xml,<?xml version='1.0' encoding='UTF-8' standalone='no'?><svg width='4.6079073in' height='2.5213542in' viewBox='0 0 117.04084 64.042396' version='1.1' id='svg1' xml:space='preserve' xmlns='http://www.w3.org/2000/svg'><defs id='defs1'/><g id='layer1' transform='translate(-46.479583,-116.4788)'><rect style='display:inline;opacity:1;fill:none;fill-opacity:1;stroke:%23ffffff;stroke-width:6;stroke-dasharray:none;stroke-opacity:1' id='rect2' width='111.04084' height='58.0424' x='49.47958' y='119.4788'/><g id='g6' style='opacity:1;fill:%23ffffff;fill-opacity:1' transform='matrix(1,0,0,1.0224587,0.56861157,30.651474)'><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:6.57396;stroke-dasharray:none;stroke-opacity:1' id='rect5' width='25.801872' height='5.860003' x='119.94384' y='98.674728' ry='0'/><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:6.03661;stroke-dasharray:none;stroke-opacity:1' id='rect6' width='6' height='30.334635' x='130.05539' y='101.46412'/></g><path style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:5.81338;stroke-dasharray:none;stroke-opacity:1' d='m 100.03961,131.46649 h 6 v 33.97218 h -6 z' id='path4'/><g id='g9' transform='matrix(1,0,0,1.0199169,-0.14807164,31.087934)'><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:5.43999;stroke-dasharray:none;stroke-opacity:1' id='rect8' width='6' height='33.229393' x='64.364632' y='98.429321'/><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:5.84555;stroke-dasharray:none;stroke-opacity:1' id='rect9' width='21.184687' height='5.8828321' x='64.373192' y='125.75582'/></g></g></svg>">
  <style>
    :root {
      /* Theme Colors */
      --bg-primary: #0a0d14;      /* Dark navy background */
      --bg-secondary: #141a24;    /* Lighter navy for cards */
      --bg-elevated: #1c2433;     /* Elevated elements */
      
      /* Accent Colors */
      --accent-primary: #60a5fa;    /* Bright blue */
      --accent-secondary: #38bdf8;  /* Sky blue */
      --accent-tertiary: #2464b1;  /* Darker blue */
      --accent-danger: #f43f5e;     /* Coral red */
      
      /* Text Colors */
      --text-primary: #ffffff;
      --text-secondary: #e2e8f0;
      --text-muted: #94a3b8;
      
      /* Status Colors */
      --status-success: #22c55e;    /* Emerald green */
      --status-error: #f43f5e;      /* Coral red */
      
      /* Strain Type Colors */
      --strain-sativa: #fbbf24;     /* Warm amber */
      --strain-indica: #8b5cf6;     /* Soft purple */
      --strain-hybrid: #34d399;     /* Emerald */
      --strain-unknown: #64748b;    /* Slate */
      
      /* Effects */
      --shadow-normal: 0 4px 8px rgba(0, 0, 0, 0.3);
      --shadow-hover: 0 0 25px rgba(96, 165, 250, 0.2);  /* Blue glow */
      --border-glow: rgba(96, 165, 250, 0.3);           /* Blue border */
      
      /* Modal */
      --modal-overlay: rgba(0, 0, 0, 0.7);
    }

    body {
      background-color: var(--bg-primary);
      color: var(--text-primary);
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }

    h1 {
      text-align: center;
      color: var(--accent-primary);
    }

    .filters-container {
      position: sticky;
      top: 0;
      z-index: 100;
      background-color: var(--bg-primary);
      padding: 10px 0;
      margin-bottom: 10px;
      /* Add subtle shadow for depth */
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    .filters select, .filters button {
      padding: 10px;
      border-radius: 5px;
      border: 1px solid var(--accent-primary);
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      cursor: pointer;
      min-width: auto;
      transition: all 0.3s ease;
      outline: none; /* Remove default focus outline */
    }

    /* Custom focus style */
    .filters select:focus {
      box-shadow: 0 0 0 2px var(--bg-primary), 0 0 0 4px var(--accent-primary);
      border-color: var(--accent-primary);
    }

    /* Style for select elements when a non-default option is selected */
    .filters select.has-selection {
      background-color: var(--accent-tertiary);
      border-color: var(--text-primary);
      color: var(--text-primary);
      box-shadow: 0 0 10px rgba(96, 165, 250, 0.3);
      font-weight: 500;
    }

    /* Custom focus style for selected state */
    .filters select.has-selection:focus {
      box-shadow: 0 0 0 2px var(--bg-primary), 0 0 0 4px var(--accent-primary);
    }

    .filters button.active {
      background-color: var(--bg-secondary);
      color: var(--status-error);
      border-color: var(--status-error);
    }

    .filters button:not(.active) {
      background-color: var(--bg-elevated);
      color: var(--accent-danger);
      border-color: var(--accent-danger);
    }
    .filters button:not(.active):hover {
      background-color: var(--border-glow);

    }

    .product-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
      padding: 20px;
      min-height: 200px; /* Prevent layout shift */
      max-width: 1200px; /* Add max-width for better control */
      margin: 0 auto; /* Center the grid */
    }

    /* Add a new class for when there are few items */
    .product-grid.few-items {
      grid-template-columns: repeat(auto-fit, minmax(250px, 300px));
      justify-content: center;
    }

    .product-card {
      background-color: var(--bg-secondary);
      border-radius: 10px;
      padding: 15px;
      box-shadow: var(--shadow-normal);
      transition: all 0.3s ease;
      max-width: 100%;
      margin: 0 auto;
      cursor: pointer;
      border: 1px solid transparent;
      opacity: 0;
      transform: translateY(10px);
      animation: fadeInUp 0.3s ease forwards;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .product-card.fade-out {
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    /* Even smaller screens */
    @media (max-width: 600px) {
      .product-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        padding: 6px;
      }

      .product-card {
        padding: 6px;
        max-width: 95%;
      }
      
      .weight-row {
        gap: 5px!important;
      }
      .stock-badge{
        min-width: 55px!important;
      }
    }

    /* Extra small screens */
    @media (max-width: 400px) {
      .product-grid {
        grid-template-columns: 1fr;
        gap: 12px;
        padding: 8px;
      }

      .product-card {
        padding: 8px;
        max-width: 100%;
      }

      .filters {
        gap: 6px;
      }

      .filters select, .filters button {
        padding: 8px;
        font-size: 0.9em;
        min-width: 0;
      }

      .variant-title {
        font-size: 1.2em;
      }

      .weight-label {
        font-size: 1.1em;
      }

      .weight-price {
        font-size: 1.5em;
      }

      .weight-row {
        padding: 4px 6px;
      }

      .weight-info {
        gap: 8px;
      }
    }

    .product-card:hover {
      transform: scale(1.025);
      box-shadow: var(--shadow-hover);
      border-color: var(--border-glow);
    }

    .product-image {
      width: 100%;
      border-radius: 10px;
    }

    .product-title {
      margin: 10px 0;
      color: var(--accent-primary);
      font-size: clamp(0.8em, 4vw, 1.5em);
      line-height: 1.2;
      width: 100%;
      text-align: center;
    }

    .product-price {
      font-size: 1.2em;
      color: var(--accent-secondary);
    }

    .product-description {
      font-size: 0.9em;
      color: var(--text-muted);
      margin: 10px 0;
    }

    .out-of-stock {
      color: var(--status-error);
      font-weight: bold;
    }

    .price-container {
      margin: 15px 0;
      padding: 0px 0px 10px 0px;
      border-radius: 8px;
      background-color: #1c243345;
      font-size: .75em;
    }

    .variant-section {
      margin-bottom: 3px;
      padding: 12px;
      border-radius: 8px;
    }

    /* Background colors for different tier sections */
    .variant-section-essential {
      background-color: rgba(255, 255, 255, 0.06);
    }

    .variant-section-preferred {
      background-color: rgba(33, 150, 243, 0.06);
    }

    .variant-section-supreme {
      background-color: rgba(255, 213, 0, 0.06);
    }

    .variant-section:last-child {
      margin-bottom: 0;

      border-bottom: none;
    }

    .variant-title {
      font-size: 1.4em;
      margin-bottom: 8px;
      padding-bottom: 4px;
      border-bottom: 1px solid var(--accent-primary);
      font-weight: bold;
    }

    /* Variant title colors for different tiers */
    .variant-title-essential {
      color: #ffffff;  /* A nice green */
      text-shadow: 0 0 14px #ffffff4a;;
    }

    .variant-title-essential::before {
      content: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="-351 153 256 256" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M-177.7,334.5c6.3-2.3,12.6-5.2,19.8-8.6c31.9-16.4,51.7-41.7,51.7-41.7s-32.5,0.6-64.4,17c-4,1.7-7.5,4-10.9,5.7c5.7-7.5,12.1-16.4,18.7-25c25-37.1,31.3-77.3,31.3-77.3s-34.8,21-59.2,58.6c-5.2,7.5-9.8,14.9-13.8,22.7c1.1-10.3,1.1-22.1,1.1-33.6c0-50-19.8-91.1-19.8-91.1s-19.8,40.5-19.8,91.1c0,12.1,0.6,23.3,1.1,33.6c-4-7.5-8.6-14.9-13.8-22.7c-25-37.1-59.2-58.6-59.2-58.6s6.3,40,31.3,77.3c6.3,9.2,12.1,17.5,18.7,25c-3.4-2.3-7.5-4-10.9-5.7c-31.9-16.4-64.4-17-64.4-17s19.8,25.6,51.7,41.7c6.9,3.4,13.2,6.3,19.8,8.6c-4,0.6-8,1.1-12.1,2.3c-30.5,6.4-53.2,23.9-53.2,23.9s27.3,7.5,58.6,1.1c9.8-2.3,19.8-4.6,27.3-7.5c-1.1,1.1,15.8-8.6,21.6-14.4v60.4h8.6v-61.8c6.3,6.3,22.7,16.4,22.1,14.9c8,2.9,17.5,5.2,27.3,7.5c30.8,6.3,58.6-1.1,58.6-1.1s-22.1-17.5-53.4-23.8C-169.6,335.7-173.7,335.1-177.7,334.5z" fill="%23ffffff"/></svg>');
      margin-right: 9px;
      display: inline-block;
      vertical-align: middle;
    }

    .variant-title-preferred {
      color: #2196F3;  /* A pleasant blue */
      text-shadow: 0 0 14px #2195f364;
    }

    .variant-title-preferred::before {
      content: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.15316 5.40838C10.4198 3.13613 11.0531 2 12 2C12.9469 2 13.5802 3.13612 14.8468 5.40837L15.1745 5.99623C15.5345 6.64193 15.7144 6.96479 15.9951 7.17781C16.2757 7.39083 16.6251 7.4699 17.3241 7.62805L17.9605 7.77203C20.4201 8.32856 21.65 8.60682 21.9426 9.54773C22.2352 10.4886 21.3968 11.4691 19.7199 13.4299L19.2861 13.9372C18.8096 14.4944 18.5713 14.773 18.4641 15.1177C18.357 15.4624 18.393 15.8341 18.465 16.5776L18.5306 17.2544C18.7841 19.8706 18.9109 21.1787 18.1449 21.7602C17.3788 22.3417 16.2273 21.8115 13.9243 20.7512L13.3285 20.4768C12.6741 20.1755 12.3469 20.0248 12 20.0248C11.6531 20.0248 11.3259 20.1755 10.6715 20.4768L10.0757 20.7512C7.77268 21.8115 6.62118 22.3417 5.85515 21.7602C5.08912 21.1787 5.21588 19.8706 5.4694 17.2544L5.53498 16.5776C5.60703 15.8341 5.64305 15.4624 5.53586 15.1177C5.42868 14.773 5.19043 14.4944 4.71392 13.9372L4.2801 13.4299C2.60325 11.4691 1.76482 10.4886 2.05742 9.54773C2.35002 8.60682 3.57986 8.32856 6.03954 7.77203L6.67589 7.62805C7.37485 7.4699 7.72433 7.39083 8.00494 7.17781C8.28555 6.96479 8.46553 6.64194 8.82547 5.99623L9.15316 5.40838Z" fill="%2360a5fa"/></svg>');
      margin-right: 9px;
      display: inline-block;
      vertical-align: middle;
    }

    .variant-title-supreme {
      color: var(--strain-sativa);
    text-shadow: 0 0 14px #fbbf248f;
    }

    .variant-title-supreme::before {
      content: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21.609 13.5616L21.8382 11.1263C22.0182 9.2137 22.1082 8.25739 21.781 7.86207C21.604 7.64823 21.3633 7.5172 21.106 7.4946C20.6303 7.45282 20.0329 8.1329 18.8381 9.49307C18.2202 10.1965 17.9113 10.5482 17.5666 10.6027C17.3757 10.6328 17.1811 10.6018 17.0047 10.5131C16.6865 10.3529 16.4743 9.91812 16.0499 9.04851L13.8131 4.46485C13.0112 2.82162 12.6102 2 12 2C11.3898 2 10.9888 2.82162 10.1869 4.46486L7.95007 9.04852C7.5257 9.91812 7.31351 10.3529 6.99526 10.5131C6.81892 10.6018 6.62434 10.6328 6.43337 10.6027C6.08872 10.5482 5.77977 10.1965 5.16187 9.49307C3.96708 8.1329 3.36968 7.45282 2.89399 7.4946C2.63666 7.5172 2.39598 7.64823 2.21899 7.86207C1.8918 8.25739 1.9818 9.2137 2.16181 11.1263L2.391 13.5616C2.76865 17.5742 2.95748 19.5805 4.14009 20.7902C5.32271 22 7.09517 22 10.6401 22H13.3599C16.9048 22 18.6773 22 19.8599 20.7902C21.0425 19.5805 21.2313 17.5742 21.609 13.5616Z" fill="%23fbbf24"/></svg>');
      margin-right: 9px;
      display: inline-block;
      vertical-align: middle;
    }

    .variant-weights {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .weight-row {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 6px 8px;
    }

    .weight-info-row {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
    }

    .weight-info {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: center;
      margin-bottom: 3px;
    }

    .weight-label {
      font-size: 1.25em;
      color: var(--text-primary);
    }

    .weight-price {
      font-size: 1.75em;
      color: var(--strain-sativa);
      font-weight: bold;
      font-family: monospace;
      border: 1px solid;
      padding: 1px 4px;
      box-shadow: inset 0px 0px 5px 0px var(--strain-sativa), 0px 0px 14px 0px #fbbf2459;
      border-radius: 5px;
    }

    .stock-badge {
      padding: 4px 0px;
      border-radius: 4px;
      font-size: 0.6em;
      font-weight: bold;
      text-transform: uppercase;
      width: 100%;
      text-align: center;
    }

    .in-stock-badge {
      background-color: rgba(34, 197, 94, 0.2);
      color: var(--status-success);
    }

    .out-of-stock-badge {
      background-color: rgba(244, 63, 94, 0.2);
      color: var(--status-error);
    }

    #product-count {
      text-align: center;
      margin: 15px 0;
      color: var(--accent-secondary);
      font-size: 1.1em;
    }

    /* Loading Animation */
    .loader-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px;
      gap: 20px;
    }

    .loader {
      width: 48px;
      height: 48px;
      border: 3px solid var(--bg-elevated);
      border-radius: 50%;
      display: inline-block;
      position: relative;
      box-sizing: border-box;
      animation: rotation 1s linear infinite;
    }

    .loader::after {
      content: '';  
      box-sizing: border-box;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 3px solid transparent;
      border-bottom-color: var(--accent-primary);
    }

    .loader-text {
      color: var(--text-secondary);
      font-size: 1.1em;
    }

    @keyframes rotation {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }

    /* Settings Button */
    #settings-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: var(--accent-primary);
      color: var(--bg-primary);
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      box-shadow: var(--shadow-normal);
      transition: all 0.3s ease;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }

    #settings-button svg {
      width: 24px;
      height: 24px;
      fill: none;
      stroke: currentColor;
      stroke-width: 2;
    }

    #settings-button:hover {
      transform: scale(1.1);
      box-shadow: var(--shadow-hover);
    }

    /* Modal Styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--modal-overlay);
      z-index: 1001;
      align-items: flex-start; /* Change from center to flex-start */
      justify-content: center;
      overflow-y: auto; /* Add scroll to overlay */
      padding: 20px 0; /* Add some padding top and bottom */
    }

    .modal {
      background-color: var(--bg-secondary);
      border-radius: 10px;
      padding: 20px;
      width: 90%;
      max-width: 600px;
      max-height: none; /* Remove max-height constraint */
      position: relative;
      box-shadow: var(--shadow-normal);
      margin: 20px 0; /* Add margin to ensure spacing at top and bottom */
    }

  
    body.modal-open {
      overflow: hidden;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-glow);
    }

    .modal-title {
      color: var(--accent-primary);
      margin: 0;
      font-size: 1.5em;
    }

    .close-modal {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 24px;
      cursor: pointer;
      padding: 0;
    }

    .close-modal:hover {
      color: var(--text-primary);
    }

    .settings-section {
      margin-bottom: 20px;
      padding: 15px;
      background-color: var(--bg-elevated);
      border-radius: 8px;
    }

    .settings-section h3 {
      color: var(--accent-secondary);
      margin-top: 0;
      margin-bottom: 15px;
    }

    .settings-select {
      display: block;
      width: 100%;
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border-glow);
      border-radius: 4px;
      padding: 8px;
      margin-bottom: 15px;
      font-size: 14px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }

    .settings-select:not([multiple]) {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%2360a5fa' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 16px;
      padding-right: 32px;
    }

    .settings-select[multiple] {
      height: auto;
      min-height: 120px;
      padding: 0;
    }

    .settings-select option {
      padding: 8px 12px;
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      border-bottom: 1px solid var(--border-glow);
    }

    .settings-select option:last-child {
      border-bottom: none;
    }

    .settings-select option:checked {
      background: var(--accent-primary);
      color: var(--bg-primary);
    }

    /* Safari-specific styles */
    @media screen and (-webkit-min-device-pixel-ratio: 0) {
      _::-webkit-full-page-media, _:future, :root .settings-select[multiple] {
        border: 1px solid var(--border-glow);
        border-radius: 4px;
        background: var(--bg-secondary);
      }

      _::-webkit-full-page-media, _:future, :root .settings-select[multiple] option {
        padding: 8px 12px;
        background: var(--bg-secondary);
        color: var(--text-primary);
      }

      _::-webkit-full-page-media, _:future, :root .settings-select[multiple] option:checked {
        background: var(--accent-primary);
        color: var(--bg-primary);
      }
    }

    .save-settings {
      background-color: var(--accent-primary);
      color: var(--bg-primary);
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      width: 100%;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .save-settings:hover {
      background-color: var(--accent-secondary);
    }

    /* Product Selection */
    .product-select-container {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 10px;
      padding: 10px;
      background-color: var(--bg-secondary);
      border-radius: 4px;
    }

    .product-search {
      margin-bottom: 10px;
      position: relative;
    }

    .product-search input {
      width: 100%;
      padding: 8px 32px 8px 12px;
      border: 1px solid var(--border-glow);
      border-radius: 4px;
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 14px;
      box-sizing: border-box;
    }

    .product-search input:focus {
      outline: none;
      border-color: var(--accent-primary);
    }

    .product-search::after {
      content: "";
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      width: 16px;
      height: 16px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%2394a3b8'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'%3E%3C/path%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain;
    }

    .product-select-item {
      display: flex;
      align-items: center;
      padding: 8px 10px;
      border-bottom: 1px solid var(--border-glow);
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .product-select-item:hover {
      background-color: var(--bg-elevated);
    }

    .product-select-item:last-child {
      border-bottom: none;
    }

    .product-select-item.hidden {
      display: none;
    }

    .product-select-item input[type="checkbox"] {
      margin-right: 10px;
    }

    /* Style for selected items */
    .product-select-item input[type="checkbox"]:checked + label {
      color: var(--accent-primary);
      font-weight: bold;
    }

    .product-select-item input[type="checkbox"]:checked {
      accent-color: var(--accent-primary);
    }

    .product-select-item:has(input[type="checkbox"]:checked) {
      background-color: var(--bg-elevated);
      border-left: 3px solid var(--accent-primary);
      padding-left: 7px; /* Compensate for the border */
    }

    .notification-input {
      box-sizing: border-box;
      width: 100%;
      margin: 5px 0;
      padding: 5px 12px;
    }

    /* Search Input Styles */
    .search-container {
      position: relative;
      display: inline-block;
    }

    .search-input {
      padding: 10px 35px 10px 10px;
      border-radius: 5px;
      border: 1px solid var(--accent-primary);
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      min-width: 200px;
    }

    .clear-search {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0;
      font-size: 18px;
      line-height: 1;
      display: none;
      width: 16px;
      height: 16px;
      align-items: center;
      justify-content: center;
    }

    .clear-search:hover {
      color: var(--text-primary);
    }

    /* Add new stock filter button styles */
    .stock-filter-btn.active {
      background-color: var(--bg-secondary);
      color: var(--accent-primary) !important;
      border-color: var(--accent-primary) !important;
    }

    .stock-filter-btn:not(.active) {
      background-color: var(--bg-elevated);
      color: var(--status-success) !important;
      border-color: var(--status-success) !important;
    }

    .stock-filter-btn:hover {
      background-color: var(--border-glow);
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
      margin-bottom: 20px;
    }

    .header img {
      height: 40px;
      width: auto;
    }

    .header h1 {
      margin: 0;
    }
    .filters select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%2360a5fa' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 16px;
      padding-right: 32px;
      padding-left: 12px;
    }

    /* Add styles for the header links */
    .header-link {
      text-decoration: none;
      color: inherit;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .header-link:hover {
      opacity: 0.8;
    }

    /* Add these styles to the existing <style> section */
    .product-image-container {
      position: relative;
      width: 100%;
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 10px;
    }

    .image-wrapper {
      position: relative;
      width: 100%;
      padding-top: 100%; /* 1:1 Aspect Ratio */
      overflow: hidden;
    }

    .product-image {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover; /* This will maintain aspect ratio while filling the container */
      transition: transform 0.3s ease;
    }

    .product-image-container:hover .image-nav {
      opacity: 1;
    }

    /* Add focus styles for keyboard navigation */
    .product-image-container:focus {
      outline: 2px solid var(--accent-primary);
      outline-offset: 2px;
    }


    .strain-type-badge {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 5px 10px;
      border-radius: 15px;
      text-transform: capitalize;
      z-index: 4;
    }

    /* Add these styles in the <style> section */
    .countdown-container {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: var(--bg-elevated);
      border-radius: 50%;
      box-shadow: var(--shadow-normal);
      cursor: pointer;
      z-index: 999;
      padding: 2px;
      display: none;
    }

    .countdown-circle {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .countdown-circle svg {
      position: absolute;
      width: 100%;
      height: 100%;
      transform: rotate(-90deg);
    }

    .countdown-circle circle {
      fill: none;
      stroke-width: 2.5;
      stroke-linecap: round;
    }

    .countdown-circle circle.progress-bg {
      stroke: var(--bg-secondary);
    }

    .countdown-circle circle.progress {
      stroke: var(--accent-primary);
      transition: stroke-dashoffset 1s linear;
    }

    .countdown-time {
      position: relative;
      font-size: 10px;
      color: var(--text-primary);
      font-family: monospace;
      z-index: 1;
    }

    .countdown-container:hover .countdown-tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateX(-100%) translateY(-50%);
    }

    .countdown-tooltip {
      position: absolute;
      right: calc(100% + 10px);
      top: 50%;
      transform: translateX(-90%) translateY(-50%);
      background-color: var(--bg-elevated);
      color: var(--text-primary);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      box-shadow: var(--shadow-normal);
    }

    .countdown-tooltip:after {
      content: '';
      position: absolute;
      right: -6px;
      top: 50%;
      transform: translateY(-50%);
      border-left: 6px solid var(--bg-elevated);
      border-top: 6px solid transparent;
      border-bottom: 6px solid transparent;
    }

    /* Virtual Cart Styles */
    .virtual-cart-button {
      position: fixed;
      bottom: 20px;
      right: 90px; /* Position next to settings button */
      background-color: var(--accent-primary);
      color: var(--bg-primary);
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      box-shadow: var(--shadow-normal);
      transition: all 0.3s ease;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .virtual-cart-button:hover {
      transform: scale(1.1);
      box-shadow: var(--shadow-hover);
    }

    .cart-count {
      position: absolute;
      top: -5px;
      right: -5px;
      background-color: var(--status-error);
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .add-to-cart-button {
      background-color: var(--accent-primary);
      color: var(--bg-primary);
      border: none;
      border-radius: 5px;
      padding: 8px 15px;
      cursor: pointer;  /* Keep pointer cursor for the button */
      transition: all 0.2s ease;
      margin-top: 5px;
      width: 100%;
      font-weight: bold;
    }

    .add-to-cart-button:hover {
      background-color: var(--accent-secondary);
      transform: scale(1.02);
    }

    .add-to-cart-button:disabled {
      background-color: var(--text-muted);
      cursor: not-allowed;
    }

    /* Add animation for the add to cart button click */
    .add-to-cart-button.clicked {
      animation: buttonClick 0.3s ease;
    }

    @keyframes buttonClick {
      0% { transform: scale(1); }
      50% { transform: scale(0.95); }
      100% { transform: scale(1); }
    }

    /* Add animation for the cart icon */
    @keyframes cartPulse {
      0% { transform: scale(1); }
      25% { transform: scale(1.2); }
      50% { transform: scale(1); }
      75% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    .virtual-cart-button.pulse {
      animation: cartPulse 0.5s ease;
    }

    /* Cart Modal Styles */
    .cart-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--modal-overlay);
      z-index: 1001;
      align-items: flex-start;
      justify-content: center;
      padding: 20px 0;
      overflow-y: auto;
    }

    .cart-modal-content {
      background-color: var(--bg-secondary);
      border-radius: 10px;
      padding: 20px;
      width: 90%;
      max-width: 600px;
      position: relative;
      margin: 20px 0;
    }

    .cart-item {
      display: flex;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid var(--border-glow);
      gap: 10px;
    }

    .cart-item-info {
      flex-grow: 1;
    }

    .cart-item-title {
      font-weight: bold;
      color: var(--text-primary);
    }

    .cart-item-variant {
      color: var(--text-muted);
      font-size: 0.9em;
    }

    .cart-item-price {
      color: var(--accent-secondary);
      font-weight: bold;
    }

    .remove-from-cart {
      color: var(--status-error);
      background: none;
      border: none;
      cursor: pointer;
      padding: 5px;
    }

    .cart-total {
      margin-top: 20px;
      padding-top: 10px;
      border-top: 1px solid var(--border-glow);
      text-align: right;
      font-weight: bold;
    }

    .checkout-button {
      background-color: var(--status-success);
      color: var(--bg-primary);
      border: none;
      border-radius: 5px;
      padding: 10px 20px;
      cursor: pointer;
      width: 100%;
      margin-top: 20px;
      font-weight: bold;
      transition: all 0.2s ease;
    }

    .checkout-button:hover {
      filter: brightness(1.1);
    }

    .empty-cart-message {
      text-align: center;
      color: var(--text-muted);
      padding: 20px;
    }

    .weight-row {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px;
      border-radius: 6px;
      margin-bottom: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      cursor: default;  /* Show default cursor for weight rows */
    }

    .weight-row.in-stock {
      background-color: rgb(96 250 132 / 10%);
    }

    .weight-row.out-of-stock {
      background-color: rgb(250 96 96 / 7%);
    }

    .weight-row:last-child {
      margin-bottom: 0;
    }

    .variant-weights {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .variant-section {
      margin-bottom: 8px;
      padding: 12px;
      border-radius: 8px;
    }

    .variant-section:last-child {
      margin-bottom: 0;
    }

    .variant-title {
      font-size: 1.4em;
      margin-bottom: 8px;
      padding-bottom: 4px;
      border-bottom: 1px solid var(--accent-primary);
    }

    /* Add these styles to your existing styles section */
    .cart-item {
      display: flex;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid var(--border-glow);
      gap: 10px;
    }

    .cart-item-info {
      flex-grow: 1;
    }

    .cart-item-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .quantity-controls {
      display: flex;
      align-items: center;
      gap: 5px;
      background: var(--bg-elevated);
      padding: 2px;
      border-radius: 4px;
    }

    .quantity-btn {
      background: var(--accent-primary);
      color: var(--bg-primary);
      border: none;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      transition: all 0.2s ease;
    }

    .quantity-btn:hover {
      background: var(--accent-secondary);
    }

    .quantity-display {
      min-width: 24px;
      text-align: center;
      font-weight: bold;
      color: var(--text-primary);
    }

    .remove-from-cart {
      color: var(--status-error);
      background: none;
      border: none;
      cursor: pointer;
      padding: 5px;
      font-size: 1.2em;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
  <!-- Add this right after the settings button, before the settings modal -->
  <div class="countdown-container">
    <div class="countdown-tooltip">Next check in: <span class="tooltip-time">5:00</span></div>
    <div class="countdown-circle">
      <svg viewBox="0 0 36 36">
        <circle class="progress-bg" r="16" cx="18" cy="18"></circle>
        <circle class="progress" r="16" cx="18" cy="18" stroke-dasharray="100.53" stroke-dashoffset="0"></circle>
      </svg>
      <div class="countdown-time">5:00</div>
    </div>
  </div>
</head>
<body>
  <div class="header">
    <!-- Add link around SVG -->
    <a href="https://www.litfarms.com" class="header-link">
      <svg width="75" height="75" viewBox="0 0 117.04084 64.042396" version="1.1" id="svg1" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
        <defs id="defs1"></defs>
        <g id="layer1" transform="translate(-46.479583,-116.4788)">
          <rect style="display:inline;opacity:1;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:6;stroke-dasharray:none;stroke-opacity:1" id="rect2" width="111.04084" height="58.0424" x="49.47958" y="119.4788"></rect>
          <g id="g6" style="opacity:1;fill:#ffffff;fill-opacity:1" transform="matrix(1,0,0,1.0224587,0.56861157,30.651474)">
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:6.57396;stroke-dasharray:none;stroke-opacity:1" id="rect5" width="25.801872" height="5.860003" x="119.94384" y="98.674728" ry="0"></rect>
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:6.03661;stroke-dasharray:none;stroke-opacity:1" id="rect6" width="6" height="30.334635" x="130.05539" y="101.46412"></rect>
          </g>
          <path style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:5.81338;stroke-dasharray:none;stroke-opacity:1" d="m 100.03961,131.46649 h 6 v 33.97218 h -6 z" id="path4"></path>
          <g id="g9" transform="matrix(1,0,0,1.0199169,-0.14807164,31.087934)">
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:5.43999;stroke-dasharray:none;stroke-opacity:1" id="rect8" width="6" height="33.229393" x="64.364632" y="98.429321"></rect>
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:5.84555;stroke-dasharray:none;stroke-opacity:1" id="rect9" width="21.184687" height="5.8828321" x="64.373192" y="125.75582"></rect>
          </g>
        </g>
      </svg>
    </a>
    <!-- Add link around title -->
    <a href="https://www.litfarms.com" class="header-link">
      <h1>Farms Products</h1>
    </a>
  </div>
  <div class="filters-container">
    <div class="filters">
      <div class="search-container">
        <input type="text" id="product-search-filter" class="search-input" placeholder="Search products...">
        <button id="clear-search" class="clear-search">&times;</button>
      </div>
      <select id="strain-filter">
        <option value="all">All Tiers</option>
        <option value="Essential">Essential</option>
        <option value="Preferred">Preferred</option>
        <option value="Supreme">Supreme</option>
      </select>
      <select id="strain-type-filter">
        <option value="all">All Types</option>
        <option value="sativa">Sativa</option>
        <option value="indica">Indica</option>
        <option value="hybrid">Hybrid</option>
        <option value="unknown">Unknown</option>
      </select>
      <select id="weight-filter">
        <option value="all">All Weights</option>
        <option value="28g">28g</option>
        <option value="3.5g">3.5g</option>
      </select>
      <select id="sort-filter">
        <option value="alpha-asc">A-Z</option>
        <option value="alpha-desc">Z-A</option>
        <option value="price-asc">Price: Low to High</option>
        <option value="price-desc">Price: High to Low</option>
        <option value="date-desc">Newest First</option>
        <option value="date-asc">Oldest First</option>
      </select>
      <button id="stock-filter" class="stock-filter-btn active">Show All</button>
    </div>
    <div id="product-count" style="text-align: center; margin: 8px 0; color: #03dac6;">
      Showing 0 products
    </div>
  </div>
  <div class="product-grid" id="product-grid">
    <!-- Product cards will be dynamically inserted here -->
  </div>

  <div id="loader" class="loader-container" style="display: none;">
    <span class="loader"></span>
    <div class="loader-text">Loading products...</div>
  </div>

  <script>
    // Define the URL for the products.json endpoint
    const shopifyStoreUrl = 'https://litfarms.com/products.json';
    
    // Ntfy configuration
    const NTFY_CONFIG = {
      appEnabled: false, // App notifications enabled
      emailEnabled: false, // Email notifications enabled
      topic: '', // Will be set in settings
      server: 'https://ntfy.sh', // Default server, can be changed in settings
      email: '' // Email for notifications
    };

    // Declare updateCheckerId at the top level
    let updateCheckerId = null;

    // Settings Management
    const DEFAULT_SETTINGS = {
      checkInterval: 5, // minutes
      notificationTiers: ['all'],
      notificationWeights: ['all'],
      notifyNew: true,
      notifyStock: true,
      notifyRemoved: true,
      specificProducts: [], // Array of product handles
      ntfyAppEnabled: false,
      ntfyEmailEnabled: false,
      ntfyTopic: '',
      ntfyServer: 'https://ntfy.sh',
      ntfyEmail: ''
    };

    let currentSettings = { ...DEFAULT_SETTINGS };

    function loadSettings() {
      const savedSettings = localStorage.getItem('litFarmsNotificationSettings');
      if (savedSettings) {
        currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(savedSettings) };
      }
      // Update Ntfy config
      NTFY_CONFIG.appEnabled = currentSettings.ntfyAppEnabled;
      NTFY_CONFIG.emailEnabled = currentSettings.ntfyEmailEnabled;
      NTFY_CONFIG.topic = currentSettings.ntfyTopic;
      NTFY_CONFIG.server = currentSettings.ntfyServer;
      NTFY_CONFIG.email = currentSettings.ntfyEmail;
      return currentSettings;
    }

    // Update saveSettings function to properly handle timer reset
    function saveSettings(settings) {
      const oldInterval = currentSettings.checkInterval;
      const newInterval = settings.checkInterval;
      
      localStorage.setItem('litFarmsNotificationSettings', JSON.stringify(settings));
      currentSettings = settings;
      
      // Only restart timers if the interval changed
      if (oldInterval !== newInterval) {
        // Clear existing intervals
        if (updateCheckerId) {
          clearInterval(updateCheckerId);
          updateCheckerId = null;
        }
        
        // Clear all existing cleanup handlers
        pageCleanupHandlers.forEach(handler => {
          try {
            handler();
          } catch (error) {
            console.warn('Cleanup handler error:', error);
          }
        });
        pageCleanupHandlers = [];
        
        // Start new product checker and countdown
        startProductUpdateChecker();
      }
    }

    // Strain data
    const MANUAL_STRAIN_DATA = {
  "zereal": {
    "description": "Zerealz is a slightly indica dominant hybrid strain (60% indica/40% sativa) created through crossing the powerful Zkittlez X Cereal Milk strains. Looking for an insanely delicious flavor and a super euphoric yet relaxing high? Zerealz is definitely made for you. This bud packs a sweet and creamy fruity berry flavor into each and every toke, sharpened slightly by a sour citrus exhale. The aroma is earthy and herbal at the onset before settling into a sweet and fruity effect as the nugs are broken apart and burned away.",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738172569453
  },
  "white linen": {
    "description": "White Linen is an indica dominant hybrid strain (70% indica/30% sativa) created through crossing the delicious Wedding Cake #13 X Melonade strains. Named for its gorgeous appearance and soft, soothing high, White Linen is the perfect choice for any lover of classic flavorful indicas. This bud has beautiful fat heart-shaped bright neon green nugs with minty green undertones, lots of thin yellow-orange hairs and a frosty thick coating of slightly golden-white crystal trichomes.",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738172600552
  },
  "lit og": {
    "description": "LIT OG: Where Tahoe OG meets Runtz in a legendary clash of titans. This unforgettable strain packs a powerful punch, leaving you feeling euphoric and blissful. But LIT OG isn't just about brute force. Its flavor profile is a delightful surprise, exploding with gassy OG terps that linger on the palate. It's the perfect choice for experienced users seeking a potent and flavorful experience that lives up to its name.",
    "category": "sativa",
    "phenotype": "sativa",
    "lastUpdate": 1738172799107
  },
  "lemon cherry belts": {
    "description": "Delivers a vibrant blend of sweet lemon zest and ripe cherries, with a smooth, creamy finish.",
    "category": "hybrid",
    "phenotype": "hybrid",
    "lastUpdate": 1738179317058
  },
  "glitter bomb": {
    "description": "Glitter Bomb THCa Flower will enchant you with its dazzling trichomes and hypnotic purple buds! It is a 70/30 indica dominant hybrid type 1 hemp flower that was indoor grown with living soil. This genetic gem of a strain is from crossing Grape Gas with OG Kush Breath Blueberry Headband, and exhibits notes of sweet, gas, and berries! This strain will have you dimension hopping with euphoria, transcendental thinking, and powerful relaxation!",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738179386321
  },
  "apple banana zoap": {
    "description": "Apple Banana Zoap from LIT Farms is a cannabis strain that combines the flavors of apples, bananas, and zoap. The strain''s unique flavor profile blends sweet, creamy notes of apples and bananas with earthy, floral undertones of zoap, creating a rich and aromatic experience. This combination makes Apple Banana highly appealing to cannabis users. This strain offers a balanced high, combining relaxation and a gentle cerebral stimulation, making it suitable for both recreational and medicinal use. The potent levels of THC in Apple Banana provide a strong and long-lasting effect, helping to relieve stress, anxiety, and chronic pain.",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738179467896
  },
  "bubblegum runtz": {
    "description": "Bubble Runtz, also known as Bubblegum Runtz and Bubble Gum Runtz,, is a hybrid weed strain made by crossing Runtz and Bubble Gum. ",
    "category": "hybrid",
    "phenotype": "hybrid",
    "lastUpdate": 1738172799107
  }
};

    // Simplify loadStrainData to just use the constant
    async function loadStrainData() {
      try {
        //console.log('Loading strain data...');
        strainData = MANUAL_STRAIN_DATA;
        console.log('Loaded strain data:', strainData);
        return strainData;
      } catch (error) {
        console.error('Error in loadStrainData:', error);
        return {};
      }
    }

    // Update getStrainType to use the new strain data
    function getStrainType(description, productHandle, productTitle) {
      //console.log(`Getting strain type for ${productTitle}`);
      
      // Clean the title first since we need it for both checks
      const cleanTitle = productTitle
        .replace(/\s*-?\s*THCA\s+Flower\s*$/i, '')
        .replace(/\s*-?\s*Flower\s*$/i, '')
        .replace(/\s*-?\s*\d+\.?\d*g\s*$/i, '')
        .replace(/-/g, '')
        .trim()
        .toLowerCase();

      // First check if product description explicitly mentions strain type
      if (description) {
        const temp = document.createElement('div');
        temp.innerHTML = description;
        const plainText = temp.textContent.toLowerCase();
        
        if (plainText.includes('sativa')) return 'sativa';
        if (plainText.includes('indica')) return 'indica';
        if (plainText.includes('hybrid')) return 'hybrid';
      }

      // If no strain type in product description, use manual strain type
      let strainInfo = strainData[cleanTitle];
      
      // If not found, try removing trailing 's' if present
      if (!strainInfo && cleanTitle.endsWith('s')) {
        const singularForm = cleanTitle.slice(0, -1);
        strainInfo = strainData[singularForm];
      }

      // Return the manual strain type if available
      if (strainInfo?.category) {
        return strainInfo.category.toLowerCase();
      }
      
      return 'unknown';
    }

    // Function to show/hide loader
    function toggleLoader(show) {
      if (show) {
        domElements.loader.style.display = 'flex';
        domElements.productGrid.style.display = 'none';
      } else {
        domElements.loader.style.display = 'none';
        domElements.productGrid.style.display = 'grid';
      }
    }

    // Define global products variable
    let products = [];

    // Cache constants
    const CACHE_KEY = 'litFarmsProducts';
    const CACHE_TIMESTAMP_KEY = 'litFarmsLastUpdate';
    const CACHE_DURATION = 1 * 60 * 1000; // 1 minutes in milliseconds

    // Function to handle caching and fetching products
    async function getProducts(immediate = false) {
      const now = Date.now();
      const lastUpdate = localStorage.getItem(CACHE_TIMESTAMP_KEY);
      const cachedData = localStorage.getItem(CACHE_KEY);

      try {
        // Check for valid cached data
        if (cachedData && lastUpdate) {
          const parsedCache = JSON.parse(cachedData);
          const isValidCache = Array.isArray(parsedCache) && 
                              parsedCache.length > 0 && 
                              parsedCache[0].hasOwnProperty('title');

          if (isValidCache) {
            // If this is an immediate request, return cached data regardless of age
            if (immediate) {
              return filterTHCAProducts(parsedCache);
            }
            
            // For background updates, check if cache is fresh enough
            if (now - parseInt(lastUpdate) < CACHE_DURATION) {
              return filterTHCAProducts(parsedCache);
            }
          }
        }

        // If we get here, we need fresh data
        console.log('Fetching fresh product data');
        const freshProducts = await fetchAllProducts();
        
        if (!Array.isArray(freshProducts) || freshProducts.length === 0) {
          throw new Error('Invalid or empty product data received');
        }

        const thcaProducts = filterTHCAProducts(freshProducts);
        
        if (thcaProducts.length > 0) {
          localStorage.setItem(CACHE_KEY, JSON.stringify(thcaProducts));
          localStorage.setItem(CACHE_TIMESTAMP_KEY, now.toString());
        }
        
        return thcaProducts;
      } catch (error) {
        console.error('Error in getProducts:', error);
        
        // If this is an immediate request and we have any cached data, use it
        if (immediate && cachedData) {
          try {
            const parsedCache = JSON.parse(cachedData);
            if (Array.isArray(parsedCache) && parsedCache.length > 0) {
              return filterTHCAProducts(parsedCache);
            }
          } catch (e) {
            console.error('Failed to parse cached data:', e);
          }
        }
        
        // Clear potentially corrupted cache
        localStorage.removeItem(CACHE_KEY);
        localStorage.removeItem(CACHE_TIMESTAMP_KEY);
        
        // Try one more time without cache
        try {
          const freshProducts = await fetchAllProducts();
          return filterTHCAProducts(freshProducts);
        } catch (retryError) {
          console.error('Retry failed:', retryError);
          throw new Error('Failed to load products after retry');
        }
      }
    }

    // Update the fetchAllProducts function to include logging
    async function fetchAllProducts() {
      let allProducts = [];
      
      try {
        // Fetch first page
        const response = await fetch(`${shopifyStoreUrl}?page=1&limit=250`);
        const data = await response.json();
        
        if (data.products && data.products.length > 0) {
          allProducts = data.products;
          console.log(`Found ${data.products.length} products on page 1`);
          
          // Only continue fetching if we got the maximum number of products (250)
          if (data.products.length === 250) {
            let page = 2;
            let hasMore = true;
            
            while (hasMore) {
              try {
                const nextResponse = await fetch(`${shopifyStoreUrl}?page=${page}&limit=250`);
                const nextData = await nextResponse.json();
                
                if (nextData.products && nextData.products.length > 0) {
                  console.log(`Found ${nextData.products.length} products on page ${page}`);
                  allProducts = allProducts.concat(nextData.products);
                  page++;
                  
                  // If we got less than 250 products, we've reached the end
                  if (nextData.products.length < 250) {
                    hasMore = false;
                  }
                } else {
                  hasMore = false;
                }
              } catch (error) {
                console.error('Error fetching page', page, ':', error);
                hasMore = false;
              }
            }
          }
        }
      } catch (error) {
        console.error('Error fetching first page:', error);
      }

      console.log('Total products fetched:', allProducts.length);
      return allProducts;
    }

    function renderProducts(filteredProducts) {
      const productGrid = domElements.productGrid;
      domElements.productCount.textContent = `Showing ${filteredProducts.length} products`;

      // First, mark existing cards for fade out
      const existingCards = productGrid.querySelectorAll('.product-card');
      existingCards.forEach(card => card.classList.add('fade-out'));

      // Wait for fade out animation
      setTimeout(() => {
        // Clear the grid but maintain the few-items class if it should stay
        const shouldHaveFewItems = filteredProducts.length < 4;
        const hadFewItems = productGrid.classList.contains('few-items');
        
        // Only remove the few-items class if we're transitioning from few to many
        if (hadFewItems && !shouldHaveFewItems) {
          productGrid.classList.remove('few-items');
        }
        
        productGrid.innerHTML = '';

        if (!hadFewItems && shouldHaveFewItems) {
          productGrid.classList.add('few-items');
        }

        // Calculate initial load count
        const productWidth = 250;
        const gap = 20;
        const containerWidth = productGrid.offsetWidth;
        const productsPerRow = Math.floor(containerWidth / (productWidth + gap));
        const initialLoadCount = productsPerRow * 2;

        // Function to render a batch of products with staggered animation
        const renderBatch = (products, startIndex, endIndex) => {
          products.slice(startIndex, endIndex).forEach((product, index) => {
            const productCard = document.createElement('div');
            productCard.className = 'product-card';
            productCard.style.animationDelay = `${index * 50}ms`; // Stagger the animations
            
            // Get filtered variants based on current filters
            const processedVariants = utils.processVariants(product);
            let relevantVariants = processedVariants;
            
            if (domElements.strainFilter.value !== 'all') {
              relevantVariants = relevantVariants.filter(v => v.correctedTier === domElements.strainFilter.value);
            }
            if (domElements.weightFilter.value !== 'all') {
              relevantVariants = relevantVariants.filter(v => v.correctedWeight === domElements.weightFilter.value);
            }
            if (!domElements.stockFilter.classList.contains('active')) {
              relevantVariants = relevantVariants.filter(v => v.available);
            }

            productCard.addEventListener('click', (e) => {
              // Regular click behavior - go to product page
              let url = `https://litfarms.com/products/${product.handle}`;
              if (relevantVariants.length === 1) {
                url += `?variant=${relevantVariants[0].id}`;
              }
              window.open(url, '_blank');
            });

            // Strain type badge
            const strainType = getStrainType(product.body_html, product.handle, product.title);
            const strainTypeBadge = createStrainTypeBadge(strainType);
            productCard.appendChild(strainTypeBadge);
            productCard.style.position = 'relative';

            // Create and add product image
            const imageContainer = createProductImage(product, relevantVariants);
            productCard.appendChild(imageContainer);

            const productTitle = createProductTitle(product);
            productCard.appendChild(productTitle);

            const priceContainer = createPriceContainer(product, relevantVariants, domElements.strainFilter.value, domElements.weightFilter.value, domElements.stockFilter.classList.contains('active'));
            productCard.appendChild(priceContainer);

            const productDescription = createProductDescription(product);
            productCard.appendChild(productDescription);

            productGrid.appendChild(productCard);
          });
        };

        // Render first two rows immediately
        renderBatch(filteredProducts, 0, initialLoadCount);

        // Render the rest after a short delay
        if (filteredProducts.length > initialLoadCount) {
          setTimeout(() => {
            renderBatch(filteredProducts, initialLoadCount, filteredProducts.length);
          }, 300); // Wait for initial batch animations to complete
        }
      }, 200); // Match this with the fade-out transition duration
    }

    // Helper functions for rendering
    function createStrainTypeBadge(strainType) {
      const badge = document.createElement('div');
      badge.className = 'strain-type-badge';
      
      // Set badge color based on strain type
      switch(strainType) {
        case 'sativa':
          badge.style.backgroundColor = 'var(--strain-sativa)';
          badge.style.color = '#000';
          break;
        case 'indica':
          badge.style.backgroundColor = 'var(--strain-indica)';
          badge.style.color = '#fff';
          break;
        case 'hybrid':
          badge.style.backgroundColor = 'var(--strain-hybrid)';
          badge.style.color = '#fff';
          break;
        default:
          badge.style.backgroundColor = 'var(--strain-unknown)';
          badge.style.color = '#fff';
      }
      
      badge.textContent = strainType;
      return badge;
    }

    function createProductImage(product, relevantVariants) {
      const imageContainer = document.createElement('div');
      imageContainer.className = 'product-image-container';
      
      const imageWrapper = document.createElement('div');
      imageWrapper.className = 'image-wrapper';
      
      const image = document.createElement('img');
      image.className = 'product-image';
      image.alt = product.title;
      
      imageWrapper.appendChild(image);
      imageContainer.appendChild(imageWrapper);

      // Filter images based on variants
      let filteredImages = [];
      if (product.images && product.images.length > 0) {
        if (relevantVariants.length === product.variants.length) {
          // Show all images if all variants are selected
          filteredImages = [product.images[0]]; // Just use first image
        } else {
          // Get set of relevant variant IDs
          const relevantVariantIds = new Set(relevantVariants.map(v => v.id));
          
          // Try to find first image that matches a variant
          const variantImage = product.images.find(img => 
            img.variant_ids && 
            img.variant_ids.some(id => relevantVariantIds.has(id))
          );
          
          // Use variant image if found, otherwise use first product image
          filteredImages = [variantImage || product.images[0]];
        }
      }

      // Use placeholder if no images available
      if (filteredImages.length === 0) {
        filteredImages = [{ src: 'https://via.placeholder.com/300' }];
      }

      // Set the image source
      image.src = filteredImages[0].src;

      // Remove tabIndex and keyboard handlers since we're not navigating images
      imageContainer.removeAttribute('tabIndex');

      return imageContainer;
    }

    function createProductTitle(product) {
      const title = document.createElement('h2');
      title.className = 'product-title';
      title.textContent = product.title;
      return title;
    }

    function createPriceContainer(product, variants, strainFilter, weightFilter, stockFilter) {
      const container = document.createElement('div');
      container.className = 'price-container';

      // Group variants by tier
      const variantsByTier = {};
      TIERS.forEach(tier => {
        variantsByTier[tier] = [];
      });

      variants.forEach(variant => {
        if (variant.correctedTier && variant.correctedWeight) {
          variantsByTier[variant.correctedTier].push(variant);
        }
      });

      // Create sections for each tier
      TIERS.forEach(tier => {
        if (strainFilter !== 'all' && tier !== strainFilter) {
          return;
        }

        const tierVariants = variantsByTier[tier];
        if (tierVariants && tierVariants.length > 0) {
          const filteredVariants = tierVariants.filter(variant => {
            if (weightFilter !== 'all' && variant.correctedWeight !== weightFilter) {
              return false;
            }
            if (!stockFilter && !variant.available) {
              return false;
            }
            return true;
          });

          if (filteredVariants.length > 0) {
            const section = document.createElement('div');
            section.className = `variant-section variant-section-${tier.toLowerCase()}`;

            const title = document.createElement('div');
            title.className = `variant-title variant-title-${tier.toLowerCase()}`;
            title.textContent = tier;
            section.appendChild(title);

            const weights = document.createElement('div');
            weights.className = 'variant-weights';

            filteredVariants.forEach(variant => {
              const row = document.createElement('div');
              row.className = variant.available ? 'weight-row in-stock' : 'weight-row out-of-stock';
              
              // Add click handler to stop event propagation
              row.addEventListener('click', (e) => {
                e.stopPropagation();
              });

              const infoRow = document.createElement('div');
              infoRow.className = 'weight-info-row';

              const info = document.createElement('div');
              info.className = 'weight-info';

              const label = document.createElement('span');
              label.className = 'weight-label';
              label.textContent = variant.correctedWeight;

              const price = document.createElement('span');
              price.className = 'weight-price';
              price.textContent = `$${variant.price}`;

              info.appendChild(label);
              info.appendChild(price);
              infoRow.appendChild(info);

              const stockBadge = document.createElement('span');
              stockBadge.className = `stock-badge ${variant.available ? 'in-stock-badge' : 'out-of-stock-badge'}`;
              stockBadge.textContent = variant.available ? 'In Stock' : 'Out of Stock';

              row.appendChild(infoRow);
              row.appendChild(stockBadge);

              if (variant.available) {
                const addButton = document.createElement('button');
                addButton.className = 'add-to-cart-button';
                addButton.textContent = 'Add to Cart';
                addButton.onclick = (e) => {
                  e.stopPropagation();
                  virtualCart.addItem(product, variant);
                };
                row.appendChild(addButton);
              }

              weights.appendChild(row);
            });

            section.appendChild(weights);
            container.appendChild(section);
          }
        }
      });

      return container;
    }

    function createTierSection(tier, variants) {
      const section = document.createElement('div');
      section.className = `variant-section variant-section-${tier.toLowerCase()}`;

      const title = document.createElement('div');
      title.className = `variant-title variant-title-${tier.toLowerCase()}`;
      title.textContent = tier;
      section.appendChild(title);

      const weights = document.createElement('div');
      weights.className = 'variant-weights';

      // Create a map of weights to variants
      const weightMap = new Map(variants.map(v => [v.correctedWeight, v]));

      // Convert to array and sort by price (highest first)
      const sortedWeights = Array.from(weightMap.entries())
        .sort((a, b) => parseFloat(b[1].price) - parseFloat(a[1].price));

      sortedWeights.forEach(([weight, variant]) => {
        weights.appendChild(createWeightRow(variant));
      });

      section.appendChild(weights);
      return section;
    }

    function createWeightRow(variant) {
      const row = document.createElement('div');
      row.className = `weight-row ${variant.available ? 'in-stock' : 'out-of-stock'}`;
      
      // Add click handler to stop event propagation
      row.addEventListener('click', (e) => {
        e.stopPropagation();
      });

      const infoRow = document.createElement('div');
      infoRow.className = 'weight-info-row';

      const info = document.createElement('div');
      info.className = 'weight-info';

      const label = document.createElement('span');
      label.className = 'weight-label';
      label.textContent = variant.correctedWeight;

      const price = document.createElement('span');
      price.className = 'weight-price';
      price.textContent = `$${variant.price}`;

      info.appendChild(label);
      info.appendChild(price);
      infoRow.appendChild(info);

      const stockBadge = document.createElement('span');
      stockBadge.className = `stock-badge ${variant.available ? 'in-stock-badge' : 'out-of-stock-badge'}`;
      stockBadge.textContent = variant.available ? 'In Stock' : 'Out of Stock';

      row.appendChild(infoRow);
      row.appendChild(stockBadge);

      // Only add the Add to Cart button if the variant is in stock
      if (variant.available) {
        const addButton = document.createElement('button');
        addButton.className = 'add-to-cart-button';
        addButton.textContent = 'Add to Cart';
        addButton.onclick = (e) => {
          e.stopPropagation(); // Prevent product card click
          virtualCart.addItem(product, variant);
        };
        row.appendChild(addButton);
      }

      weights.appendChild(row);
      return row;
    }

    function createProductDescription(product) {
      const description = document.createElement('p');
      description.className = 'product-description';
      
      // Always use product description if it exists and is meaningful
      if (product.body_html) {
        const temp = document.createElement('div');
        temp.innerHTML = product.body_html;
        const plainText = temp.textContent
          .replace(/click here for product coa/gi, '')
          .replace(/\s+/g, ' ')
          .trim();
          
        if (plainText.length > 10) {
          description.innerHTML = product.body_html;
          return description;
        }
      }
      
      // Only fall back to manual strain description if no product description
      const cleanStrainName = product.title
        .replace(/\s*-?\s*THCA\s+Flower\s*$/i, '')
        .replace(/\s*-?\s*Flower\s*$/i, '')
        .replace(/\s*-?\s*\d+\.?\d*g\s*$/i, '')
        .replace(/-/g, '')
        .trim()
        .toLowerCase();

      const leaflyData = strainData[cleanStrainName];
      description.innerHTML = leaflyData?.description || 'No description available.';
      return description;
    }

    // Update filter function
    function filterProducts() {
      const strainFilter = domElements.strainFilter.value;
      const strainTypeFilter = domElements.strainTypeFilter.value;
      const weightFilter = domElements.weightFilter.value;
      const stockFilter = domElements.stockFilter.classList.contains('active');
      const searchQuery = domElements.searchInput.value.toLowerCase().trim();
      const sortFilter = domElements.sortFilter.value;

      const filteredProducts = products.filter((product) => {
        // Check search query first
        if (searchQuery && !product.title.toLowerCase().includes(searchQuery)) {
          return false;
        }

        // Process variants with utility function
        const correctedVariants = utils.processVariants(product);

        // If no valid variants at all, filter out the product
        if (correctedVariants.length === 0) {
          return false;
        }

        // Check if any variant matches the weight filter AND has a valid price
        if (weightFilter !== 'all') {
          const validWeightVariants = correctedVariants.filter(v => 
            v.correctedWeight === weightFilter && 
            v.hasPrice
          );
          if (validWeightVariants.length === 0) {
            return false;
          }
        }

        // Check if any variant matches the strain filter
        if (strainFilter !== 'all') {
          const validStrainVariants = correctedVariants.filter(v => 
            v.correctedTier === strainFilter && 
            (weightFilter === 'all' || v.correctedWeight === weightFilter) &&
            v.hasPrice
          );
          if (validStrainVariants.length === 0) {
            return false;
          }
        }

        // Check strain type
        if (strainTypeFilter !== 'all') {
          const productStrainType = getStrainType(product.body_html, product.handle, product.title);
          if (productStrainType !== strainTypeFilter) {
            return false;
          }
        }

        // Check stock status
        if (!stockFilter) {
          let stockCheckVariants = correctedVariants;
          if (weightFilter !== 'all') {
            stockCheckVariants = stockCheckVariants.filter(v => 
              v.correctedWeight === weightFilter && 
              v.hasPrice
            );
          }
          if (strainFilter !== 'all') {
            stockCheckVariants = stockCheckVariants.filter(v => v.correctedTier === strainFilter);
          }
          
          const hasInStockVariant = stockCheckVariants.some(variant => variant.available);
          if (!hasInStockVariant) {
            return false;
          }
        }

        return true;
      });

      // Sort the filtered products
      const sortedProducts = utils.sortProducts(filteredProducts, sortFilter, strainFilter, weightFilter);
      
      // Render the sorted products
      renderProducts(sortedProducts);
    }

    // Functions to handle filter state persistence
    function saveFilterState() {
      const filterState = {
        strainFilter: document.getElementById('strain-filter').value,
        strainTypeFilter: document.getElementById('strain-type-filter').value,
        weightFilter: document.getElementById('weight-filter').value,
        sortFilter: document.getElementById('sort-filter').value,
        stockFilter: document.getElementById('stock-filter').classList.contains('active')
      };
      localStorage.setItem('litFarmsFilterState', JSON.stringify(filterState));
    }

    function loadFilterState() {
      const savedState = localStorage.getItem('litFarmsFilterState');
      if (savedState) {
        const filterState = JSON.parse(savedState);
        
        // Restore select filters and update their styles
        const selects = {
          'strain-filter': filterState.strainFilter,
          'strain-type-filter': filterState.strainTypeFilter,
          'weight-filter': filterState.weightFilter,
          'sort-filter': filterState.sortFilter
        };

        Object.entries(selects).forEach(([id, value]) => {
          const select = document.getElementById(id);
          select.value = value;
          updateSelectStyle(select);
        });
        
        // Restore stock filter button state
        const stockButton = document.getElementById('stock-filter');
        if (filterState.stockFilter) {
          stockButton.classList.add('active');
          stockButton.textContent = 'Show All Items';
        } else {
          stockButton.classList.remove('active');
          stockButton.textContent = 'In Stock Only';
        }
      } else {
        // Set default state for first-time users: In Stock Only
        const stockButton = document.getElementById('stock-filter');
        stockButton.classList.remove('active');
        stockButton.textContent = 'In Stock Only';
      }

      // Always reset search input
      const searchInput = document.getElementById('product-search-filter');
      const clearSearchButton = document.getElementById('clear-search');
      searchInput.value = '';
      clearSearchButton.style.display = 'none';
    }

    // Event listeners for filters
    document.getElementById('strain-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    document.getElementById('strain-type-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    document.getElementById('weight-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    document.getElementById('sort-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    // Function to update select element style based on selection
    function updateSelectStyle(selectElement) {
      // Don't apply styles to the sort filter since it has no default option
      if (selectElement.id === 'sort-filter') {
        return;
      }
      
      if (selectElement.value === 'all') {
        selectElement.classList.remove('has-selection');
      } else {
        selectElement.classList.add('has-selection');
      }
    }

    document.getElementById('stock-filter').addEventListener('click', () => {
      const button = document.getElementById('stock-filter');
      button.classList.toggle('active');
      button.textContent = button.classList.contains('active') ? 'Show All Items' : 'In Stock Only';
      filterProducts();
      saveFilterState();
    });

    // Function to compare products and detect changes
    function detectProductChanges(oldProducts, newProducts) {
      log(LOG_LEVELS.INFO, '=== Starting Product Change Detection ===');
      log(LOG_LEVELS.INFO, `Old products count: ${oldProducts.length}`);
      log(LOG_LEVELS.INFO, `New products count: ${newProducts.length}`);

      // Helper function to check if a product matches current filters
      function matchesFilters(product) {
        const variants = utils.processVariants(product);
        
        // If specific products are selected, only check those
        if (currentSettings.specificProducts.length > 0) {
          return currentSettings.specificProducts.includes(product.handle);
        }

        // Check if any variant matches the tier and weight filters
        return variants.some(variant => {
          const matchesTier = currentSettings.notificationTiers.includes('all') ||
                            currentSettings.notificationTiers.includes(variant.correctedTier);
          const matchesWeight = currentSettings.notificationWeights.includes('all') ||
                              currentSettings.notificationWeights.includes(variant.correctedWeight);
          return matchesTier && matchesWeight;
        });
      }

      const changes = {
        new: [],
        stockChanged: [],
        removed: []
      };

      // Check for new products
      if (currentSettings.notifyNew) {
        const oldHandles = new Set(oldProducts.map(p => p.handle));
        const newlyAdded = newProducts.filter(p => !oldHandles.has(p.handle));
        
        newlyAdded.forEach(newProduct => {
          if (matchesFilters(newProduct)) {
            log(LOG_LEVELS.INFO, `New product detected: ${newProduct.title}`);
            changes.new.push(newProduct);
          }
        });
      }

      // Check for stock changes and variant changes
      if (currentSettings.notifyStock) {
        newProducts.forEach(newProduct => {
          const oldProduct = oldProducts.find(p => p.handle === newProduct.handle);
          if (oldProduct && matchesFilters(newProduct)) {
            const oldVariants = utils.processVariants(oldProduct);
            const newVariants = utils.processVariants(newProduct);

            let hasChanges = false;
            const changedVariants = [];

            // Check for changes in existing variants
            newVariants.forEach(newVariant => {
              const oldVariant = oldVariants.find(v => 
                v.correctedTier === newVariant.correctedTier && 
                v.correctedWeight === newVariant.correctedWeight
              );

              if (oldVariant) {
                if (oldVariant.available !== newVariant.available ||
                    oldVariant.price !== newVariant.price) {
                  hasChanges = true;
                  changedVariants.push({
                    ...newVariant,
                    oldPrice: oldVariant.price,
                    oldAvailable: oldVariant.available
                  });
                  log(LOG_LEVELS.INFO, `Variant change detected for ${newProduct.title}`, {
                    tier: newVariant.correctedTier,
                    weight: newVariant.correctedWeight,
                    oldPrice: oldVariant.price,
                    newPrice: newVariant.price,
                    oldAvailable: oldVariant.available,
                    newAvailable: newVariant.available
                  });
                }
              } else {
                // New variant added
                hasChanges = true;
                changedVariants.push(newVariant);
                log(LOG_LEVELS.INFO, `New variant added to ${newProduct.title}`, {
                  tier: newVariant.correctedTier,
                  weight: newVariant.correctedWeight,
                  price: newVariant.price,
                  available: newVariant.available
                });
              }
            });

            if (hasChanges) {
              changes.stockChanged.push({
                ...newProduct,
                changedVariants
              });
            }
          }
        });
      }

      // Check for removed products
      if (currentSettings.notifyRemoved) {
        const newHandles = new Set(newProducts.map(p => p.handle));
        oldProducts.forEach(oldProduct => {
          if (!newHandles.has(oldProduct.handle) && matchesFilters(oldProduct)) {
            log(LOG_LEVELS.INFO, `Product removed: ${oldProduct.title}`);
            changes.removed.push(oldProduct);
          }
        });
      }

      // Log summary of changes
      log(LOG_LEVELS.INFO, '=== Change Detection Summary ===', {
        newProducts: changes.new.length,
        stockChanges: changes.stockChanged.length,
        removedProducts: changes.removed.length
      });

      return changes;
    }

    // Function to send Ntfy notification
    async function sendNtfyNotification(title, message, priority = 3) {
      if (!NTFY_CONFIG.appEnabled && !NTFY_CONFIG.emailEnabled) {
        console.log('No notification methods enabled');
        return;
      }

      if (NTFY_CONFIG.appEnabled && !NTFY_CONFIG.topic) {
        console.log('App notifications enabled but no topic set');
        return;
      }

      if (NTFY_CONFIG.emailEnabled && !NTFY_CONFIG.email) {
        console.log('Email notifications enabled but no email set');
        return;
      }

      try {
        const headers = {
          'X-Title': title,
          'X-Priority': priority.toString(),
          'X-Tags': 'cannabis,stock'
        };

        // Email header
        if (NTFY_CONFIG.emailEnabled && NTFY_CONFIG.email) {
          headers['X-Email'] = NTFY_CONFIG.email;
        }

        // Send notification - we need a topic even for email-only notifications
        const topic = NTFY_CONFIG.appEnabled ? NTFY_CONFIG.topic : 'email-only-' + Math.random().toString(36).substring(7);
        
        const response = await fetch(`${NTFY_CONFIG.server}/${topic}`, {
          method: 'POST',
          headers: headers,
          body: message
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        console.log('Notification sent successfully');
      } catch (error) {
        console.error('Failed to send notification:', error);
      }
    }

    // Function to check if a variant matches notification settings
    function matchesNotificationFilters(variant) {
      const matchesTier = currentSettings.notificationTiers.includes('all') ||
                         currentSettings.notificationTiers.includes(variant.correctedTier);
      const matchesWeight = currentSettings.notificationWeights.includes('all') ||
                         currentSettings.notificationWeights.includes(variant.correctedWeight);
      return matchesTier && matchesWeight;
    }

    // Update handleNotifications function to filter based on settings
    async function handleNotifications(changes) {
      if (!changes.new.length && !changes.stockChanged.length && !changes.removed.length) {
        return;
      }

      // Filter changes based on notification settings
      const filteredChanges = {
        new: changes.new.filter(product => {
          const variants = utils.processVariants(product);
          return variants.some(variant => matchesNotificationFilters(variant));
        }),
        stockChanged: changes.stockChanged.filter(product => {
          // Only include products where changed variants match filters
          const filteredVariants = product.changedVariants.filter(variant => 
            matchesNotificationFilters(variant)
          );
          if (filteredVariants.length > 0) {
            // Update changedVariants to only include matching variants
            product.changedVariants = filteredVariants;
            return true;
          }
          return false;
        }),
        removed: changes.removed.filter(product => {
          const variants = utils.processVariants(product);
          return variants.some(variant => matchesNotificationFilters(variant));
        })
      };

      // Log all changes for record keeping
      log(LOG_LEVELS.INFO, '=== All Changes ===', changes);
      log(LOG_LEVELS.INFO, '=== Filtered Changes for Notifications ===', filteredChanges);

      // Only send notification if there are filtered changes and notifications are enabled
      if ((filteredChanges.new.length || filteredChanges.stockChanged.length || filteredChanges.removed.length) &&
          (NTFY_CONFIG.appEnabled || NTFY_CONFIG.emailEnabled)) {
        
        let ntfyMessage = '';
        
        if (filteredChanges.new.length && currentSettings.notifyNew) {
          ntfyMessage += `🌟 NEW PRODUCTS (${filteredChanges.new.length}) 🌟\n\n`;
          filteredChanges.new.forEach(p => {
            const matchingVariants = utils.processVariants(p).filter(v => matchesNotificationFilters(v));
            ntfyMessage += `🌿 ${p.title}\n`;
            matchingVariants.forEach(v => {
              ntfyMessage += `   • ${v.correctedTier} ${v.correctedWeight}\n`;
              ntfyMessage += `     💰 $${v.price} ${v.available ? '(In Stock)' : '(Out of Stock)'}\n`;
            });
            ntfyMessage += '\n';
          });
        }
        
        if (filteredChanges.stockChanged.length && currentSettings.notifyStock) {
          ntfyMessage += `📦 STOCK CHANGES (${filteredChanges.stockChanged.length}) 📦\n\n`;
          filteredChanges.stockChanged.forEach(p => {
            ntfyMessage += `🌿 ${p.title}\n\n`;
            
            // Get new variants (variants without oldPrice or oldAvailable)
            const newVariants = p.changedVariants.filter(v => !v.oldPrice && !v.oldAvailable);
            const nowInStock = p.changedVariants.filter(v => v.oldAvailable === false && v.available === true);
            const nowOutOfStock = p.changedVariants.filter(v => v.oldAvailable === true && v.available === false);
            const priceChanges = p.changedVariants.filter(v => v.oldPrice && v.price !== v.oldPrice);
            
            // New variants added
            if (newVariants.length > 0) {
              ntfyMessage += `   🆕 NEW VARIANTS ADDED:\n`;
              newVariants.forEach(v => {
                ntfyMessage += `      • ${v.correctedTier} ${v.correctedWeight}\n`;
                if (v.available) {
                  ntfyMessage += `        💰 $${v.price} (In Stock)\n`;
                } else {
                  ntfyMessage += `        💰 $${v.price} (Out of Stock)\n`;
                }
              });
              ntfyMessage += '\n';
            }
            
            if (nowInStock.length > 0) {
              ntfyMessage += `   ✅ NOW IN STOCK:\n`;
              nowInStock.forEach(v => {
                ntfyMessage += `      • ${v.correctedTier} ${v.correctedWeight}\n        💰 $${v.price}\n`;
              });
              ntfyMessage += '\n';
            }
            
            if (nowOutOfStock.length > 0) {
              ntfyMessage += `   ❌ NOW OUT OF STOCK:\n`;
              nowOutOfStock.forEach(v => {
                ntfyMessage += `      • ${v.correctedTier} ${v.correctedWeight}\n        💰 $${v.price}\n`;
              });
              ntfyMessage += '\n';
            }

            if (priceChanges.length > 0) {
              ntfyMessage += `   💰 PRICE CHANGES:\n`;
              priceChanges.forEach(v => {
                const priceChange = parseFloat(v.oldPrice) - parseFloat(v.price);
                const changeSymbol = priceChange > 0 ? '↓' : '↑';
                ntfyMessage += `      • ${v.correctedTier} ${v.correctedWeight}\n`;
                ntfyMessage += `        Was: $${v.oldPrice} → Now: $${v.price} ${changeSymbol}\n`;
                ntfyMessage += `        ${Math.abs(priceChange).toFixed(2)} ${priceChange > 0 ? 'decrease' : 'increase'}\n`;
              });
              ntfyMessage += '\n';
            }
          });
        }
        
        if (filteredChanges.removed.length && currentSettings.notifyRemoved) {
          ntfyMessage += `🚫 REMOVED PRODUCTS (${filteredChanges.removed.length}) 🚫\n\n`;
          filteredChanges.removed.forEach(p => {
            const matchingVariants = utils.processVariants(p).filter(v => matchesNotificationFilters(v));
            ntfyMessage += `❌ ${p.title}\n`;
            matchingVariants.forEach(v => {
              ntfyMessage += `   • ${v.correctedTier} ${v.correctedWeight}\n`;
            });
            ntfyMessage += '\n';
          });
        }
        
        if (ntfyMessage) {
          ntfyMessage += `\n🕒 Updated: ${new Date().toLocaleString()}`;
          await sendNtfyNotification('LitFarms Update', ntfyMessage);
        }
      }
    }

    // Update the startProductUpdateChecker function
    function startProductUpdateChecker() {
      let lastProducts = products;
      const intervalMs = currentSettings.checkInterval * 60 * 1000;

      console.log(`Starting product update checker - checking every ${currentSettings.checkInterval} minutes`);

      // Start the countdown timer and get cleanup function
      const countdownCleanup = startCountdownTimer(intervalMs);
      
      // Add countdown timer cleanup to pageCleanupHandlers
      pageCleanupHandlers.push(countdownCleanup);

      updateCheckerId = setInterval(async () => {
        try {
          const freshProducts = await getProducts();
          const changes = detectProductChanges(lastProducts, freshProducts);
          
          if (changes.new.length > 0 || changes.stockChanged.length > 0 || changes.removed.length > 0) {
            console.log('Changes detected, updating state and sending notifications...');
            await handleNotifications(changes);
            products = freshProducts;
            lastProducts = freshProducts;
            filterProducts();
            updateProductSelectList();
          }
        } catch (error) {
          console.error('Error checking for product updates:', error);
        }
      }, intervalMs);

      return updateCheckerId;
    }

    // Filter THCA products
    function filterTHCAProducts(products) {
      const thcaProducts = products.filter(product => 
        product.title.toLowerCase().includes('thca') || 
        product.tags.includes('thca') || 
        product.product_type === 'THCA Flower'
      );
      //console.log(`Filtered ${products.length} total products to ${thcaProducts.length} THCA products`);
      return thcaProducts;
    }

    // Update the preloadImages function to remove text updates
    function preloadImages(products) {
      return Promise.all(products.map(product => {
        if (!product.images[0]?.src) return Promise.resolve();
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => resolve();
          img.onerror = () => resolve();
          img.src = product.images[0].src;
        });
      }));
    }

    // Add cleanup handler for page unload
    let pageCleanupHandlers = [];
    
    window.addEventListener('beforeunload', () => {
      // Execute all cleanup handlers
      pageCleanupHandlers.forEach(handler => {
        try {
          handler();
        } catch (error) {
          console.warn('Cleanup handler error:', error);
        }
      });
    });

    // Update attemptLoad function with cleanup
    async function attemptLoad() {
      let imagePreloadAbortController = new AbortController();
      
      // Add cleanup handler
      pageCleanupHandlers.push(() => {
        imagePreloadAbortController.abort();
        if (updateCheckerId) {
          clearInterval(updateCheckerId);
        }
      });

      try {
        // Load notification settings first
        loadSettings();
        
        // First try to load cached products immediately
        products = await getProducts(true);
        
        if (Array.isArray(products) && products.length > 0) {
          console.log(`Loaded ${products.length} cached THCA products`);
          loadFilterState();
          await loadStrainData();
          
          // Show products immediately
          toggleLoader(false);
          filterProducts();
          
          // Then check for updates in the background
          try {
            const updatedProducts = await getProducts(false);
            if (JSON.stringify(products) !== JSON.stringify(updatedProducts)) {
              console.log('Products updated, refreshing display');
              products = updatedProducts;
              filterProducts();
            }
          } catch (updateError) {
            console.warn('Background update failed:', updateError);
            // Continue with cached data
          }
        } else {
          // No cached products, load fresh
          products = await getProducts(false);
          if (!Array.isArray(products) || products.length === 0) {
            throw new Error('No products loaded');
          }
          
          console.log(`Loaded ${products.length} fresh THCA products`);
          loadFilterState();
          await loadStrainData();
          
          // Preload images with timeout and abort controller
          try {
            const filteredProducts = products.filter(() => true);
            await Promise.race([
              preloadImages(filteredProducts, imagePreloadAbortController.signal),
              new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Image preload timeout')), 5000);
              })
            ]);
          } catch (preloadError) {
            console.warn('Image preload incomplete:', preloadError);
            // Continue without complete preload
          }
          
          toggleLoader(false);
          filterProducts();
        }

        // Start the update checker
        startProductUpdateChecker();
        
      } catch (error) {
        console.error('Error in initialization:', error);
        
        if (retryCount < maxRetries) {
          retryCount++;
          console.log(`Retrying... Attempt ${retryCount} of ${maxRetries}`);
          
          // Clear cache before retrying
          localStorage.removeItem(CACHE_KEY);
          localStorage.removeItem(CACHE_TIMESTAMP_KEY);
          
          // Wait a bit before retrying
          await new Promise(resolve => setTimeout(resolve, 1000));
          return attemptLoad();
        }
        
        const productGrid = document.getElementById('product-grid');
        productGrid.innerHTML = `
          <div style="text-align: center; padding: 20px;">
            <p style="color: var(--status-error); margin-bottom: 15px;">
              Error loading products. Please try refreshing the page.
            </p>
            <button onclick="window.location.reload()" style="
              background-color: var(--accent-primary);
              color: var(--bg-primary);
              border: none;
              padding: 10px 20px;
              border-radius: 5px;
              cursor: pointer;
            ">
              Refresh Page
            </button>
          </div>`;
        toggleLoader(false);
      }
    }

    // Update preloadImages function to accept abort signal
    function preloadImages(products, signal) {
      return Promise.all(products.map(product => {
        if (!product.images[0]?.src) return Promise.resolve();
        return new Promise((resolve, reject) => {
          const img = new Image();
          
          // Handle abort signal
          if (signal) {
            signal.addEventListener('abort', () => {
              img.src = '';
              resolve(); // Resolve instead of reject to avoid error logging
            });
          }
          
          img.onload = () => resolve();
          img.onerror = () => resolve(); // Resolve on error to continue loading
          img.src = product.images[0].src;
        });
      }));
    }

    // Document ready event listener
    document.addEventListener('DOMContentLoaded', async () => {
      toggleLoader(true);

      // Settings modal
      document.getElementById('settings-button').addEventListener('click', openSettingsModal);
      document.querySelector('.close-modal').addEventListener('click', closeSettingsModal);
      document.querySelector('.save-settings').addEventListener('click', saveSettingsFromForm);

      // Track mousedown position for modal
      let modalMouseDown = false;
      const modal = document.getElementById('settings-modal');
      
      modal.addEventListener('mousedown', (e) => {
        if (e.target === modal) {
          modalMouseDown = true;
        }
      });

      modal.addEventListener('mouseup', (e) => {
        if (e.target === modal && modalMouseDown) {
          closeSettingsModal();
        }
        modalMouseDown = false;
      });

      // Reset flag when mouse leaves modal
      modal.addEventListener('mouseleave', () => {
        modalMouseDown = false;
      });

      let retryCount = 0;
      const maxRetries = 3;

      await attemptLoad();
    });

    function updateProductSelectList() {
      const productSelect = document.getElementById('product-select');
      productSelect.innerHTML = '';

      // Sort products alphabetically by title
      const sortedProducts = [...products].sort((a, b) => 
        a.title.toLowerCase().localeCompare(b.title.toLowerCase())
      );

      sortedProducts.forEach(product => {
        const item = document.createElement('div');
        item.className = 'product-select-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `product-${product.handle}`;
        checkbox.value = product.handle;
        checkbox.checked = currentSettings.specificProducts.includes(product.handle);
        
        const label = document.createElement('label');
        label.htmlFor = `product-${product.handle}`;
        label.textContent = product.title;
        
        item.appendChild(checkbox);
        item.appendChild(label);
        productSelect.appendChild(item);
      });

      // Search functionality
      const searchInput = document.getElementById('product-search');
      
      function filterProducts(searchTerm) {
        const items = productSelect.getElementsByClassName('product-select-item');
        const term = searchTerm.toLowerCase();
        
        Array.from(items).forEach(item => {
          const label = item.querySelector('label');
          const title = label.textContent.toLowerCase();
          
          if (title.includes(term)) {
            item.classList.remove('hidden');
          } else {
            item.classList.add('hidden');
          }
        });
      }

      // Search event listener
      searchInput.addEventListener('input', (e) => {
        filterProducts(e.target.value);
      });

      // Clear search when modal is opened
      searchInput.value = '';
      filterProducts('');
    }

    // Settings Modal Management
    function openSettingsModal() {
      const modal = document.getElementById('settings-modal');
      modal.style.display = 'flex';
      
      // Load current settings into form
      document.getElementById('check-interval').value = currentSettings.checkInterval;
      document.getElementById('ntfy-enabled').checked = currentSettings.ntfyAppEnabled;
      document.getElementById('email-enabled').checked = currentSettings.ntfyEmailEnabled;
      document.getElementById('ntfy-topic').value = currentSettings.ntfyTopic;
      document.getElementById('ntfy-server').value = currentSettings.ntfyServer;
      document.getElementById('ntfy-email').value = currentSettings.ntfyEmail;
      
      // Update the minutes suffix position immediately after setting the value
      requestAnimationFrame(updateMinutesSuffixPosition);
      
      // Set multiple select values
      const tierSelect = document.getElementById('notification-tier');
      const weightSelect = document.getElementById('notification-weight');

      // Clear previous selections
      Array.from(tierSelect.options).forEach(option => option.selected = false);
      Array.from(weightSelect.options).forEach(option => option.selected = false);
      
      // Set new selections
      currentSettings.notificationTiers.forEach(tier => {
        const option = Array.from(tierSelect.options).find(opt => opt.value === tier);
        if (option) option.selected = true;
      });
      
      currentSettings.notificationWeights.forEach(weight => {
        const option = Array.from(weightSelect.options).find(opt => opt.value === weight);
        if (option) option.selected = true;
      });
      
      // If nothing is selected, select 'all' by default
      if (!Array.from(tierSelect.selectedOptions).length) {
        tierSelect.querySelector('option[value="all"]').selected = true;
      }
      if (!Array.from(weightSelect.selectedOptions).length) {
        weightSelect.querySelector('option[value="all"]').selected = true;
      }
      
      // Set checkboxes
      document.getElementById('notify-new').checked = currentSettings.notifyNew;
      document.getElementById('notify-stock').checked = currentSettings.notifyStock;
      document.getElementById('notify-removed').checked = currentSettings.notifyRemoved;
      
      // Update product list and clear search
      updateProductSelectList();

      document.body.classList.add('modal-open');
    }

    function closeSettingsModal() {
      document.getElementById('settings-modal').style.display = 'none';
      document.body.classList.remove('modal-open');
    }

    function getSelectedValues(selectElement) {
      const selectedValues = Array.from(selectElement.selectedOptions).map(option => option.value);
      // If nothing is selected or only 'all' is selected, return ['all']
      return selectedValues.length === 0 ? ['all'] : selectedValues;
    }

    function saveSettingsFromForm() {
      const newSettings = {
        checkInterval: parseInt(document.getElementById('check-interval').value) || DEFAULT_SETTINGS.checkInterval,
        notificationTiers: getSelectedValues(document.getElementById('notification-tier')),
        notificationWeights: getSelectedValues(document.getElementById('notification-weight')),
        notifyNew: document.getElementById('notify-new').checked,
        notifyStock: document.getElementById('notify-stock').checked,
        notifyRemoved: document.getElementById('notify-removed').checked,
        specificProducts: Array.from(document.querySelectorAll('#product-select input:checked')).map(cb => cb.value),
        ntfyAppEnabled: document.getElementById('ntfy-enabled').checked,
        ntfyEmailEnabled: document.getElementById('email-enabled').checked,
        ntfyTopic: document.getElementById('ntfy-topic').value.trim(),
        ntfyServer: document.getElementById('ntfy-server').value.trim() || DEFAULT_SETTINGS.ntfyServer,
        ntfyEmail: document.getElementById('ntfy-email').value.trim()
      };

      // Update Ntfy config
      NTFY_CONFIG.appEnabled = newSettings.ntfyAppEnabled;
      NTFY_CONFIG.emailEnabled = newSettings.ntfyEmailEnabled;
      NTFY_CONFIG.topic = newSettings.ntfyTopic;
      NTFY_CONFIG.server = newSettings.ntfyServer;
      NTFY_CONFIG.email = newSettings.ntfyEmail;

      // Log the settings being saved
      console.log('Saving settings:', newSettings);

      saveSettings(newSettings);
      closeSettingsModal();
    }

    // Event listeners for the multiple selects
    document.addEventListener('DOMContentLoaded', () => {
      const tierSelect = document.getElementById('notification-tier');
      const weightSelect = document.getElementById('notification-weight');

      function handleAllOption(selectElement) {
        selectElement.addEventListener('change', (e) => {
          const allOption = selectElement.querySelector('option[value="all"]');
          const otherOptions = Array.from(selectElement.options).filter(opt => opt.value !== 'all');
          
          if (allOption.selected) {
            // If 'all' is selected, deselect other options
            otherOptions.forEach(opt => opt.selected = false);
          } else if (Array.from(selectElement.selectedOptions).length === 0) {
            // If nothing is selected, select 'all'
            allOption.selected = true;
          } else {
            // If other options are selected, deselect 'all'
            allOption.selected = false;
          }
        });
      }

      handleAllOption(tierSelect);
      handleAllOption(weightSelect);
    });



    // Dynamic suffix positioning
    function updateMinutesSuffixPosition() {
      const input = document.getElementById('check-interval');
      const suffix = input.nextElementSibling;
      const valueLength = input.value.length;
      const basePosition = 28; // Base position for single digit
      const digitWidth = 8; // Approximate width per digit
      
      // Calculate new position based on number of digits
      const newPosition = basePosition + (valueLength - 1) * digitWidth;
      suffix.style.left = `${newPosition}px`;
    }

    // Event listeners for the check interval input
    document.addEventListener('DOMContentLoaded', () => {
      const checkIntervalInput = document.getElementById('check-interval');
      
      // Update position on any input change
      checkIntervalInput.addEventListener('input', updateMinutesSuffixPosition);
      
      // Initial position
      updateMinutesSuffixPosition();
    });

    // Test Ntfy notification
    let testButtonCooldown = false;
    const COOLDOWN_PERIOD = 30000; // 10 seconds in milliseconds

    async function testNtfyNotification() {
      if (testButtonCooldown) {
        return;
      }

      // Get current form values instead of using saved settings
      const appEnabled = document.getElementById('ntfy-enabled').checked;
      const emailEnabled = document.getElementById('email-enabled').checked;
      const topic = document.getElementById('ntfy-topic').value.trim();
      const server = document.getElementById('ntfy-server').value.trim() || DEFAULT_SETTINGS.ntfyServer;
      const email = document.getElementById('ntfy-email').value.trim();

      if (!appEnabled && !emailEnabled) {
        alert('Please enable at least one notification method');
        return;
      }

      if (appEnabled && !topic) {
        alert('Please set a topic for app notifications');
        return;
      }

      if (emailEnabled && !email) {
        alert('Please set an email address for email notifications');
        return;
      }

      const testButton = document.getElementById('test-ntfy');
      testButton.disabled = true;
      testButton.textContent = 'Sending...';

      // Set cooldown flag
      testButtonCooldown = true;

      try {
        // Create temporary config for test
        const tempConfig = {
          appEnabled: appEnabled,
          emailEnabled: emailEnabled,
          topic: topic,
          server: server,
          email: email
        };

        // Store current config
        const originalConfig = { ...NTFY_CONFIG };
        
        // Temporarily set config to form values
        Object.assign(NTFY_CONFIG, tempConfig);

        const testMessage = `🌟 NEW PRODUCTS (2) 🌟

🌿 Blue Dream THCA Flower
   • Essential 28g
     💰 $49.99

🌿 Purple Punch THCA Flower
   • Supreme 28g
     💰 $89.99


📦 STOCK CHANGES (2) 📦

🌿 Gelato THCA Flower

   ✅ NOW IN STOCK:
      • Essential 28g
        💰 $49.99

   ❌ NOW OUT OF STOCK:
      • Preferred 28g
        💰 $69.99


🌿 Wedding Cake THCA Flower

   ✅ NOW IN STOCK:
      • Supreme 28g
        💰 $89.99


🚫 REMOVED PRODUCTS (1) 🚫

❌ Northern Lights THCA Flower


🕒 Updated: ${new Date().toLocaleString()}`;

        await sendNtfyNotification(
          'LitFarms Test Notification',
          testMessage
        );
        testButton.textContent = 'Notification Sent!';

        // Restore original config
        Object.assign(NTFY_CONFIG, originalConfig);
      } catch (error) {
        console.error('Failed to send test notification:', error);
        testButton.textContent = 'Error!';
        
        // Restore original config in case of error
        Object.assign(NTFY_CONFIG, originalConfig);
      }

      // Start cooldown timer
      setTimeout(() => {
        testButtonCooldown = false;
        testButton.disabled = false;
        testButton.textContent = 'Test Notifications';
      }, COOLDOWN_PERIOD);

      // Countdown timer
      let remainingTime = COOLDOWN_PERIOD / 1000;
      const countdownInterval = setInterval(() => {
        remainingTime--;
        if (remainingTime > 0) {
          testButton.textContent = `Wait ${remainingTime}s`;
        } else {
          clearInterval(countdownInterval);
        }
      }, 1000);
    }

    // Update selected products count
    function updateSelectedProductsCount() {
      const selectedCount = document.querySelectorAll('#product-select input:checked').length;
      const countElement = document.getElementById('products-selected-count');
      countElement.textContent = `${selectedCount} product${selectedCount === 1 ? '' : 's'} selected`;
    }

    // Deselect all products
    function deselectAllProducts() {
      const checkboxes = document.querySelectorAll('#product-select input[type="checkbox"]');
      checkboxes.forEach(checkbox => {
        checkbox.checked = false;
      });
      updateSelectedProductsCount();
    }

    // Update the updateProductSelectList function to include count updates
    function updateProductSelectList() {
      const productSelect = document.getElementById('product-select');
      productSelect.innerHTML = '';

      // Sort products alphabetically by title
      const sortedProducts = [...products].sort((a, b) => 
        a.title.toLowerCase().localeCompare(b.title.toLowerCase())
      );

      sortedProducts.forEach(product => {
        const item = document.createElement('div');
        item.className = 'product-select-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `product-${product.handle}`;
        checkbox.value = product.handle;
        checkbox.checked = currentSettings.specificProducts.includes(product.handle);
        
        // Update count
        checkbox.addEventListener('change', updateSelectedProductsCount);
        
        const label = document.createElement('label');
        label.htmlFor = `product-${product.handle}`;
        label.textContent = product.title;
        
        item.appendChild(checkbox);
        item.appendChild(label);
        productSelect.appendChild(item);
      });

      // Update initial count
      updateSelectedProductsCount();

      // Search functionality
      const searchInput = document.getElementById('product-search');
      
      function filterProducts(searchTerm) {
        const items = productSelect.getElementsByClassName('product-select-item');
        const term = searchTerm.toLowerCase();
        
        Array.from(items).forEach(item => {
          const label = item.querySelector('label');
          const title = label.textContent.toLowerCase();
          
          if (title.includes(term)) {
            item.classList.remove('hidden');
          } else {
            item.classList.add('hidden');
          }
        });
      }

      // Search event listener
      searchInput.addEventListener('input', (e) => {
        filterProducts(e.target.value);
      });

      // Clear search when modal is opened
      searchInput.value = '';
      filterProducts('');
    }

    // Topic name arrays
    const ADJECTIVES = ['swift', 'bright', 'cosmic', 'mystic', 'golden', 'silver', 'crystal', 'azure', 'crimson', 'emerald'];
    const NOUNS = ['phoenix', 'dragon', 'falcon', 'tiger', 'wolf', 'eagle', 'lion', 'hawk', 'panther', 'bear'];
    
    // Random topic name generator
    function generateRandomTopic() {
      // Get random elements from arrays
      const adjective = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
      const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
      
      // Generate random numbers (4 digits)
      const numbers = Math.floor(1000 + Math.random() * 9000);
      
      // Generate random letters (2 characters)
      const letters = String.fromCharCode(65 + Math.floor(Math.random() * 26)) + 
                     String.fromCharCode(65 + Math.floor(Math.random() * 26));
      
      // Combine everything with dashes
      const topic = `litfarms-${adjective}-${noun}-${numbers}${letters}`;
      
      // Set the value in the input field
      document.getElementById('ntfy-topic').value = topic;
    }

    // Clear search functionality
    const clearSearchButton = document.getElementById('clear-search');
    const searchInput = document.getElementById('product-search-filter');

    // Show/hide clear button based on search input content
    searchInput.addEventListener('input', () => {
      clearSearchButton.style.display = searchInput.value ? 'flex' : 'none';
      filterProducts();
      saveFilterState();
    });

    // Move cursor to end when input receives focus
    searchInput.addEventListener('focus', () => {
      const length = searchInput.value.length;
      searchInput.setSelectionRange(length, length);
    });

    // Close keyboard on enter key press
    searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        searchInput.blur(); // This will close the keyboard on mobile
      }
    });

    // Clear search when button is clicked
    clearSearchButton.addEventListener('click', () => {
      searchInput.value = '';
      clearSearchButton.style.display = 'none';
      filterProducts();
      saveFilterState();
    });

    // Utility Functions
    const WEIGHTS = ['28g', '3.5g', '7g'];
    const TIERS = ['Essential', 'Preferred', 'Supreme'];
    
    const utils = {
      isWeight: (value) => value && WEIGHTS.includes(value),
      isTier: (value) => value && TIERS.includes(value),
      hasValidPrice: (variant) => variant.price && !isNaN(parseFloat(variant.price)) && parseFloat(variant.price) > 0,
      
      standardizeWeight: (weightStr) => {
        if (!weightStr) return null;
        weightStr = weightStr.trim();
        if (weightStr.match(/^\d+\.?\d*$/)) weightStr += 'g';
        if (weightStr === '3.5') weightStr = '3.5g';
        return weightStr;
      },
      
      processVariants: (product) => {
        return product.variants.map(v => {
          const weight = utils.isWeight(v.option1) ? v.option1 : utils.isWeight(v.option2) ? v.option2 : null;
          let tier = utils.isTier(v.option1) ? v.option1 : utils.isTier(v.option2) ? v.option2 : null;
          if (weight && !tier) tier = 'Essential';
          return {
            ...v,
            correctedWeight: weight,
            correctedTier: tier,
            hasPrice: utils.hasValidPrice(v)
          };
        }).filter(v => v.correctedWeight && v.hasPrice);
      },
      
      getVariantKey: (variant) => 
        `${variant.correctedTier}-${variant.correctedWeight}-${variant.price}-${variant.available}`,
        
      extractTierAndWeight: (str) => {
        const parts = str.split('/').map(s => s.trim());
        const weightPart = parts.find(p => utils.isWeight(utils.standardizeWeight(p)));
        const tierPart = parts.find(p => TIERS.includes(p));
        return { 
          weight: weightPart ? utils.standardizeWeight(weightPart) : null, 
          tier: tierPart 
        };
      },

      sortProducts: (products, sortFilter, strainFilter, weightFilter) => {
        return [...products].sort((a, b) => {
          switch (sortFilter) {
            case 'alpha-asc':
              return a.title.localeCompare(b.title);
            case 'alpha-desc':
              return b.title.localeCompare(a.title);
            case 'date-desc':
              return new Date(b.published_at) - new Date(a.published_at);
            case 'date-asc':
              return new Date(a.published_at) - new Date(b.published_at);
            case 'price-asc':
            case 'price-desc': {
              // Get valid variants for both products
              const aVariants = utils.processVariants(a);
              const bVariants = utils.processVariants(b);

              // Filter variants based on current filters
              let relevantAVariants = aVariants;
              let relevantBVariants = bVariants;

              if (weightFilter !== 'all') {
                relevantAVariants = relevantAVariants.filter(v => v.correctedWeight === weightFilter);
                relevantBVariants = relevantBVariants.filter(v => v.correctedWeight === weightFilter);
              }
              if (strainFilter !== 'all') {
                relevantAVariants = relevantAVariants.filter(v => v.correctedTier === strainFilter);
                relevantBVariants = relevantBVariants.filter(v => v.correctedTier === strainFilter);
              }
              
              // If in "In Stock Only" mode, only consider available variants
              if (!domElements.stockFilter.classList.contains('active')) {
                relevantAVariants = relevantAVariants.filter(v => v.available);
                relevantBVariants = relevantBVariants.filter(v => v.available);
              }

              // If no relevant variants after filtering, push to end of sort
              if (relevantAVariants.length === 0) return 1;
              if (relevantBVariants.length === 0) return -1;

              // Get the min/max prices for comparison
              const aPrice = relevantAVariants.length ? 
                (sortFilter === 'price-asc' ? 
                  Math.min(...relevantAVariants.map(v => parseFloat(v.price))) : 
                  Math.max(...relevantAVariants.map(v => parseFloat(v.price)))) : 
                Infinity;
              const bPrice = relevantBVariants.length ? 
                (sortFilter === 'price-asc' ? 
                  Math.min(...relevantBVariants.map(v => parseFloat(v.price))) : 
                  Math.max(...relevantBVariants.map(v => parseFloat(v.price)))) : 
                Infinity;

              // If prices are equal, sort alphabetically
              if (aPrice === bPrice) {
                return a.title.localeCompare(b.title);
              }

              return sortFilter === 'price-asc' ? aPrice - bPrice : bPrice - aPrice;
            }
            default:
              return 0;
          }
        });
      }
    };

    // Cache frequently accessed DOM elements
    const domElements = {
      productGrid: document.getElementById('product-grid'),
      productCount: document.getElementById('product-count'),
      strainFilter: document.getElementById('strain-filter'),
      strainTypeFilter: document.getElementById('strain-type-filter'),
      weightFilter: document.getElementById('weight-filter'),
      sortFilter: document.getElementById('sort-filter'),
      stockFilter: document.getElementById('stock-filter'),
      searchInput: document.getElementById('product-search-filter'),
      clearSearch: document.getElementById('clear-search'),
      loader: document.getElementById('loader'),
      settingsModal: document.getElementById('settings-modal')
    };

    // Constants for logging
    const LOG_LEVELS = {
      INFO: 'INFO',
      WARN: 'WARN',
      ERROR: 'ERROR'
    };

    function log(level, message, data = null) {
      const logMessage = `${message}`;
      
      switch(level) {
        case LOG_LEVELS.ERROR:
          data ? console.error(logMessage, data) : console.error(logMessage);
          break;
        case LOG_LEVELS.WARN:
          data ? console.warn(logMessage, data) : console.warn(logMessage);
          break;
        default:
          data ? console.log(logMessage, data) : console.log(logMessage);
      }
    }

    // Update startCountdownTimer function for better state management
    function startCountdownTimer(intervalMs) {
      const countdownEl = document.querySelector('.countdown-time');
      const tooltipTimeEl = document.querySelector('.tooltip-time');
      const progressCircle = document.querySelector('.progress');
      const circumference = 2 * Math.PI * 16; // r = 16
      
      // Reset all visual elements first
      progressCircle.style.strokeDasharray = circumference;
      progressCircle.style.strokeDashoffset = 0;
      countdownEl.textContent = '';
      tooltipTimeEl.textContent = '';
      
      let timeLeft = intervalMs;
      let timerId = null;
      let isActive = true; // Track if this timer instance is active
      
      function updateCountdown() {
        // Only update if this timer instance is still active
        if (!isActive) return;
        
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        countdownEl.textContent = display;
        tooltipTimeEl.textContent = display;
        
        // Update progress circle
        const progress = (timeLeft / intervalMs) * 100;
        const offset = circumference - (progress / 100) * circumference;
        progressCircle.style.strokeDashoffset = offset;
        
        timeLeft -= 1000;
        
        if (timeLeft < 0) {
          timeLeft = intervalMs;
        }
      }
      
      // Initial update
      updateCountdown();
      
      // Start the interval
      timerId = setInterval(updateCountdown, 1000);
      
      // Return cleanup function
      return () => {
        isActive = false; // Mark this timer instance as inactive
        if (timerId) {
          clearInterval(timerId);
          timerId = null;
        }
        // Reset visual elements on cleanup
        countdownEl.textContent = '';
        tooltipTimeEl.textContent = '';
        progressCircle.style.strokeDashoffset = 0;
      };
    }

    // Virtual Cart State
    const virtualCart = {
      items: [],
      
      addItem(product, variant) {
        // Add visual feedback to the clicked button
        const clickedButton = document.activeElement;
        if (clickedButton && clickedButton.classList.contains('add-to-cart-button')) {
          clickedButton.classList.add('clicked');
          setTimeout(() => clickedButton.classList.remove('clicked'), 300);
        }

        const existingItemIndex = this.items.findIndex(item => item.variantId === variant.id);
        
        if (existingItemIndex !== -1) {
          // Update quantity of existing item
          this.items[existingItemIndex].quantity += 1;
        } else {
          // Add new item with quantity 1
          this.items.push({
            productId: product.id,
            productTitle: product.title,
            variantId: variant.id,
            variantTitle: `${variant.correctedTier} ${variant.correctedWeight}`,
            price: parseFloat(variant.price),
            available: variant.available,
            quantity: 1
          });
        }

        // Add visual feedback to the cart icon
        const cartButton = document.getElementById('virtual-cart-button');
        cartButton.classList.add('pulse');
        setTimeout(() => cartButton.classList.remove('pulse'), 500);

        this.updateUI();
        this.saveToLocalStorage();
      },

      updateQuantity(index, newQuantity) {
        if (newQuantity > 0) {
          this.items[index].quantity = newQuantity;
          this.updateUI();
          this.saveToLocalStorage();
        } else {
          this.removeItem(index);
        }
      },

      removeItem(index) {
        this.items.splice(index, 1);
        this.updateUI();
        this.saveToLocalStorage();
      },

      clearCart() {
        this.items = [];
        this.updateUI();
        this.saveToLocalStorage();
      },

      updateUI() {
        // Update cart count (sum of all quantities)
        const cartCount = document.querySelector('.cart-count');
        const totalItems = this.items.reduce((sum, item) => sum + item.quantity, 0);
        cartCount.textContent = totalItems;

        // Update cart modal contents
        const cartItems = document.getElementById('cart-items');
        const cartTotal = document.getElementById('cart-total');
        
        if (this.items.length === 0) {
          cartItems.innerHTML = '<div class="empty-cart-message">Your cart is empty</div>';
          cartTotal.textContent = '0.00';
          return;
        }

        cartItems.innerHTML = this.items.map((item, index) => `
          <div class="cart-item">
            <div class="cart-item-info">
              <div class="cart-item-title">${item.productTitle}</div>
              <div class="cart-item-variant">${item.variantTitle}</div>
              <div class="cart-item-price">$${(item.price * item.quantity).toFixed(2)}</div>
            </div>
            <div class="cart-item-controls">
              <div class="quantity-controls">
                <button class="quantity-btn" onclick="virtualCart.updateQuantity(${index}, ${item.quantity - 1})">-</button>
                <span class="quantity-display">${item.quantity}</span>
                <button class="quantity-btn" onclick="virtualCart.updateQuantity(${index}, ${item.quantity + 1})">+</button>
              </div>
              <button class="remove-from-cart" onclick="virtualCart.removeItem(${index})">×</button>
            </div>
          </div>
        `).join('');

        // Update total
        const total = this.items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
        cartTotal.textContent = total.toFixed(2);
      },

      saveToLocalStorage() {
        localStorage.setItem('virtualCart', JSON.stringify(this.items));
      },

      loadFromLocalStorage() {
        const saved = localStorage.getItem('virtualCart');
        if (saved) {
          this.items = JSON.parse(saved);
          this.updateUI();
        }
      }
    };

    // Cart Modal Functions
    function openCartModal() {
      document.getElementById('cart-modal').style.display = 'flex';
      document.body.classList.add('modal-open');
    }

    function closeCartModal() {
      document.getElementById('cart-modal').style.display = 'none';
      document.body.classList.remove('modal-open');
    }

    function checkout() {
      if (virtualCart.items.length === 0) return;

      // Create a form to submit all items
      const form = document.createElement('form');
      form.method = 'post';
      form.action = 'https://litfarms.com/cart/add';
      form.target = '_blank';

      // Add each item as a hidden input with its quantity
      virtualCart.items.forEach((item, index) => {
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = `items[${index}][id]`;
        input.value = item.variantId;
        form.appendChild(input);

        const quantityInput = document.createElement('input');
        quantityInput.type = 'hidden';
        quantityInput.name = `items[${index}][quantity]`;
        quantityInput.value = item.quantity.toString();
        form.appendChild(quantityInput);
      });

      // Submit the form
      document.body.appendChild(form);
      form.submit();
      document.body.removeChild(form);

      // Clear the virtual cart
      virtualCart.clearCart();
      closeCartModal();
    }

    // Initialize cart
    document.addEventListener('DOMContentLoaded', () => {
      virtualCart.loadFromLocalStorage();
      
      // Add cart button click handler
      document.getElementById('virtual-cart-button').addEventListener('click', openCartModal);

      // Track mousedown position for cart modal
      let cartModalMouseDown = false;
      const cartModal = document.getElementById('cart-modal');
      
      cartModal.addEventListener('mousedown', (e) => {
        if (e.target === cartModal) {
          cartModalMouseDown = true;
        }
      });

      cartModal.addEventListener('mouseup', (e) => {
        if (e.target === cartModal && cartModalMouseDown) {
          closeCartModal();
        }
        cartModalMouseDown = false;
      });

      // Reset flag when mouse leaves modal
      cartModal.addEventListener('mouseleave', () => {
        cartModalMouseDown = false;
      });
    });

    // Update createPriceContainer to add "Add to Cart" buttons
    function createPriceContainer(product, variants, strainFilter, weightFilter, stockFilter) {
      const container = document.createElement('div');
      container.className = 'price-container';

      // Group variants by tier
      const variantsByTier = {};
      TIERS.forEach(tier => {
        variantsByTier[tier] = [];
      });

      variants.forEach(variant => {
        if (variant.correctedTier && variant.correctedWeight) {
          variantsByTier[variant.correctedTier].push(variant);
        }
      });

      // Create sections for each tier
      TIERS.forEach(tier => {
        if (strainFilter !== 'all' && tier !== strainFilter) {
          return;
        }

        const tierVariants = variantsByTier[tier];
        if (tierVariants && tierVariants.length > 0) {
          const filteredVariants = tierVariants.filter(variant => {
            if (weightFilter !== 'all' && variant.correctedWeight !== weightFilter) {
              return false;
            }
            if (!stockFilter && !variant.available) {
              return false;
            }
            return true;
          });

          if (filteredVariants.length > 0) {
            const section = document.createElement('div');
            section.className = `variant-section variant-section-${tier.toLowerCase()}`;

            const title = document.createElement('div');
            title.className = `variant-title variant-title-${tier.toLowerCase()}`;
            title.textContent = tier;
            section.appendChild(title);

            const weights = document.createElement('div');
            weights.className = 'variant-weights';

            filteredVariants.forEach(variant => {
              const row = document.createElement('div');
              row.className = variant.available ? 'weight-row in-stock' : 'weight-row out-of-stock';
              
              // Add click handler to stop event propagation
              row.addEventListener('click', (e) => {
                e.stopPropagation();
              });

              const infoRow = document.createElement('div');
              infoRow.className = 'weight-info-row';

              const info = document.createElement('div');
              info.className = 'weight-info';

              const label = document.createElement('span');
              label.className = 'weight-label';
              label.textContent = variant.correctedWeight;

              const price = document.createElement('span');
              price.className = 'weight-price';
              price.textContent = `$${variant.price}`;

              info.appendChild(label);
              info.appendChild(price);
              infoRow.appendChild(info);

              const stockBadge = document.createElement('span');
              stockBadge.className = `stock-badge ${variant.available ? 'in-stock-badge' : 'out-of-stock-badge'}`;
              stockBadge.textContent = variant.available ? 'In Stock' : 'Out of Stock';

              row.appendChild(infoRow);
              row.appendChild(stockBadge);

              if (variant.available) {
                const addButton = document.createElement('button');
                addButton.className = 'add-to-cart-button';
                addButton.textContent = 'Add to Cart';
                addButton.onclick = (e) => {
                  e.stopPropagation();
                  virtualCart.addItem(product, variant);
                };
                row.appendChild(addButton);
              }

              weights.appendChild(row);
            });

            section.appendChild(weights);
            container.appendChild(section);
          }
        }
      });

      return container;
    }
  </script>

  <!-- Settings Button -->
  <button id="settings-button" title="Notification Settings">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M12 15a3 3 0 100-6 3 3 0 000 6z" />
      <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z" />
    </svg>
  </button>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settings-modal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title">Notification Settings</h2>
        <button class="close-modal">&times;</button>
      </div>
      
      <div class="settings-section">
        <h3>Update Frequency</h3>
        <div class="settings-input-group">
          <input type="number" id="check-interval" class="settings-input" min="1" value="5" placeholder="5">
          <span class="settings-input-suffix">minutes</span>
        </div>
      </div>

      <div class="settings-section">
        <h3>Notifications</h3>
        <div style="margin-bottom: 20px;">
          <div class="settings-checkbox">
            <input type="checkbox" id="ntfy-enabled">
            <label for="ntfy-enabled">Enable App Notifications</label>
          </div>
          <small style="color: var(--text-muted); display: block; margin-left: 25px;">
            Receive notifications on your phone via the Ntfy app
          </small>
        </div>

        <div style="margin-bottom: 20px;">
          <div class="settings-checkbox">
            <input type="checkbox" id="email-enabled">
            <label for="email-enabled">Enable Email Notifications</label>
          </div>
          <small style="color: var(--text-muted); display: block; margin-left: 25px;">
            Receive notifications via email
          </small>
        </div>
        
        <div style="margin-top: 10px;">
          <label for="ntfy-topic">Ntfy Topic:</label>
          <div style="display: flex; gap: 8px; margin-bottom: 4px;">
            <input type="text" id="ntfy-topic" class="settings-input notification-input" placeholder="Enter your unique topic name" style="flex: 1;">
            <button onclick="generateRandomTopic()" style="background-color: var(--accent-secondary); color: var(--bg-primary); border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; white-space: nowrap;">
              Generate Random
            </button>
          </div>
          <small style="color: var(--text-muted); display: block; margin-bottom: 10px;">
            This is your private notification channel. Required for app notifications. Use the generate button for a unique topic name.
          </small>
        </div>

        <div style="margin-top: 10px;">
          <label for="ntfy-email">Email Address:</label>
          <input type="email" id="ntfy-email" class="settings-input notification-input" placeholder="your@email.com">
          <small style="color: var(--text-muted); display: block; margin-bottom: 10px;">
            Required for email notifications.
          </small>
        </div>

        <div style="margin-top: 10px;">
          <label for="ntfy-server">Ntfy Server (optional):</label>
          <input type="text" id="ntfy-server" class="settings-input notification-input" placeholder="https://ntfy.sh">
          <small style="color: var(--text-muted); display: block; margin-bottom: 10px;">
            Leave as default unless you're using a self-hosted server.
          </small>
        </div>

        <button id="test-ntfy" onclick="testNtfyNotification()" style="background-color: var(--accent-primary); color: var(--bg-primary); border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-top: 10px;">
          Test Notifications
        </button>

        <div style="margin-top: 15px; padding: 10px; background: var(--bg-elevated); border-radius: 4px;">
          <p style="margin: 0 0 10px 0; color: var(--text-secondary);">To receive app notifications:</p>
          <ol style="margin: 0; padding-left: 20px; color: var(--text-muted);">
            <li>Download the Ntfy app for <a href="https://apps.apple.com/us/app/ntfy/id1625396347" target="_blank" style="color: var(--accent-primary);">iOS</a> or <a href="https://play.google.com/store/apps/details?id=io.heckel.ntfy" target="_blank" style="color: var(--accent-primary);">Android</a></li>
            <li>Open the app and tap "Add subscription"</li>
            <li>Enter your topic name exactly as above</li>
            <li>Save and wait for notifications!</li>
          </ol>
        </div>
      </div>

      <div class="settings-section">
        <h3>Product Filters</h3>
        <label for="notification-tier">Select Tiers (hold Ctrl/Cmd to select multiple):</label>
        <select id="notification-tier" class="settings-select" multiple size="4">
          <option value="all">All Tiers</option>
          <option value="Essential">Essential</option>
          <option value="Preferred">Preferred</option>
          <option value="Supreme">Supreme</option>
        </select>

        <label for="notification-weight">Select Weights (hold Ctrl/Cmd to select multiple):</label>
        <select id="notification-weight" class="settings-select" multiple size="3">
          <option value="all">All Weights</option>
          <option value="28g">28g</option>
          <option value="3.5g">3.5g</option>
        </select>

        <div class="settings-checkbox">
          <input type="checkbox" id="notify-new" checked>
          <label for="notify-new">Notify for new products</label>
        </div>

        <div class="settings-checkbox">
          <input type="checkbox" id="notify-stock" checked>
          <label for="notify-stock">Notify for stock changes</label>
        </div>

        <div class="settings-checkbox">
          <input type="checkbox" id="notify-removed" checked>
          <label for="notify-removed">Notify for removed products</label>
        </div>
      </div>

      <div class="settings-section">
        <h3>Specific Products</h3>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <span id="products-selected-count" style="color: var(--text-muted);">0 products selected</span>
          <button id="deselect-all-products" onclick="deselectAllProducts()" style="background: none; border: none; color: var(--accent-primary); cursor: pointer; font-size: 0.9em;">
            Deselect All
          </button>
        </div>
        <div class="product-search">
          <input type="text" id="product-search" placeholder="Search products...">
        </div>
        <div class="product-select-container" id="product-select">
          <!-- Product checkboxes will be dynamically added here -->
        </div>
      </div>

      <button class="save-settings">Save Settings</button>
    </div>
  </div>

  <!-- Virtual Cart Button -->
  <button id="virtual-cart-button" class="virtual-cart-button" title="View Cart">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="9" cy="21" r="1"></circle>
      <circle cx="20" cy="21" r="1"></circle>
      <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
    </svg>
    <span class="cart-count">0</span>
  </button>

  <!-- Cart Modal -->
  <div id="cart-modal" class="cart-modal">
    <div class="cart-modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Shopping Cart</h2>
        <button class="close-modal" onclick="closeCartModal()">&times;</button>
      </div>
      <div id="cart-items">
        <!-- Cart items will be dynamically inserted here -->
      </div>
      <div class="cart-total">
        Total: $<span id="cart-total">0.00</span>
      </div>
      <button id="checkout-button" class="checkout-button" onclick="checkout()">
        Proceed to Checkout
      </button>
    </div>
  </div>
</body>
</html>