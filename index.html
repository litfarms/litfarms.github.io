<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>LitFarms Product List</title>
  <!-- Replace favicon with inline SVG -->
  <link rel="icon" href="data:image/svg+xml,<?xml version='1.0' encoding='UTF-8' standalone='no'?><svg width='4.6079073in' height='2.5213542in' viewBox='0 0 117.04084 64.042396' version='1.1' id='svg1' xml:space='preserve' xmlns='http://www.w3.org/2000/svg'><defs id='defs1'/><g id='layer1' transform='translate(-46.479583,-116.4788)'><rect style='display:inline;opacity:1;fill:none;fill-opacity:1;stroke:%23ffffff;stroke-width:6;stroke-dasharray:none;stroke-opacity:1' id='rect2' width='111.04084' height='58.0424' x='49.47958' y='119.4788'/><g id='g6' style='opacity:1;fill:%23ffffff;fill-opacity:1' transform='matrix(1,0,0,1.0224587,0.56861157,30.651474)'><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:6.57396;stroke-dasharray:none;stroke-opacity:1' id='rect5' width='25.801872' height='5.860003' x='119.94384' y='98.674728' ry='0'/><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:6.03661;stroke-dasharray:none;stroke-opacity:1' id='rect6' width='6' height='30.334635' x='130.05539' y='101.46412'/></g><path style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:5.81338;stroke-dasharray:none;stroke-opacity:1' d='m 100.03961,131.46649 h 6 v 33.97218 h -6 z' id='path4'/><g id='g9' transform='matrix(1,0,0,1.0199169,-0.14807164,31.087934)'><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:5.43999;stroke-dasharray:none;stroke-opacity:1' id='rect8' width='6' height='33.229393' x='64.364632' y='98.429321'/><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:5.84555;stroke-dasharray:none;stroke-opacity:1' id='rect9' width='21.184687' height='5.8828321' x='64.373192' y='125.75582'/></g></g></svg>">
  <link rel="stylesheet" href="style.css">
  <style>
  
  </style>
  <div class="countdown-container">
    <div class="countdown-tooltip">Next check in: <span class="tooltip-time">5:00</span></div>
    <div class="countdown-circle">
      <svg viewBox="0 0 36 36">
        <circle class="progress-bg" r="16" cx="18" cy="18"></circle>
        <circle class="progress" r="16" cx="18" cy="18" stroke-dasharray="100.53" stroke-dashoffset="0"></circle>
      </svg>
      <div class="countdown-time">5:00</div>
    </div>
  </div>
</head>
<body>
  <!-- Cart and Settings buttons - placed early for immediate interactivity -->
  <button id="settings-button" title="Notification Settings">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M12 15a3 3 0 100-6 3 3 0 000 6z" />
      <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z" />
    </svg>
  </button>

  <button id="virtual-cart-button" class="virtual-cart-button" title="View Cart">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="9" cy="21" r="1"></circle>
      <circle cx="20" cy="21" r="1"></circle>
      <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
    </svg>
    <span class="cart-count">0</span>
  </button>

  <script>
    // Store scroll position for modals
    var modalScrollPosition = 0;
    var lastKnownScrollPosition = window.scrollY || window.pageYOffset || 0;
    var isModalOpen = false;
    
    // Track scroll position continuously (but not when modal is open)
    window.addEventListener('scroll', function() {
      if (!isModalOpen) {
        var currentScroll = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;
        // Only update if it's not a sudden jump to 0 (which happens when position:fixed is applied)
        // Allow 0 only if we were already near 0 (within 10px)
        if (currentScroll > 0 || lastKnownScrollPosition < 10) {
          lastKnownScrollPosition = currentScroll;
        }
      }
    }, { passive: true });
    
    // Define functions immediately
    // Generic close modal function to avoid duplication
    function closeModal(modalId) {
      var modal = document.getElementById(modalId);
      if (modal && modal.style.display === 'flex') {
        modal.style.display = 'none';
        document.body.classList.remove('modal-open');
        
        // Restore body scroll
        document.body.style.overflow = '';
        document.body.style.paddingRight = '';
        
        isModalOpen = false;
        modalScrollPosition = 0;
      }
    }
    
    // Improved modal management for mobile
    window.openCartModal = function() {
      var modal = document.getElementById('cart-modal');
      if (modal && modal.style.display !== 'flex') {
        var savedPosition = lastKnownScrollPosition;
        isModalOpen = true;
        modalScrollPosition = savedPosition;
        
        // Store scroll position and prevent body scroll without position:fixed
        document.body.style.overflow = 'hidden';
        // Only add padding compensation on desktop (where scrollbars take up space)
        var scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
        if (scrollbarWidth > 0) {
          document.body.style.paddingRight = scrollbarWidth + 'px';
        }
        
        modal.style.display = 'flex';
        document.body.classList.add('modal-open');
        
        // Update cart UI if virtualCart is available
        if (typeof virtualCart !== 'undefined') {
          virtualCart.updateUI();
        }
        
        // Check if content is scrollable and show indicator
        requestAnimationFrame(function() {
          if (typeof checkScrollIndicator !== 'undefined') {
            checkScrollIndicator(modal);
          }
        });
      }
    };
    
    window.closeCartModal = function() {
      closeModal('cart-modal');
    };
    
    // openSettingsModal is defined later with full functionality
    
    window.closeSettingsModal = function() {
      closeModal('settings-modal');
    };
    
    // Attach event listeners immediately
    var settingsBtn = document.getElementById('settings-button');
    var cartBtn = document.getElementById('virtual-cart-button');
    
    // Use touch events on mobile, click on desktop to prevent double-firing
    var isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    var eventType = isTouchDevice ? 'touchend' : 'click';
    
    settingsBtn.addEventListener(eventType, function(e) {
      e.preventDefault();
      e.stopPropagation();
      window.openSettingsModal();
    }, { passive: false });
    
    cartBtn.addEventListener(eventType, function(e) {
      e.preventDefault();
      e.stopPropagation();
      window.openCartModal();
    }, { passive: false });
    
    // Show buttons after delay on mobile, immediately on desktop
    var isMobile = window.innerWidth <= 700;
    var delay = isMobile ? 500 : 0; // 5 seconds on mobile, instant on desktop
    
    setTimeout(function() {
      settingsBtn.style.opacity = '1';
      settingsBtn.style.pointerEvents = 'auto';
      cartBtn.style.opacity = '1';
      cartBtn.style.pointerEvents = 'auto';
    }, delay);
  </script>

  <div id="site-status" class="site-status">
    <span id="status-message"></span>
    <button id="retry-button" class="retry-button" style="display: none;">Retry Now</button>
  </div>
  <div class="header">
    <a href="https://www.litfarms.com?sca_ref=9871506.3QN5sUKgOM&sca_crp=MjMzMjUw" class="header-link">
      <svg width="75" height="75" viewBox="0 0 117.04084 64.042396" version="1.1" id="svg1" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
        <defs id="defs1"></defs>
        <g id="layer1" transform="translate(-46.479583,-116.4788)">
          <rect style="display:inline;opacity:1;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:6;stroke-dasharray:none;stroke-opacity:1" id="rect2" width="111.04084" height="58.0424" x="49.47958" y="119.4788"></rect>
          <g id="g6" style="opacity:1;fill:#ffffff;fill-opacity:1" transform="matrix(1,0,0,1.0224587,0.56861157,30.651474)">
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:6.57396;stroke-dasharray:none;stroke-opacity:1" id="rect5" width="25.801872" height="5.860003" x="119.94384" y="98.674728" ry="0"></rect>
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:6.03661;stroke-dasharray:none;stroke-opacity:1" id="rect6" width="6" height="30.334635" x="130.05539" y="101.46412"></rect>
          </g>
          <path style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:5.81338;stroke-dasharray:none;stroke-opacity:1" d="m 100.03961,131.46649 h 6 v 33.97218 h -6 z" id="path4"></path>
          <g id="g9" transform="matrix(1,0,0,1.0199169,-0.14807164,31.087934)">
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:5.43999;stroke-dasharray:none;stroke-opacity:1" id="rect8" width="6" height="33.229393" x="64.364632" y="98.429321"></rect>
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:5.84555;stroke-dasharray:none;stroke-opacity:1" id="rect9" width="21.184687" height="5.8828321" x="64.373192" y="125.75582"></rect>
          </g>
        </g>
      </svg>
    </a>
    <a href="https://www.litfarms.com?sca_ref=9871506.3QN5sUKgOM&sca_crp=MjMzMjUw" class="header-link">
      <h1>Farms Products</h1>
    </a>
  </div>
  <div class="filters-container">
    <button id="filters-toggle" class="filters-toggle" aria-label="Toggle filters">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
      </svg>
      <span class="filters-toggle-text">Filters</span>
      <svg class="filters-toggle-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="6 9 12 15 18 9"></polyline>
      </svg>
    </button>
    <div class="filters" id="filters">
      <div class="search-container">
        <input type="text" id="product-search-filter" class="search-input" placeholder="Search products...">
        <button id="clear-search" class="clear-search">&times;</button>
      </div>
      <select id="strain-filter">
        <option value="all">All Tiers</option>
        <option value="Essential">Essential</option>
        <option value="Preferred">Preferred</option>
        <option value="Supreme">Supreme</option>
      </select>
      <select id="strain-type-filter">
        <option value="all">All Types</option>
        <option value="sativa">Sativa</option>
        <option value="indica">Indica</option>
        <option value="hybrid">Hybrid</option>
        <option value="unknown">Unknown</option>
      </select>
      <select id="weight-filter">
        <option value="all">All Weights</option>
        <option value="28g">28g</option>
        <option value="28g (Smalls)">28g (Smalls)</option>
        <option value="3.5g">3.5g</option>
      </select>
      <select id="sort-filter">
        <option value="alpha-asc">A-Z</option>
        <option value="alpha-desc">Z-A</option>
        <option value="price-asc">Price: Low to High</option>
        <option value="price-desc">Price: High to Low</option>
        <option value="date-desc">Newest First</option>
        <option value="date-asc">Oldest First</option>
      </select>
      <button id="stock-filter" class="stock-filter-btn active">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
          <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
          <line x1="12" y1="22.08" x2="12" y2="12"></line>
        </svg>
        <span>All Items</span>
      </button>
      <button id="sale-filter" class="sale-filter-btn">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
          <line x1="7" y1="7" x2="7.01" y2="7"></line>
        </svg>
        <span>All Items</span>
      </button>
    </div>
    <div id="product-count" style="text-align: center; margin: 8px 0; color: var(--text-secondary);text-shadow: 0 2px 5px rgb(0 0 0 / 50%);">
      Showing 0 products
    </div>
  </div>
  <div class="product-grid" id="product-grid">
    <!-- Product cards will be dynamically inserted here -->
  </div>

  <div id="loader" class="loader-container" style="display: none;">
    <span class="loader"></span>
    <div class="loader-text">Loading products...</div>
  </div>

  <!-- Lightbox for images -->
  <div id="image-lightbox" class="lightbox" style="display: none;">
    <span class="lightbox-close">&times;</span>
    <img class="lightbox-content" id="lightbox-img">
    <div class="lightbox-caption" id="lightbox-caption"></div>
  </div>

  <script>
    // Define the URL for the products.json endpoint
    const shopifyStoreUrl = 'https://litfarms.com/products.json';
    
    // Ntfy configuration
    const NTFY_CONFIG = {
      appEnabled: false, // App notifications enabled
      emailEnabled: false, // Email notifications enabled
      topic: '', // Will be set in settings
      server: 'https://ntfy.sh', // Default server, can be changed in settings
      email: '' // Email for notifications
    };

    // Declare updateCheckerId at the top level
    let updateCheckerId = null;

    // Hardcoded referral parameters
    const REFERRAL_PARAMS = {
      sca_ref: '9871506.3QN5sUKgOM',
      sca_crp: 'MjMzMjUw'
    };

    // Settings Management
    const DEFAULT_SETTINGS = {
      checkInterval: 5, // minutes
      notificationTiers: ['all'],
      notificationWeights: ['all'],
      notifyNew: true,
      notifyStock: true,
      notifyRemoved: true,
      specificProducts: [], // Array of product handles
      ntfyAppEnabled: false,
      ntfyEmailEnabled: false,
      ntfyTopic: '',
      ntfyServer: 'https://ntfy.sh',
      ntfyEmail: '',
      enableProductLinks: true // Enable/disable clicking products to open product page
    };

    let currentSettings = { ...DEFAULT_SETTINGS };

    function loadSettings() {
      const savedSettings = localStorage.getItem('litFarmsNotificationSettings');
      if (savedSettings) {
        currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(savedSettings) };
      }
      // Update Ntfy config
      NTFY_CONFIG.appEnabled = currentSettings.ntfyAppEnabled;
      NTFY_CONFIG.emailEnabled = currentSettings.ntfyEmailEnabled;
      NTFY_CONFIG.topic = currentSettings.ntfyTopic;
      NTFY_CONFIG.server = currentSettings.ntfyServer;
      NTFY_CONFIG.email = currentSettings.ntfyEmail;
      return currentSettings;
    }

    // Update saveSettings function to properly handle timer reset
    function saveSettings(settings) {
      const oldInterval = currentSettings.checkInterval;
      const newInterval = settings.checkInterval;
      const oldEnableProductLinks = currentSettings.enableProductLinks;
      const newEnableProductLinks = settings.enableProductLinks;
      
      localStorage.setItem('litFarmsNotificationSettings', JSON.stringify(settings));
      currentSettings = settings;
      
      // Update product card data attributes if enableProductLinks changed
      if (oldEnableProductLinks !== newEnableProductLinks) {
        document.querySelectorAll('.product-card').forEach(card => {
          card.dataset.linksEnabled = newEnableProductLinks;
        });
      }
      
      // Only restart timers if the interval changed
      if (oldInterval !== newInterval) {
        // Clear existing intervals
        if (updateCheckerId) {
          clearInterval(updateCheckerId);
          updateCheckerId = null;
        }
        
        // Clear all existing cleanup handlers
        pageCleanupHandlers.forEach(handler => {
          try {
            handler();
          } catch (error) {
            console.warn('Cleanup handler error:', error);
          }
        });
        pageCleanupHandlers = [];
        
        // Start new product checker and countdown
        startProductUpdateChecker();
      }
    }

    // Strain data
    const MANUAL_STRAIN_DATA = {
  "zereal": {
    "description": "Zerealz is a slightly indica dominant hybrid strain (60% indica/40% sativa) created through crossing the powerful Zkittlez X Cereal Milk strains. Looking for an insanely delicious flavor and a super euphoric yet relaxing high? Zerealz is definitely made for you. This bud packs a sweet and creamy fruity berry flavor into each and every toke, sharpened slightly by a sour citrus exhale. The aroma is earthy and herbal at the onset before settling into a sweet and fruity effect as the nugs are broken apart and burned away.",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738172569453
  },
  "white linen": {
    "description": "White Linen is an indica dominant hybrid strain (70% indica/30% sativa) created through crossing the delicious Wedding Cake #13 X Melonade strains. Named for its gorgeous appearance and soft, soothing high, White Linen is the perfect choice for any lover of classic flavorful indicas. This bud has beautiful fat heart-shaped bright neon green nugs with minty green undertones, lots of thin yellow-orange hairs and a frosty thick coating of slightly golden-white crystal trichomes.",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738172600552
  },
  "lit og": {
    "description": "LIT OG: Where Tahoe OG meets Runtz in a legendary clash of titans. This unforgettable strain packs a powerful punch, leaving you feeling euphoric and blissful. But LIT OG isn't just about brute force. Its flavor profile is a delightful surprise, exploding with gassy OG terps that linger on the palate. It's the perfect choice for experienced users seeking a potent and flavorful experience that lives up to its name.",
    "category": "sativa",
    "phenotype": "sativa",
    "lastUpdate": 1738172799107
  },
  "lemon cherry belts": {
    "description": "Delivers a vibrant blend of sweet lemon zest and ripe cherries, with a smooth, creamy finish.",
    "category": "hybrid",
    "phenotype": "hybrid",
    "lastUpdate": 1738179317058
  },
  "glitter bomb": {
    "description": "Glitter Bomb THCa Flower will enchant you with its dazzling trichomes and hypnotic purple buds! It is a 70/30 indica dominant hybrid type 1 hemp flower that was indoor grown with living soil. This genetic gem of a strain is from crossing Grape Gas with OG Kush Breath Blueberry Headband, and exhibits notes of sweet, gas, and berries! This strain will have you dimension hopping with euphoria, transcendental thinking, and powerful relaxation!",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738179386321
  },
  "apple banana zoap": {
    "description": "Apple Banana Zoap from LIT Farms is a cannabis strain that combines the flavors of apples, bananas, and zoap. The strain''s unique flavor profile blends sweet, creamy notes of apples and bananas with earthy, floral undertones of zoap, creating a rich and aromatic experience. This combination makes Apple Banana highly appealing to cannabis users. This strain offers a balanced high, combining relaxation and a gentle cerebral stimulation, making it suitable for both recreational and medicinal use. The potent levels of THC in Apple Banana provide a strong and long-lasting effect, helping to relieve stress, anxiety, and chronic pain.",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738179467896
  },
  "bubblegum runtz": {
    "description": "Bubble Runtz, also known as Bubblegum Runtz and Bubble Gum Runtz,, is a hybrid weed strain made by crossing Runtz and Bubble Gum. ",
    "category": "hybrid",
    "phenotype": "hybrid",
    "lastUpdate": 1738172799107
  }
};

    // Simplify loadStrainData to just use the constant
    async function loadStrainData() {
      try {
        //console.log('Loading strain data...');
        strainData = MANUAL_STRAIN_DATA;
        //console.log('Loaded strain data:', strainData);
        return strainData;
      } catch (error) {
        console.error('Error in loadStrainData:', error);
        return {};
      }
    }

    // Update getStrainType to use the new strain data
    function getStrainType(description, productHandle, productTitle, productTags = []) {
      //console.log(`Getting strain type for ${productTitle}`);
      
      // Clean the title first since we need it for both checks
      const cleanTitle = productTitle
        .replace(/\s*-?\s*THCA\s+Flower\s*$/i, '')
        .replace(/\s*-?\s*Flower\s*$/i, '')
        .replace(/\s*-?\s*\d+\.?\d*g\s*$/i, '')
        .replace(/-/g, '')
        .trim()
        .toLowerCase();

      // First check product tags for strain type
      if (productTags && Array.isArray(productTags)) {
        const tagsLower = productTags.map(tag => tag.toLowerCase());
        if (tagsLower.includes('sativa')) return 'sativa';
        if (tagsLower.includes('indica')) return 'indica';
        if (tagsLower.includes('hybrid')) return 'hybrid';
      }

      // Then check if product description explicitly mentions strain type
      if (description) {
        const temp = document.createElement('div');
        temp.innerHTML = description;
        const plainText = temp.textContent.toLowerCase();
        
        if (plainText.includes('sativa')) return 'sativa';
        if (plainText.includes('indica')) return 'indica';
        if (plainText.includes('hybrid')) return 'hybrid';
      }

      // If no strain type in tags or description, use manual strain type
      let strainInfo = strainData[cleanTitle];
      
      // If not found, try removing trailing 's' if present
      if (!strainInfo && cleanTitle.endsWith('s')) {
        const singularForm = cleanTitle.slice(0, -1);
        strainInfo = strainData[singularForm];
      }

      // Return the manual strain type if available
      if (strainInfo?.category) {
        return strainInfo.category.toLowerCase();
      }
      
      return 'unknown';
    }

    // Function to show/hide loader
    function toggleLoader(show) {
      if (show) {
        domElements.loader.style.display = 'flex';
        domElements.productGrid.style.display = 'none';
      } else {
        domElements.loader.style.display = 'none';
        domElements.productGrid.style.display = 'grid';
      }
    }

    // Define global products variable
    let products = [];

    // Cache constants
    const CACHE_KEY = 'litFarmsProducts';
    const CACHE_TIMESTAMP_KEY = 'litFarmsLastUpdate';
    const CACHE_DURATION = 1 * 60 * 1000; // 1 minutes in milliseconds

    // Function to handle caching and fetching products
    async function getProducts(immediate = false) {
      const now = Date.now();
      const lastUpdate = localStorage.getItem(CACHE_TIMESTAMP_KEY);
      const cachedData = localStorage.getItem(CACHE_KEY);

      try {
        // Check for valid cached data
        if (cachedData && lastUpdate) {
          const parsedCache = JSON.parse(cachedData);
          const isValidCache = Array.isArray(parsedCache) && 
                              parsedCache.length > 0 && 
                              parsedCache[0].hasOwnProperty('title');

          if (isValidCache) {
            // Clear any stored error state since we have valid cache
            localStorage.removeItem('lastFetchError');
            
            // If this is an immediate request, return cached data regardless of age
            if (immediate) {
              return filterTHCAProducts(parsedCache);
            }
            
            // For background updates, check if cache is fresh enough
            if (now - parseInt(lastUpdate) < CACHE_DURATION) {
              return filterTHCAProducts(parsedCache);
            }
          }
        }

        // If we get here, we need fresh data
        console.log('Fetching fresh product data');
        const freshProducts = await fetchAllProducts();
        
        if (!Array.isArray(freshProducts) || freshProducts.length === 0) {
          throw new Error('Invalid or empty product data received');
        }

        // Clear any stored error state on successful fetch
        localStorage.removeItem('lastFetchError');

        const thcaProducts = filterTHCAProducts(freshProducts);
        
        if (thcaProducts.length > 0) {
          localStorage.setItem(CACHE_KEY, JSON.stringify(thcaProducts));
          localStorage.setItem(CACHE_TIMESTAMP_KEY, now.toString());
        }
        
        return thcaProducts;
      } catch (error) {
        console.error('Error in getProducts:', error);
        
        // Store the error state for maintenance mode detection
        if (error.message && error.message.includes('401')) {
          localStorage.setItem('lastFetchError', error.message);
        }
        
        // If this is an immediate request and we have any cached data, use it
        if (immediate && cachedData) {
          try {
            const parsedCache = JSON.parse(cachedData);
            if (Array.isArray(parsedCache) && parsedCache.length > 0) {
              return filterTHCAProducts(parsedCache);
            }
          } catch (e) {
            console.error('Failed to parse cached data:', e);
          }
        }
        
        throw error;
      }
    }

    // Update the fetchAllProducts function to include logging
    async function fetchAllProducts() {
      let allProducts = [];
      
      try {
        // Fetch first page
        const response = await fetch(`${shopifyStoreUrl}?page=1&limit=250`);
        const data = await response.json();
        
        if (data.products && data.products.length > 0) {
          allProducts = data.products;
          console.log(`Found ${data.products.length} products on page 1`);
          
          // Only continue fetching if we got the maximum number of products (250)
          if (data.products.length === 250) {
            let page = 2;
            let hasMore = true;
            
            while (hasMore) {
              try {
                const nextResponse = await fetch(`${shopifyStoreUrl}?page=${page}&limit=250`);
                const nextData = await nextResponse.json();
                
                if (nextData.products && nextData.products.length > 0) {
                  console.log(`Found ${nextData.products.length} products on page ${page}`);
                  allProducts = allProducts.concat(nextData.products);
                  page++;
                  
                  // If we got less than 250 products, we've reached the end
                  if (nextData.products.length < 250) {
                    hasMore = false;
                  }
                } else {
                  hasMore = false;
                }
              } catch (error) {
                console.error('Error fetching page', page, ':', error);
                hasMore = false;
              }
            }
          }
        }
      } catch (error) {
        console.error('Error fetching first page:', error);
      }

      console.log('Total products fetched:', allProducts.length);
      return allProducts;
    }

    function renderProducts(filteredProducts) {
      const productGrid = domElements.productGrid;
      domElements.productCount.textContent = `Showing ${filteredProducts.length} products`;

      // First, mark existing cards for fade out
      const existingCards = productGrid.querySelectorAll('.product-card');
      existingCards.forEach(card => card.classList.add('fade-out'));

      // Wait for fade out animation
      setTimeout(() => {
        // Clear the grid but maintain the few-items class if it should stay
        const shouldHaveFewItems = filteredProducts.length < 4;
        const hadFewItems = productGrid.classList.contains('few-items');
        
        // Only remove the few-items class if we're transitioning from few to many
        if (hadFewItems && !shouldHaveFewItems) {
          productGrid.classList.remove('few-items');
        }
        
        productGrid.innerHTML = '';

        if (!hadFewItems && shouldHaveFewItems) {
          productGrid.classList.add('few-items');
        }

        // Calculate initial load count
        const productWidth = 250;
        const gap = 20;
        const containerWidth = productGrid.offsetWidth;
        const productsPerRow = Math.floor(containerWidth / (productWidth + gap));
        const initialLoadCount = productsPerRow * 2;

        // Function to render a batch of products with staggered animation
        const renderBatch = (products, startIndex, endIndex) => {
          products.slice(startIndex, endIndex).forEach((product, index) => {
            const productCard = document.createElement('div');
            productCard.className = 'product-card';
            productCard.style.animationDelay = `${index * 50}ms`; // Stagger the animations
            productCard.dataset.linksEnabled = currentSettings.enableProductLinks;
            
            // Get filtered variants based on current filters
            const processedVariants = utils.processVariants(product);
            let relevantVariants = processedVariants;
            
            if (domElements.strainFilter.value !== 'all') {
              relevantVariants = relevantVariants.filter(v => v.correctedTier === domElements.strainFilter.value);
            }
            if (domElements.weightFilter.value !== 'all') {
              relevantVariants = relevantVariants.filter(v => v.correctedWeight === domElements.weightFilter.value);
            }
            if (!domElements.stockFilter.classList.contains('active')) {
              relevantVariants = relevantVariants.filter(v => v.available);
            }
            if (domElements.saleFilter.classList.contains('active')) {
              relevantVariants = relevantVariants.filter(v => v.isOnSale);
            }

            productCard.addEventListener('click', (e) => {
              // Check if the click was on the COA button
              if (e.target.classList.contains('coa-button')) {
                return; // Do nothing, let the COA button handle the click
              }

              // Check if product links are enabled
              if (!currentSettings.enableProductLinks) {
                return; // Do nothing if product links are disabled
              }

              // Regular click behavior - go to product page
              let url = `https://litfarms.com/products/${product.handle}`;
              const params = new URLSearchParams();
              
              if (relevantVariants.length === 1) {
                params.append('variant', relevantVariants[0].id);
              }
              
              // Add referral parameters
              params.append('sca_ref', REFERRAL_PARAMS.sca_ref);
              params.append('sca_crp', REFERRAL_PARAMS.sca_crp);
              
              if (params.toString()) {
                url += `?${params.toString()}`;
              }
              
              window.open(url, '_blank');
            });

            // Strain type badge
            const strainType = getStrainType(product.body_html, product.handle, product.title, product.tags);
            const strainTypeBadge = createStrainTypeBadge(strainType);
            productCard.appendChild(strainTypeBadge);
            productCard.style.position = 'relative';
            productCard.dataset.strainType = strainType;

            // Create and add product image
            const imageContainer = createProductImage(product, relevantVariants);
            productCard.appendChild(imageContainer);

            const productTitle = createProductTitle(product);
            productCard.appendChild(productTitle);

            const priceContainer = createPriceContainer(product, relevantVariants, domElements.strainFilter.value, domElements.weightFilter.value, domElements.stockFilter.classList.contains('active'), productCard);
            productCard.appendChild(priceContainer);

            // Set initial image to first tier if multiple tiers exist
            const processedVariantsForImage = utils.processVariants(product);
            const variantsByTierForImage = {};
            TIERS.forEach(tier => {
              variantsByTierForImage[tier] = [];
            });
            processedVariantsForImage.forEach(variant => {
              if (variant.correctedTier && variant.correctedWeight) {
                variantsByTierForImage[variant.correctedTier].push(variant);
              }
            });
            
            // Find first available tier with variants
            const firstTierWithVariants = TIERS.find(tier => {
              const tierVariants = variantsByTierForImage[tier];
              if (!tierVariants || tierVariants.length === 0) return false;
              
              const filtered = tierVariants.filter(v => {
                if (domElements.strainFilter.value !== 'all' && v.correctedTier !== domElements.strainFilter.value) return false;
                if (domElements.weightFilter.value !== 'all' && v.correctedWeight !== domElements.weightFilter.value) return false;
                if (!domElements.stockFilter.classList.contains('active') && !v.available) return false;
                return true;
              });
              return filtered.length > 0;
            });
            
            // Update image to first tier's image if multiple tiers exist
            if (firstTierWithVariants && variantsByTierForImage[firstTierWithVariants]) {
              const availableTiersCount = TIERS.filter(tier => {
                const tierVariants = variantsByTierForImage[tier];
                if (!tierVariants || tierVariants.length === 0) return false;
                const filtered = tierVariants.filter(v => {
                  if (domElements.strainFilter.value !== 'all' && v.correctedTier !== domElements.strainFilter.value) return false;
                  if (domElements.weightFilter.value !== 'all' && v.correctedWeight !== domElements.weightFilter.value) return false;
                  if (!domElements.stockFilter.classList.contains('active') && !v.available) return false;
                  return true;
                });
                return filtered.length > 0;
              }).length;
              
              if (availableTiersCount > 1) {
                updateProductImage(productCard, product, variantsByTierForImage[firstTierWithVariants], true);
              }
            }

            const productDescription = createProductDescription(product);
            productCard.appendChild(productDescription);

            productGrid.appendChild(productCard);
          });
        };

        // Force 5 columns on large screens to prevent auto-fill recalculation
        if (window.innerWidth >= 1200) {
          productGrid.style.gridTemplateColumns = 'repeat(5, 1fr)';
        }

        // Render first two rows immediately
        renderBatch(filteredProducts, 0, initialLoadCount);

        // Render the rest in smaller chunks to avoid blocking
        if (filteredProducts.length > initialLoadCount) {
          const chunkSize = 20; // Render 20 items at a time
          let currentIndex = initialLoadCount;
          
          const renderNextChunk = () => {
            const endIndex = Math.min(currentIndex + chunkSize, filteredProducts.length);
            renderBatch(filteredProducts, currentIndex, endIndex);
            currentIndex = endIndex;
            
            if (currentIndex < filteredProducts.length) {
              requestAnimationFrame(renderNextChunk);
            }
          };
          
          requestAnimationFrame(renderNextChunk);
        }
      }, 200); // Match this with the fade-out transition duration
    }

    // Helper functions for rendering
    // Helper function to check if an image is the logo
    function isLogoImage(imageSrc) {
      if (!imageSrc) return false;
      return imageSrc.includes('litfarms-logo-circle-profile.jpg');
    }

    // Helper function to find a suitable image, skipping the logo
    function findSuitableImage(images, variantIds = null) {
      if (!images || images.length === 0) return null;
      
      let candidateImages = images;
      
      // If variant IDs provided, try to find matching variant images first
      if (variantIds && variantIds.size > 0) {
        const variantImages = images.filter(img => 
          img.variant_ids && 
          img.variant_ids.some(id => variantIds.has(id)) &&
          !isLogoImage(img.src)
        );
        
        if (variantImages.length > 0) {
          return variantImages[0];
        }
      }
      
      // Fall back to first non-logo image
      const nonLogoImages = images.filter(img => !isLogoImage(img.src));
      if (nonLogoImages.length > 0) {
        return nonLogoImages[0];
      }
      
      // If all images are logos, return the first one anyway
      return images[0];
    }

    function createStrainTypeBadge(strainType) {
      const badge = document.createElement('div');
      badge.className = 'strain-type-badge';
      
      // Set badge color based on strain type
      switch(strainType) {
        case 'sativa':
          badge.style.backgroundColor = 'var(--strain-sativa)';
          badge.style.color = '#000';
          break;
        case 'indica':
          badge.style.backgroundColor = 'var(--strain-indica)';
          badge.style.color = '#fff';
          break;
        case 'hybrid':
          badge.style.backgroundColor = 'var(--strain-hybrid)';
          badge.style.color = '#fff';
          break;
        default:
          badge.style.backgroundColor = 'var(--strain-unknown)';
          badge.style.color = '#fff';
      }
      
      badge.textContent = strainType;
      return badge;
    }

    function createProductImage(product, relevantVariants) {
      const imageContainer = document.createElement('div');
      imageContainer.className = 'product-image-container';
      
      const imageWrapper = document.createElement('div');
      imageWrapper.className = 'image-wrapper';
      
      const image = document.createElement('img');
      image.className = 'product-image';
      image.alt = product.title;
      
      imageWrapper.appendChild(image);
      imageContainer.appendChild(imageWrapper);

      // Filter images based on variants
      let selectedImage = null;
      if (product.images && product.images.length > 0) {
        if (relevantVariants.length === product.variants.length) {
          // Show all images if all variants are selected
          selectedImage = findSuitableImage(product.images);
        } else {
          // Get set of relevant variant IDs
          const relevantVariantIds = new Set(relevantVariants.map(v => v.id));
          
          // Find suitable image, skipping logo
          selectedImage = findSuitableImage(product.images, relevantVariantIds);
        }
      }

      // Use placeholder if no images available
      if (!selectedImage) {
        selectedImage = { src: 'https://via.placeholder.com/300' };
      }

      // Set the image source
      image.src = selectedImage.src;

      // Add click handler to open lightbox with original high-res image
      image.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent card click
        try {
          // Use the current image src (not the captured filteredImages) so it shows the correct tier image
          const originalSrc = image.src;
          openLightbox(originalSrc, product.title);
        } catch (error) {
          console.error('Error opening lightbox:', error);
        }
      });

      // Add visual indicator that image is clickable
      image.style.cursor = 'zoom-in';

      return imageContainer;
    }

    function createProductTitle(product) {
      const title = document.createElement('h2');
      title.className = 'product-title';
      title.textContent = product.title;
      return title;
    }

    function createPriceContainer(product, variants, strainFilter, weightFilter, stockFilter) {
      const container = document.createElement('div');
      container.className = 'price-container';

      // Group variants by tier
      const variantsByTier = {};
      TIERS.forEach(tier => {
        variantsByTier[tier] = [];
      });

      variants.forEach(variant => {
        if (variant.correctedTier && variant.correctedWeight) {
          variantsByTier[variant.correctedTier].push(variant);
        }
      });

      // Create sections for each tier
      TIERS.forEach(tier => {
        if (strainFilter !== 'all' && tier !== strainFilter) {
          return;
        }

        const tierVariants = variantsByTier[tier];
        if (tierVariants && tierVariants.length > 0) {
          const filteredVariants = tierVariants.filter(variant => {
            if (weightFilter !== 'all' && variant.correctedWeight !== weightFilter) {
              return false;
            }
            if (!stockFilter && !variant.available) {
              return false;
            }
            return true;
          });

          if (filteredVariants.length > 0) {
            const section = document.createElement('div');
            section.className = `variant-section variant-section-${tier.toLowerCase()}`;

            const title = document.createElement('div');
            title.className = `variant-title variant-title-${tier.toLowerCase()}`;
            title.textContent = tier;
            section.appendChild(title);

            const weights = document.createElement('div');
            weights.className = 'variant-weights';

            filteredVariants.forEach(variant => {
              const row = document.createElement('div');
              row.className = variant.available ? 'weight-row in-stock' : 'weight-row out-of-stock';
              
              // Add click handler to stop event propagation
              row.addEventListener('click', (e) => {
                e.stopPropagation();
              });

              const infoRow = document.createElement('div');
              infoRow.className = 'weight-info-row';

              const info = document.createElement('div');
              info.className = 'weight-info';

              const label = document.createElement('span');
              label.className = 'weight-label';
              label.textContent = variant.correctedWeight;

              const price = document.createElement('span');
              price.className = 'weight-price';
              price.textContent = `$${variant.price}`;

              info.appendChild(label);
              info.appendChild(price);
              infoRow.appendChild(info);

              const stockBadge = document.createElement('span');
              stockBadge.className = `stock-badge ${variant.available ? 'in-stock-badge' : 'out-of-stock-badge'}`;
              stockBadge.textContent = variant.available ? 'In Stock' : 'Out of Stock';

              row.appendChild(infoRow);
              row.appendChild(stockBadge);

              if (variant.available) {
                const addButton = document.createElement('button');
                addButton.className = 'add-to-cart-button';
                addButton.textContent = 'Add to Cart';
                addButton.onclick = (e) => {
                  e.stopPropagation();
                  virtualCart.addItem(product, variant, e.currentTarget);
                };
                row.appendChild(addButton);
              }

              weights.appendChild(row);
            });

            section.appendChild(weights);
            container.appendChild(section);
          }
        }
      });

      return container;
    }

    function createProductDescription(product) {
      const container = document.createElement('div');
      container.className = 'product-description-container';
      
      const toggleButton = document.createElement('button');
      toggleButton.className = 'description-toggle';
      toggleButton.innerHTML = '<span>Show Info</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg>';
      
      const description = document.createElement('div');
      description.className = 'product-description collapsed';
      
      if (product.body_html) {
        const temp = document.createElement('div');
        temp.innerHTML = product.body_html;
        
        // Find and extract COA button
        let coaButton = null;
        const links = temp.getElementsByTagName('a');
        for (let i = links.length - 1; i >= 0; i--) {
          const link = links[i];
          const linkText = link.textContent.toLowerCase();
          // Check for both variations: "click here for product coa" and "click here to see product coa"
          if (linkText.includes('click here') && linkText.includes('product coa')) {
            // Create the COA button
            coaButton = document.createElement('a');
            coaButton.className = 'coa-button';
            coaButton.textContent = 'View COA';
            coaButton.target = '_blank';
            coaButton.href = link.href;
            
            // Get the original href
            const originalUrl = link.href;
            
            // Check if it's a PDF link (look for .pdf anywhere in the URL)
            if (originalUrl.toLowerCase().includes('.pdf')) {
              // Use Google Docs viewer for PDFs
              const baseUrl = originalUrl.split('?')[0];
              coaButton.href = `https://docs.google.com/viewer?url=${encodeURIComponent(baseUrl)}&embedded=true`;
            }
            
            // Add event listener to stop propagation
            coaButton.addEventListener('click', (e) => {
              e.stopPropagation();
            });
            
            // Remove the original link from temp
            link.parentNode.removeChild(link);
          }
        }
        
        const plainText = temp.textContent
          .replace(/click here (for|to see) product coa/gi, '')
          .replace(/\s+/g, ' ')
          .trim();
          
        if (plainText.length > 10) {
          // Create a wrapper for the text content
          const contentWrapper = document.createElement('div');
          contentWrapper.className = 'description-content';
          contentWrapper.innerHTML = temp.innerHTML;
          
          // Add content first, then COA button at bottom
          description.appendChild(contentWrapper);
          if (coaButton) {
            description.appendChild(coaButton);
          }
        } else {
          // Fall back to manual strain description
          const cleanStrainName = product.title
            .replace(/\s*-?\s*THCA\s+Flower\s*$/i, '')
            .replace(/\s*-?\s*Flower\s*$/i, '')
            .replace(/\s*-?\s*\d+\.?\d*g\s*$/i, '')
            .replace(/-/g, '')
            .trim()
            .toLowerCase();

          const leaflyData = strainData[cleanStrainName];
          description.innerHTML = leaflyData?.description || 'No description available.';
        }
      } else {
        // Only fall back to manual strain description if no product description
        const cleanStrainName = product.title
          .replace(/\s*-?\s*THCA\s+Flower\s*$/i, '')
          .replace(/\s*-?\s*Flower\s*$/i, '')
          .replace(/\s*-?\s*\d+\.?\d*g\s*$/i, '')
          .replace(/-/g, '')
          .trim()
          .toLowerCase();

        const leaflyData = strainData[cleanStrainName];
        description.innerHTML = leaflyData?.description || 'No description available.';
      }
      
      // Function to check if description has scrollable content
      function checkScrollable(desc) {
        if (desc && desc.scrollHeight > desc.clientHeight) {
          desc.classList.add('has-scroll');
        } else if (desc) {
          desc.classList.remove('has-scroll');
        }
      }
      
      // Toggle functionality - expand all cards in the same row
      toggleButton.addEventListener('click', (e) => {
        e.stopPropagation();
        
        const productCard = container.closest('.product-card');
        const allCards = Array.from(document.querySelectorAll('.product-card'));
        const cardIndex = allCards.indexOf(productCard);
        
        // Calculate which row this card is in (based on grid columns)
        const gridComputedStyle = window.getComputedStyle(document.querySelector('.product-grid'));
        const gridColumns = gridComputedStyle.getPropertyValue('grid-template-columns').split(' ').length;
        const rowIndex = Math.floor(cardIndex / gridColumns);
        
        // Get all cards in the same row
        const rowStartIndex = rowIndex * gridColumns;
        const rowEndIndex = rowStartIndex + gridColumns;
        const cardsInRow = allCards.slice(rowStartIndex, rowEndIndex);
        
        // Toggle all descriptions in the row
        const isCurrentlyCollapsed = description.classList.contains('collapsed');
        cardsInRow.forEach(card => {
          const desc = card.querySelector('.product-description');
          const btn = card.querySelector('.description-toggle');
          if (desc && btn) {
            if (isCurrentlyCollapsed) {
              desc.classList.remove('collapsed');
              btn.querySelector('span').textContent = 'Hide Info';
              btn.classList.add('expanded');
              // Check if scrollable after expansion
              setTimeout(() => checkScrollable(desc), 100);
            } else {
              desc.classList.add('collapsed');
              btn.querySelector('span').textContent = 'Show Info';
              btn.classList.remove('expanded');
            }
          }
        });
      });
      
      container.appendChild(toggleButton);
      container.appendChild(description);
      return container;
    }

    // Update filter function
    function filterProducts() {
      const strainFilter = domElements.strainFilter.value;
      const strainTypeFilter = domElements.strainTypeFilter.value;
      const weightFilter = domElements.weightFilter.value;
      const stockFilter = domElements.stockFilter.classList.contains('active');
      const saleFilter = domElements.saleFilter.classList.contains('active');
      const searchQuery = domElements.searchInput.value.toLowerCase().trim();
      const sortFilter = domElements.sortFilter.value;

      const filteredProducts = products.filter((product) => {
        // Process variants with utility function first
        const correctedVariants = utils.processVariants(product);
        
        // Check search query - search in title AND variant options
        if (searchQuery) {
          const titleMatch = product.title.toLowerCase().includes(searchQuery);
          const variantMatch = correctedVariants.some(v => 
            v.correctedWeight?.toLowerCase().includes(searchQuery) ||
            v.correctedTier?.toLowerCase().includes(searchQuery) ||
            v.title?.toLowerCase().includes(searchQuery)
          );
          
          if (!titleMatch && !variantMatch) {
            return false;
          }
        }

        // If no valid variants at all, filter out the product
        if (correctedVariants.length === 0) {
          return false;
        }

        // Check if any variant matches the weight filter AND has a valid price
        if (weightFilter !== 'all') {
          const validWeightVariants = correctedVariants.filter(v => 
            v.correctedWeight === weightFilter && 
            v.hasPrice
          );
          if (validWeightVariants.length === 0) {
            return false;
          }
        }

        // Check if any variant matches the strain filter
        if (strainFilter !== 'all') {
          const validStrainVariants = correctedVariants.filter(v => 
            v.correctedTier === strainFilter && 
            (weightFilter === 'all' || v.correctedWeight === weightFilter) &&
            v.hasPrice
          );
          if (validStrainVariants.length === 0) {
            return false;
          }
        }

        // Check strain type
        if (strainTypeFilter !== 'all') {
          const productStrainType = getStrainType(product.body_html, product.handle, product.title, product.tags);
          if (productStrainType !== strainTypeFilter) {
            return false;
          }
        }

        // Check stock status
        if (!stockFilter) {
          let stockCheckVariants = correctedVariants;
          if (weightFilter !== 'all') {
            stockCheckVariants = stockCheckVariants.filter(v => 
              v.correctedWeight === weightFilter && 
              v.hasPrice
            );
          }
          if (strainFilter !== 'all') {
            stockCheckVariants = stockCheckVariants.filter(v => v.correctedTier === strainFilter);
          }
          
          const hasInStockVariant = stockCheckVariants.some(variant => variant.available);
          if (!hasInStockVariant) {
            return false;
          }
        }

        // Check sale status
        if (saleFilter) {
          let saleCheckVariants = correctedVariants;
          if (weightFilter !== 'all') {
            saleCheckVariants = saleCheckVariants.filter(v => 
              v.correctedWeight === weightFilter && 
              v.hasPrice
            );
          }
          if (strainFilter !== 'all') {
            saleCheckVariants = saleCheckVariants.filter(v => v.correctedTier === strainFilter);
          }
          if (!stockFilter) {
            saleCheckVariants = saleCheckVariants.filter(v => v.available);
          }
          
          const hasOnSaleVariant = saleCheckVariants.some(variant => variant.isOnSale);
          if (!hasOnSaleVariant) {
            return false;
          }
        }

        return true;
      });

      // Sort the filtered products
      const sortedProducts = utils.sortProducts(filteredProducts, sortFilter, strainFilter, weightFilter);
      
      // Render the sorted products
      renderProducts(sortedProducts);
    }

    // Functions to handle filter state persistence
    function saveFilterState() {
      const filterState = {
        strainFilter: document.getElementById('strain-filter').value,
        strainTypeFilter: document.getElementById('strain-type-filter').value,
        weightFilter: document.getElementById('weight-filter').value,
        sortFilter: document.getElementById('sort-filter').value,
        stockFilter: document.getElementById('stock-filter').classList.contains('active'),
        saleFilter: document.getElementById('sale-filter').classList.contains('active')
      };
      localStorage.setItem('litFarmsFilterState', JSON.stringify(filterState));
    }

    function loadFilterState() {
      const savedState = localStorage.getItem('litFarmsFilterState');
      if (savedState) {
        const filterState = JSON.parse(savedState);
        
        // Restore select filters and update their styles
        const selects = {
          'strain-filter': filterState.strainFilter,
          'strain-type-filter': filterState.strainTypeFilter,
          'weight-filter': filterState.weightFilter,
          'sort-filter': filterState.sortFilter
        };

        Object.entries(selects).forEach(([id, value]) => {
          const select = document.getElementById(id);
          select.value = value;
          updateSelectStyle(select);
        });
        
        // Restore stock filter button state
        const stockButton = document.getElementById('stock-filter');
        if (filterState.stockFilter) {
          stockButton.classList.add('active');
          stockButton.querySelector('span').textContent = 'All Items';
        } else {
          stockButton.classList.remove('active');
          stockButton.querySelector('span').textContent = 'In Stock Only';
        }
        
        // Restore sale filter button state
        const saleButton = document.getElementById('sale-filter');
        if (filterState.saleFilter) {
          saleButton.classList.add('active');
          saleButton.querySelector('span').textContent = 'Sales Only';
        } else {
          saleButton.classList.remove('active');
          saleButton.querySelector('span').textContent = 'All Items';
        }
      } else {
        // Set default state for first-time users: In Stock Only
        const stockButton = document.getElementById('stock-filter');
        stockButton.classList.remove('active');
        stockButton.querySelector('span').textContent = 'In Stock Only';
        
        // Set default state for sale filter: All Items
        const saleButton = document.getElementById('sale-filter');
        saleButton.classList.remove('active');
        saleButton.querySelector('span').textContent = 'All Items';
      }

      // Always reset search input
      const searchInput = document.getElementById('product-search-filter');
      const clearSearchButton = document.getElementById('clear-search');
      searchInput.value = '';
      clearSearchButton.style.display = 'none';
    }

    // Event listeners for filters
    document.getElementById('strain-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    document.getElementById('strain-type-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    document.getElementById('weight-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    document.getElementById('sort-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    // Function to update select element style based on selection
    function updateSelectStyle(selectElement) {
      // Don't apply styles to the sort filter since it has no default option
      if (selectElement.id === 'sort-filter') {
        return;
      }
      
      if (selectElement.value === 'all') {
        selectElement.classList.remove('has-selection');
      } else {
        selectElement.classList.add('has-selection');
      }
    }

    document.getElementById('stock-filter').addEventListener('click', () => {
      const button = document.getElementById('stock-filter');
      button.classList.toggle('active');
      button.querySelector('span').textContent = button.classList.contains('active') ? 'All Items' : 'In Stock Only';
      filterProducts();
      saveFilterState();
    });

    document.getElementById('sale-filter').addEventListener('click', () => {
      const button = document.getElementById('sale-filter');
      button.classList.toggle('active');
      button.querySelector('span').textContent = button.classList.contains('active') ? 'Sales Only' : 'All Items';
      filterProducts();
      saveFilterState();
    });

    // Function to compare products and detect changes
    function detectProductChanges(oldProducts, newProducts) {
      log(LOG_LEVELS.INFO, '=== Starting Product Change Detection ===');
      log(LOG_LEVELS.INFO, `Old products count: ${oldProducts.length}`);
      log(LOG_LEVELS.INFO, `New products count: ${newProducts.length}`);

      // Check for maintenance mode
      if (newProducts.length === 0 && oldProducts.length > 0) {
        // This might be maintenance mode rather than actual product removal
        // We'll check the last error in the fetch
        const lastError = localStorage.getItem('lastFetchError');
        if (lastError && lastError.includes('401')) {
          log(LOG_LEVELS.WARN, 'Site appears to be in maintenance mode, skipping change detection');
          return {
            new: [],
            stockChanged: [],
            removed: [],
            maintenanceMode: true
          };
        }
      }

      // Helper function to check if a product matches current filters
      function matchesFilters(product) {
        const variants = utils.processVariants(product);
        
        // If specific products are selected, only check those
        if (currentSettings.specificProducts.length > 0) {
          return currentSettings.specificProducts.includes(product.handle);
        }

        // Check if any variant matches the tier and weight filters
        return variants.some(variant => {
          const matchesTier = currentSettings.notificationTiers.includes('all') ||
                            currentSettings.notificationTiers.includes(variant.correctedTier);
          const matchesWeight = currentSettings.notificationWeights.includes('all') ||
                              currentSettings.notificationWeights.includes(variant.correctedWeight);
          return matchesTier && matchesWeight;
        });
      }

      const changes = {
        new: [],
        stockChanged: [],
        removed: []
      };

      // Check for new products
      if (currentSettings.notifyNew) {
        const oldHandles = new Set(oldProducts.map(p => p.handle));
        const newlyAdded = newProducts.filter(p => !oldHandles.has(p.handle));
        
        newlyAdded.forEach(newProduct => {
          if (matchesFilters(newProduct)) {
            log(LOG_LEVELS.INFO, `New product detected: ${newProduct.title}`);
            changes.new.push(newProduct);
          }
        });
      }

      // Check for stock changes and variant changes
      if (currentSettings.notifyStock) {
        newProducts.forEach(newProduct => {
          const oldProduct = oldProducts.find(p => p.handle === newProduct.handle);
          if (oldProduct && matchesFilters(newProduct)) {
            const oldVariants = utils.processVariants(oldProduct);
            const newVariants = utils.processVariants(newProduct);

            let hasChanges = false;
            const changedVariants = [];

            // Check for changes in existing variants
            newVariants.forEach(newVariant => {
              const oldVariant = oldVariants.find(v => 
                v.correctedTier === newVariant.correctedTier && 
                v.correctedWeight === newVariant.correctedWeight
              );

              if (oldVariant) {
                // Check for availability changes
                const availabilityChanged = oldVariant.available !== newVariant.available;
                // Only track price changes if the item is currently in stock or was in stock
                const priceChanged = oldVariant.price !== newVariant.price && (oldVariant.available || newVariant.available);
                
                if (availabilityChanged || priceChanged) {
                  hasChanges = true;
                  changedVariants.push({
                    ...newVariant,
                    oldPrice: oldVariant.price,
                    oldAvailable: oldVariant.available
                  });
                  log(LOG_LEVELS.INFO, `Variant change detected for ${newProduct.title}`, {
                    tier: newVariant.correctedTier,
                    weight: newVariant.correctedWeight,
                    oldPrice: oldVariant.price,
                    newPrice: newVariant.price,
                    oldAvailable: oldVariant.available,
                    newAvailable: newVariant.available
                  });
                }
              } else {
                // New variant added
                hasChanges = true;
                changedVariants.push(newVariant);
                log(LOG_LEVELS.INFO, `New variant added to ${newProduct.title}`, {
                  tier: newVariant.correctedTier,
                  weight: newVariant.correctedWeight,
                  price: newVariant.price,
                  available: newVariant.available
                });
              }
            });

            if (hasChanges) {
              changes.stockChanged.push({
                ...newProduct,
                changedVariants
              });
            }
          }
        });
      }

      // Check for removed products
      if (currentSettings.notifyRemoved) {
        const newHandles = new Set(newProducts.map(p => p.handle));
        oldProducts.forEach(oldProduct => {
          if (!newHandles.has(oldProduct.handle) && matchesFilters(oldProduct)) {
            log(LOG_LEVELS.INFO, `Product removed: ${oldProduct.title}`);
            changes.removed.push(oldProduct);
          }
        });
      }

      // Log summary of changes
      log(LOG_LEVELS.INFO, '=== Change Detection Summary ===', {
        newProducts: changes.new.length,
        stockChanges: changes.stockChanged.length,
        removedProducts: changes.removed.length
      });

      return changes;
    }

    // Function to send Ntfy notification
    async function sendNtfyNotification(title, message, priority = 3) {
      if (!NTFY_CONFIG.appEnabled && !NTFY_CONFIG.emailEnabled) {
        console.log('No notification methods enabled');
        return;
      }

      if (NTFY_CONFIG.appEnabled && !NTFY_CONFIG.topic) {
        console.log('App notifications enabled but no topic set');
        return;
      }

      if (NTFY_CONFIG.emailEnabled && !NTFY_CONFIG.email) {
        console.log('Email notifications enabled but no email set');
        return;
      }

      try {
        const headers = {
          'Content-Type': 'text/plain; charset=utf-8',
          'X-Title': title,
          'X-Priority': priority.toString(),
          'X-Tags': 'cannabis,stock'
        };

        // Email header
        if (NTFY_CONFIG.emailEnabled && NTFY_CONFIG.email) {
          headers['X-Email'] = NTFY_CONFIG.email;
        }

        // Send notification - we need a topic even for email-only notifications
        const topic = NTFY_CONFIG.appEnabled ? NTFY_CONFIG.topic : 'email-only-' + Math.random().toString(36).substring(7);
        
        const response = await fetch(`${NTFY_CONFIG.server}/${topic}`, {
          method: 'POST',
          headers: headers,
          body: message
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        console.log('Notification sent successfully');
      } catch (error) {
        console.error('Failed to send notification:', error);
      }
    }

    // Function to check if a variant matches notification settings
    function matchesNotificationFilters(variant) {
      const matchesTier = currentSettings.notificationTiers.includes('all') ||
                         currentSettings.notificationTiers.includes(variant.correctedTier);
      const matchesWeight = currentSettings.notificationWeights.includes('all') ||
                         currentSettings.notificationWeights.includes(variant.correctedWeight);
      return matchesTier && matchesWeight;
    }

    // Update handleNotifications function to filter based on settings
    async function handleNotifications(changes) {
      if (changes.maintenanceMode) {
        // Only send maintenance mode notification if notifications are enabled
        if (NTFY_CONFIG.appEnabled || NTFY_CONFIG.emailEnabled) {
          const message = ` MAINTENANCE MODE 

LitFarms website is currently in maintenance mode.
The product list will be updated once the site is back online.

Using cached data from: ${new Date(parseInt(localStorage.getItem(CACHE_TIMESTAMP_KEY))).toLocaleString()}

 Status checked: ${new Date().toLocaleString()}`;

          await sendNtfyNotification('LitFarms Maintenance Mode', message, 3);
        }
        return;
      }

      if (!changes.new.length && !changes.stockChanged.length && !changes.removed.length) {
        return;
      }

      // Filter changes based on notification settings
      const filteredChanges = {
        new: changes.new.filter(product => {
          const variants = utils.processVariants(product);
          return variants.some(variant => matchesNotificationFilters(variant));
        }),
        stockChanged: changes.stockChanged.filter(product => {
          // Only include products where changed variants match filters
          const filteredVariants = product.changedVariants.filter(variant => 
            matchesNotificationFilters(variant)
          );
          if (filteredVariants.length > 0) {
            // Update changedVariants to only include matching variants
            product.changedVariants = filteredVariants;
            return true;
          }
          return false;
        }),
        removed: changes.removed.filter(product => {
          const variants = utils.processVariants(product);
          return variants.some(variant => matchesNotificationFilters(variant));
        })
      };

      // Log all changes for record keeping
      log(LOG_LEVELS.INFO, '=== All Changes ===', changes);
      log(LOG_LEVELS.INFO, '=== Filtered Changes for Notifications ===', filteredChanges);

      // Only send notification if there are filtered changes and notifications are enabled
      if ((filteredChanges.new.length || filteredChanges.stockChanged.length || filteredChanges.removed.length) &&
          (NTFY_CONFIG.appEnabled || NTFY_CONFIG.emailEnabled)) {
        
        let ntfyMessage = '';
        
        if (filteredChanges.new.length && currentSettings.notifyNew) {
          ntfyMessage += ` NEW PRODUCTS (${filteredChanges.new.length}) \n\n`;
          filteredChanges.new.forEach(p => {
            const matchingVariants = utils.processVariants(p).filter(v => matchesNotificationFilters(v));
            ntfyMessage += ` ${p.title}\n`;
            matchingVariants.forEach(v => {
              ntfyMessage += `    ${v.correctedTier} ${v.correctedWeight}\n`;
              ntfyMessage += `      $${v.price} ${v.available ? '(In Stock)' : '(Out of Stock)'}\n`;
            });
            ntfyMessage += '\n';
          });
        }
        
        if (filteredChanges.stockChanged.length && currentSettings.notifyStock) {
          ntfyMessage += ` STOCK CHANGES (${filteredChanges.stockChanged.length}) \n\n`;
          filteredChanges.stockChanged.forEach(p => {
            ntfyMessage += ` ${p.title}\n\n`;
            
            // Get new variants (variants without oldPrice or oldAvailable)
            const newVariants = p.changedVariants.filter(v => !v.oldPrice && !v.oldAvailable);
            const nowInStock = p.changedVariants.filter(v => v.oldAvailable === false && v.available === true);
            const nowOutOfStock = p.changedVariants.filter(v => v.oldAvailable === true && v.available === false);
            const priceChanges = p.changedVariants.filter(v => v.oldPrice && v.price !== v.oldPrice);
            
            // New variants added
            if (newVariants.length > 0) {
              ntfyMessage += `    NEW VARIANTS ADDED:\n`;
              newVariants.forEach(v => {
                ntfyMessage += `       ${v.correctedTier} ${v.correctedWeight}\n`;
                if (v.available) {
                  ntfyMessage += `         $${v.price} (In Stock)\n`;
                } else {
                  ntfyMessage += `         $${v.price} (Out of Stock)\n`;
                }
              });
              ntfyMessage += '\n';
            }
            
            if (nowInStock.length > 0) {
              ntfyMessage += `    NOW IN STOCK:\n`;
              nowInStock.forEach(v => {
                ntfyMessage += `       ${v.correctedTier} ${v.correctedWeight}\n         $${v.price}\n`;
              });
              ntfyMessage += '\n';
            }
            
            if (nowOutOfStock.length > 0) {
              ntfyMessage += `    NOW OUT OF STOCK:\n`;
              nowOutOfStock.forEach(v => {
                ntfyMessage += `       ${v.correctedTier} ${v.correctedWeight}\n         $${v.price}\n`;
              });
              ntfyMessage += '\n';
            }

            if (priceChanges.length > 0) {
              ntfyMessage += `    PRICE CHANGES:\n`;
              priceChanges.forEach(v => {
                const priceChange = parseFloat(v.oldPrice) - parseFloat(v.price);
                const changeSymbol = priceChange > 0 ? '' : '';
                ntfyMessage += `       ${v.correctedTier} ${v.correctedWeight}\n`;
                ntfyMessage += `        Was: $${v.oldPrice}  Now: $${v.price} ${changeSymbol}\n`;
                ntfyMessage += `        ${Math.abs(priceChange).toFixed(2)} ${priceChange > 0 ? 'decrease' : 'increase'}\n`;
              });
              ntfyMessage += '\n';
            }
          });
        }
        
        if (filteredChanges.removed.length && currentSettings.notifyRemoved) {
          ntfyMessage += ` REMOVED PRODUCTS (${filteredChanges.removed.length}) \n\n`;
          filteredChanges.removed.forEach(p => {
            const matchingVariants = utils.processVariants(p).filter(v => matchesNotificationFilters(v));
            ntfyMessage += ` ${p.title}\n`;
            matchingVariants.forEach(v => {
              ntfyMessage += `    ${v.correctedTier} ${v.correctedWeight}\n`;
            });
            ntfyMessage += '\n';
          });
        }
        
        if (ntfyMessage) {
          ntfyMessage += `\n Updated: ${new Date().toLocaleString()}`;
          await sendNtfyNotification('LitFarms Update', ntfyMessage);
        }
      }
    }

    // Update the startProductUpdateChecker function
    function startProductUpdateChecker() {
      // Create a deep copy of products to avoid reference issues
      let lastProducts = JSON.parse(JSON.stringify(products));
      const intervalMs = currentSettings.checkInterval * 60 * 1000;

      console.log(`Starting product update checker - checking every ${currentSettings.checkInterval} minutes`);

      // Start the countdown timer and get cleanup function
      const countdownCleanup = startCountdownTimer(intervalMs);
      
      // Add countdown timer cleanup to pageCleanupHandlers
      pageCleanupHandlers.push(countdownCleanup);

      updateCheckerId = setInterval(async () => {
        try {
          const freshProducts = await getProducts();
          const changes = detectProductChanges(lastProducts, freshProducts);
          
          if (changes.new.length > 0 || changes.stockChanged.length > 0 || changes.removed.length > 0) {
            console.log('Changes detected, updating state and sending notifications...');
            await handleNotifications(changes);
            products = freshProducts;
            // Update lastProducts with a deep copy
            lastProducts = JSON.parse(JSON.stringify(freshProducts));
            filterProducts();
            updateProductSelectList();
          } else {
            // Even if no changes, update lastProducts to keep it in sync
            lastProducts = JSON.parse(JSON.stringify(freshProducts));
          }
        } catch (error) {
          console.error('Error checking for product updates:', error);
        }
      }, intervalMs);

      return updateCheckerId;
    }

    // Filter THCA products
    function filterTHCAProducts(products) {
      const thcaProducts = products.filter(product => 
        product.title.toLowerCase().includes('thca') || 
        product.tags.includes('thca') || 
        product.product_type === 'THCA Flower'
      );
      //console.log(`Filtered ${products.length} total products to ${thcaProducts.length} THCA products`);
      return thcaProducts;
    }

    // preloadImages is defined later with abort signal support

    // Add cleanup handler for page unload
    let pageCleanupHandlers = [];
    
    window.addEventListener('beforeunload', () => {
      // Execute all cleanup handlers
      pageCleanupHandlers.forEach(handler => {
        try {
          handler();
        } catch (error) {
          console.warn('Cleanup handler error:', error);
        }
      });
    });

    // Add these utility functions for status management
    const statusManager = {
      show: (message, type = 'error') => {
        const statusBar = document.getElementById('site-status');
        const statusMessage = document.getElementById('status-message');
        const retryButton = document.getElementById('retry-button');
        
        statusBar.className = `site-status ${type}`;
        statusMessage.textContent = message;
        statusBar.style.display = 'block';
        
        // Show retry button for errors
        retryButton.style.display = type === 'error' ? 'inline-block' : 'none';
      },
      
      hide: () => {
        const statusBar = document.getElementById('site-status');
        statusBar.style.display = 'none';
      },
      
      update: (message) => {
        const statusMessage = document.getElementById('status-message');
        statusMessage.textContent = message;
      }
    };

    // Add maintenance mode check interval
    let maintenanceCheckerId = null;
    const MAINTENANCE_CHECK_INTERVAL = 5 * 60 * 1000; // 5 minutes in milliseconds

    // Update attemptLoad function with periodic maintenance check
    async function attemptLoad() {
      let retryCount = 0;
      const maxRetries = 3;
      let imagePreloadAbortController = new AbortController();
      
      // Add cleanup handler
      pageCleanupHandlers.push(() => {
        imagePreloadAbortController.abort();
        if (updateCheckerId) {
          clearInterval(updateCheckerId);
        }
        if (maintenanceCheckerId) {
          clearInterval(maintenanceCheckerId);
          maintenanceCheckerId = null;
        }
      });

      function startMaintenanceChecker() {
        if (maintenanceCheckerId) {
          clearInterval(maintenanceCheckerId);
        }

        // Update status message to show next check time
        const nextCheck = new Date(Date.now() + MAINTENANCE_CHECK_INTERVAL);
        statusManager.show(
          `LitFarms website is in maintenance mode. Next check at ${nextCheck.toLocaleTimeString()}. Using cached data.`,
          'warning'
        );

        maintenanceCheckerId = setInterval(async () => {
          try {
            console.log('Checking if site is back from maintenance...');
            const freshProducts = await getProducts(false);
            if (Array.isArray(freshProducts) && freshProducts.length > 0) {
              // Site is back! Clear maintenance checker and restart normal operation
              clearInterval(maintenanceCheckerId);
              maintenanceCheckerId = null;
              statusManager.hide();
              products = freshProducts;
              filterProducts();
              startProductUpdateChecker();
              console.log('Site is back online, resumed normal operation');
            }
          } catch (error) {
            console.log('Site still in maintenance mode');
            // Update status message with next check time
            const nextCheck = new Date(Date.now() + MAINTENANCE_CHECK_INTERVAL);
            statusManager.show(
              `LitFarms website is in maintenance mode. Next check at ${nextCheck.toLocaleTimeString()}. Using cached data.`,
              'warning'
            );
          }
        }, MAINTENANCE_CHECK_INTERVAL);
      }

      async function tryLoad() {
        try {
          // Hide any existing status messages
          statusManager.hide();
          
          // Load notification settings first
          loadSettings();
          
          // First try to load cached products immediately
          products = await getProducts(true);
          
          if (Array.isArray(products) && products.length > 0) {
            console.log(`Loaded ${products.length} cached THCA products`);
            loadFilterState();
            await loadStrainData();
            
            // Show products immediately
            toggleLoader(false);
            filterProducts();
            
            // Then check for updates in the background without re-rendering if unchanged
            try {
              const updatedProducts = await getProducts(false);
              // Only update if products actually changed (compare lengths and IDs)
              const productsChanged = products.length !== updatedProducts.length ||
                products.some((p, i) => p.id !== updatedProducts[i]?.id || 
                  p.variants.length !== updatedProducts[i]?.variants.length);
              
              if (productsChanged) {
                console.log('Products updated, refreshing display');
                products = updatedProducts;
                filterProducts();
              } else {
                console.log('Products unchanged, skipping re-render');
              }
            } catch (updateError) {
              console.warn('Background update failed:', updateError);
              if (updateError.message.includes('401')) {
                startMaintenanceChecker();
              }
            }
          } else {
            // No cached products, load fresh
            products = await getProducts(false);
            if (!Array.isArray(products) || products.length === 0) {
              throw new Error('No products loaded');
            }
            
            console.log(`Loaded ${products.length} fresh THCA products`);
            loadFilterState();
            await loadStrainData();
            
            toggleLoader(false);
            filterProducts();
          }

          // Start the update checker
          startProductUpdateChecker();
          
          return true; // Success
        } catch (error) {
          console.error('Error in initialization:', error);
          
          if (error.message.includes('401')) {
            if (products && products.length > 0) {
              // We have cached data, start maintenance checker
              startMaintenanceChecker();
            } else {
              statusManager.show('LitFarms website is currently in maintenance mode. Please try again later.', 'error');
            }
          } else {
            statusManager.show('Unable to load products. Please try again later.', 'error');
          }
          
          if (retryCount < maxRetries) {
            retryCount++;
            statusManager.update(`Retrying... Attempt ${retryCount} of ${maxRetries}`);
            
            // Clear cache before retrying
            localStorage.removeItem(CACHE_KEY);
            localStorage.removeItem(CACHE_TIMESTAMP_KEY);
            
            // Wait a bit before retrying
            await new Promise(resolve => setTimeout(resolve, 2000));
            return tryLoad();
          }
          
          if (!products || products.length === 0) {
            const productGrid = document.getElementById('product-grid');
            productGrid.innerHTML = `
              <div style="
                text-align: center;
                padding: 20px;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 100%;
                max-width: 400px;
              ">
                <p style="
                  color: var(--status-error);
                  margin-bottom: 15px;
                  font-size: 16px;
                  line-height: 1.4;
                ">
                  Unable to load products. The LitFarms website may be in maintenance mode.
                </p>
                <button onclick="window.location.reload()" style="
                  background-color: var(--accent-primary);
                  color: var(--bg-primary);
                  border: none;
                  padding: 10px 20px;
                  border-radius: 5px;
                  cursor: pointer;
                  font-size: 14px;
                  transition: opacity 0.2s;
                ">
                  Refresh Page
                </button>
              </div>`;
            toggleLoader(false);
          }
          
          // Start maintenance checker if it was a 401 error
          if (error.message.includes('401')) {
            startMaintenanceChecker();
          }
          
          return false;
        }
      }

      // Initial load attempt
      return tryLoad();
    }

    // Add retry button handler
    document.getElementById('retry-button').addEventListener('click', async () => {
      toggleLoader(true);
      await attemptLoad();
    });

    // Update preloadImages function to accept abort signal
    function preloadImages(products, signal) {
      return Promise.all(products.map(product => {
        if (!product.images[0]?.src) return Promise.resolve();
        return new Promise((resolve, reject) => {
          const img = new Image();
          
          // Handle abort signal
          if (signal) {
            signal.addEventListener('abort', () => {
              img.src = '';
              resolve(); // Resolve instead of reject to avoid error logging
            });
          }
          
          img.onload = () => resolve();
          img.onerror = () => resolve(); // Resolve on error to continue loading
          img.src = product.images[0].src;
        });
      }));
    }

    // Lightbox Functions
    function openLightbox(imageSrc, caption) {
      const lightbox = document.getElementById('image-lightbox');
      const lightboxImg = document.getElementById('lightbox-img');
      const lightboxCaption = document.getElementById('lightbox-caption');
      
      if (!lightbox || !lightboxImg || !lightboxCaption) {
        console.error('Lightbox elements not found');
        return;
      }
      
      // Get higher resolution image by removing size parameters from Shopify URLs
      let highResImageSrc = imageSrc;
      
      // Shopify images often have size parameters like _300x300 or _small
      // Remove these to get the original high-res image
      if (imageSrc && imageSrc.includes('cdn.shopify.com')) {
        // Remove size suffixes like _300x300, _small, _medium, _large, _compact, _grande
        highResImageSrc = imageSrc.replace(/_(pico|icon|thumb|small|compact|medium|large|grande|original|\d+x\d*|x\d+)(\.[a-z]+)/gi, '_2048x2048$2');
        // Or just get the master/original
        highResImageSrc = imageSrc.replace(/_(pico|icon|thumb|small|compact|medium|large|grande|\d+x\d*|x\d+)\./gi, '_master.');
      }
      
      lightbox.style.display = 'flex';
      lightboxImg.src = highResImageSrc;
      lightboxCaption.textContent = caption || '';
      document.body.style.overflow = 'hidden'; // Prevent background scrolling
    }

    function closeLightbox() {
      const lightbox = document.getElementById('image-lightbox');
      if (lightbox) {
        lightbox.style.display = 'none';
      }
      document.body.style.overflow = ''; // Restore scrolling
    }

    // Filters toggle functionality
    let lastScrollY = 0;
    let isFiltersManuallyToggled = false;

    function setupFiltersToggle() {
      const filtersToggle = document.getElementById('filters-toggle');
      const filtersContainer = document.querySelector('.filters-container');
      
      if (!filtersToggle) return;

      // Toggle on button click
      filtersToggle.addEventListener('click', () => {
        filtersContainer.classList.toggle('collapsed');
        isFiltersManuallyToggled = true;
        
        // Reset manual toggle flag after .5 seconds
        setTimeout(() => {
          isFiltersManuallyToggled = false;
        }, 500);
      });

      // Auto-collapse on scroll down (mobile only)
      window.addEventListener('scroll', () => {
        // Only auto-collapse on mobile
        if (window.innerWidth > 700) return;
        if (isFiltersManuallyToggled) return;
        
        const currentScrollY = window.scrollY;
        
        // Collapse when scrolling down past 100px
        if (currentScrollY > 100 && currentScrollY > lastScrollY) {
          filtersContainer.classList.add('collapsed');
        }
        // Expand when scrolling back to top
        else if (currentScrollY < 50) {
          filtersContainer.classList.remove('collapsed');
        }
        
        lastScrollY = currentScrollY;
      });
      
      // Handle resize: always show filters on desktop
      window.addEventListener('resize', () => {
        if (window.innerWidth > 700) {
          // Desktop view - always show filters
          filtersContainer.classList.remove('collapsed');
        }
      });
    }

    // Document ready event listener
    document.addEventListener('DOMContentLoaded', async () => {
      toggleLoader(true);

      // Setup filters toggle
      setupFiltersToggle();

      // Lightbox event listeners - with null checks
      const lightbox = document.getElementById('image-lightbox');
      const lightboxClose = document.querySelector('.lightbox-close');
      
      if (lightboxClose) {
        lightboxClose.addEventListener('click', closeLightbox);
      }
      
      // Close lightbox when clicking anywhere (background, image, or close button)
      if (lightbox) {
        lightbox.addEventListener('click', (e) => {
          // Close on any click within the lightbox
          closeLightbox();
        });
      }
      
      // Also add click handler to the image itself
      const lightboxImg = document.getElementById('lightbox-img');
      if (lightboxImg) {
        lightboxImg.addEventListener('click', (e) => {
          closeLightbox();
        });
      }
      
      // Close lightbox with Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const lb = document.getElementById('image-lightbox');
          if (lb && lb.style.display === 'flex') {
            closeLightbox();
          }
        }
      });

      // Settings button event listener already attached at top of file
      document.querySelector('.close-modal').addEventListener('click', closeSettingsModal);
      document.querySelector('.save-settings').addEventListener('click', saveSettingsFromForm);

      // Track mousedown position for modal
      let modalMouseDown = false;
      const modal = document.getElementById('settings-modal');
      
      modal.addEventListener('mousedown', (e) => {
        if (e.target === modal) {
          modalMouseDown = true;
        }
      });

      modal.addEventListener('mouseup', (e) => {
        if (e.target === modal && modalMouseDown) {
          closeSettingsModal();
        }
        modalMouseDown = false;
      });

      // Reset flag when mouse leaves modal
      modal.addEventListener('mouseleave', () => {
        modalMouseDown = false;
      });

      // Initialize modal tabs and chips early so they're ready when modal opens
      initializeSettingsTabs();
      initializeFilterChipListeners();

      let retryCount = 0;
      const maxRetries = 3;

      await attemptLoad();
    });

    // updateProductSelectList is defined later with event listener support

    // This function is called later and overrides the earlier one - need to merge scroll logic
    window.openSettingsModal = function() {
      var modal = document.getElementById('settings-modal');
      if (modal && modal.style.display !== 'flex') {
        // Save position BEFORE setting flag
        var savedPosition = lastKnownScrollPosition;
        isModalOpen = true;
        modalScrollPosition = savedPosition;
      }
      
      // Load current settings into form
      document.getElementById('check-interval').value = currentSettings.checkInterval;
      document.getElementById('ntfy-topic').value = currentSettings.ntfyTopic;
      document.getElementById('ntfy-server').value = currentSettings.ntfyServer;
      document.getElementById('ntfy-email').value = currentSettings.ntfyEmail;
      document.getElementById('ntfy-enabled').checked = currentSettings.ntfyAppEnabled;
      document.getElementById('email-enabled').checked = currentSettings.ntfyEmailEnabled;
      document.getElementById('enable-product-links').checked = currentSettings.enableProductLinks ?? true;
      
      // Set notification type checkboxes
      document.getElementById('notify-new').checked = currentSettings.notifyNew;
      document.getElementById('notify-stock').checked = currentSettings.notifyStock;
      document.getElementById('notify-removed').checked = currentSettings.notifyRemoved;
      
      // Update the minutes suffix position immediately after setting the value
      requestAnimationFrame(updateMinutesSuffixPosition);
      
      // Set multiple select values
      const tierSelect = document.getElementById('notification-tier');
      const weightSelect = document.getElementById('notification-weight');

      // Clear previous selections
      Array.from(tierSelect.options).forEach(option => option.selected = false);
      Array.from(weightSelect.options).forEach(option => option.selected = false);
      
      // Set new selections
      currentSettings.notificationTiers.forEach(tier => {
        const option = Array.from(tierSelect.options).find(opt => opt.value === tier);
        if (option) option.selected = true;
      });
      
      currentSettings.notificationWeights.forEach(weight => {
        const option = Array.from(weightSelect.options).find(opt => opt.value === weight);
        if (option) option.selected = true;
      });
      
      // If nothing is selected, select 'all' by default
      if (!Array.from(tierSelect.selectedOptions).length) {
        tierSelect.querySelector('option[value="all"]').selected = true;
      }
      if (!Array.from(weightSelect.selectedOptions).length) {
        weightSelect.querySelector('option[value="all"]').selected = true;
      }
      
      // Sync mobile chips with desktop selects
      syncMobileChips();
      
      // Update product list and clear search
      updateProductSelectList();
      
      // Clear search input
      const searchInput = document.getElementById('product-search');
      searchInput.value = '';
      
      // Setup search functionality
      const productSelect = document.getElementById('product-select');
      
      // Remove old event listener if exists
      const newSearchInput = searchInput.cloneNode(true);
      searchInput.parentNode.replaceChild(newSearchInput, searchInput);
      
      newSearchInput.addEventListener('input', (e) => {
        const items = productSelect.getElementsByClassName('product-select-item');
        const term = e.target.value.toLowerCase();
        
        Array.from(items).forEach(item => {
          const label = item.querySelector('label');
          const title = label.textContent.toLowerCase();
          
          if (title.includes(term)) {
            item.classList.remove('hidden');
          } else {
            item.classList.add('hidden');
          }
        });
      });

      // Show modal (reuse the modal variable from above)
      // Store scroll position and prevent body scroll without position:fixed
      document.body.style.overflow = 'hidden';
      // Only add padding compensation on desktop (where scrollbars take up space)
      var scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
      if (scrollbarWidth > 0) {
        document.body.style.paddingRight = scrollbarWidth + 'px';
      }
      
      modal.style.display = 'flex';
      document.body.classList.add('modal-open');
      
      // Just sync the checkbox state (listeners already attached on page load)
      syncNewFilterChipsState();
      
      // Check if content is scrollable and show indicator
      requestAnimationFrame(() => checkScrollIndicator(modal));
    }
    
    // Initialize settings tabs (only runs once)
    var settingsTabsInitialized = false;
    function initializeSettingsTabs() {
      if (settingsTabsInitialized) return;
      settingsTabsInitialized = true;
      
      const tabs = document.querySelectorAll('.settings-tab');
      
      // Add listeners once using event delegation would be better, but this works
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const targetTab = tab.dataset.tab;
          
          // Update active tab
          document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          // Update active content
          document.querySelectorAll('.settings-tab-content').forEach(content => {
            if (content.dataset.content === targetTab) {
              content.classList.add('active');
            } else {
              content.classList.remove('active');
            }
          });
        });
      });
    }
    
    // Initialize chip listeners once
    var filterChipsInitialized = false;
    function initializeFilterChipListeners() {
      if (filterChipsInitialized) return;
      filterChipsInitialized = true;
      
      const tierSelect = document.getElementById('notification-tier');
      const weightSelect = document.getElementById('notification-weight');
      
      // Add tier chip listeners once
      const tierChips = document.querySelectorAll('#tier-chips-new input[type="checkbox"]');
      tierChips.forEach(chip => {
        chip.addEventListener('change', () => {
          const option = Array.from(tierSelect.options).find(opt => opt.value === chip.value);
          if (option) {
            option.selected = chip.checked;
          }
        });
      });
      
      // Add weight chip listeners once
      const weightChips = document.querySelectorAll('#weight-chips-new input[type="checkbox"]');
      weightChips.forEach(chip => {
        chip.addEventListener('change', () => {
          const option = Array.from(weightSelect.options).find(opt => opt.value === chip.value);
          if (option) {
            option.selected = chip.checked;
          }
        });
      });
    }
    
    // Just sync the checkbox states (listeners already initialized on page load)
    function syncNewFilterChipsState() {
      const tierSelect = document.getElementById('notification-tier');
      const weightSelect = document.getElementById('notification-weight');
      
      // Sync tier chips state only (fast operation)
      const tierChips = document.querySelectorAll('#tier-chips-new input[type="checkbox"]');
      tierChips.forEach(chip => {
        const isSelected = Array.from(tierSelect.selectedOptions).some(opt => opt.value === chip.value);
        chip.checked = isSelected;
      });
      
      // Sync weight chips state only (fast operation)
      const weightChips = document.querySelectorAll('#weight-chips-new input[type="checkbox"]');
      weightChips.forEach(chip => {
        const isSelected = Array.from(weightSelect.selectedOptions).some(opt => opt.value === chip.value);
        chip.checked = isSelected;
      });
    }
    
    // Function to check if modal content is scrollable
    function checkScrollIndicator(modal) {
      const modalContent = modal.querySelector('.modal-content');
      const modalFooter = modal.querySelector('.modal-footer');
      
      if (modalContent && modalFooter) {
        const isScrollable = modalContent.scrollHeight > modalContent.clientHeight;
        
        if (isScrollable) {
          modalFooter.classList.add('show-scroll-indicator');
        } else {
          modalFooter.classList.remove('show-scroll-indicator');
        }
        
        // Update indicator on scroll
        modalContent.addEventListener('scroll', function() {
          const isAtBottom = modalContent.scrollHeight - modalContent.scrollTop <= modalContent.clientHeight + 10;
          
          if (isAtBottom) {
            modalFooter.classList.remove('show-scroll-indicator');
          } else if (isScrollable) {
            modalFooter.classList.add('show-scroll-indicator');
          }
        });
      }
    }

    // closeSettingsModal is already defined globally at the top

    // Sync mobile chips with desktop selects
    function syncMobileChips() {
      const tierSelect = document.getElementById('notification-tier');
      const weightSelect = document.getElementById('notification-weight');
      
      // Sync tier chips
      const tierChips = document.querySelectorAll('#tier-chips input[type="checkbox"]');
      tierChips.forEach(checkbox => {
        const value = checkbox.value;
        const option = Array.from(tierSelect.options).find(opt => opt.value === value);
        checkbox.checked = option && option.selected;
      });
      
      // Sync weight chips
      const weightChips = document.querySelectorAll('#weight-chips input[type="checkbox"]');
      weightChips.forEach(checkbox => {
        const value = checkbox.value;
        const option = Array.from(weightSelect.options).find(opt => opt.value === value);
        checkbox.checked = option && option.selected;
      });
      
      // Add event listeners to mobile chips
      document.querySelectorAll('.filter-chip input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          const group = this.dataset.group;
          const value = this.value;
          
          // Handle "all" selection
          if (value === 'all' && this.checked) {
            // Uncheck all others in this group
            document.querySelectorAll(`.filter-chip input[data-group="${group}"]`).forEach(cb => {
              if (cb.value !== 'all') cb.checked = false;
            });
          } else if (this.checked) {
            // Uncheck "all" when selecting specific items
            const allCheckbox = document.querySelector(`.filter-chip input[data-group="${group}"][value="all"]`);
            if (allCheckbox) allCheckbox.checked = false;
          }
          
          // Sync back to desktop select
          syncChipsToSelect(group);
        });
      });
    }
    
    // Sync mobile chips back to desktop selects
    function syncChipsToSelect(group) {
      const selectId = group === 'tier' ? 'notification-tier' : 'notification-weight';
      const select = document.getElementById(selectId);
      const chips = document.querySelectorAll(`.filter-chip input[data-group="${group}"]`);
      
      // Clear all selections
      Array.from(select.options).forEach(option => option.selected = false);
      
      // Set selections based on checked chips
      chips.forEach(checkbox => {
        if (checkbox.checked) {
          const option = Array.from(select.options).find(opt => opt.value === checkbox.value);
          if (option) option.selected = true;
        }
      });
      
      // If nothing selected, select 'all'
      if (!Array.from(select.selectedOptions).length) {
        select.querySelector('option[value="all"]').selected = true;
        const allChip = document.querySelector(`.filter-chip input[data-group="${group}"][value="all"]`);
        if (allChip) allChip.checked = true;
      }
    }

    function getSelectedValues(selectElement) {
      const selectedValues = Array.from(selectElement.selectedOptions).map(option => option.value);
      // If nothing is selected or only 'all' is selected, return ['all']
      return selectedValues.length === 0 ? ['all'] : selectedValues;
    }

    function saveSettingsFromForm() {
      const newSettings = {
        checkInterval: parseInt(document.getElementById('check-interval').value) || DEFAULT_SETTINGS.checkInterval,
        notificationTiers: getSelectedValues(document.getElementById('notification-tier')),
        notificationWeights: getSelectedValues(document.getElementById('notification-weight')),
        notifyNew: document.getElementById('notify-new').checked,
        notifyStock: document.getElementById('notify-stock').checked,
        notifyRemoved: document.getElementById('notify-removed').checked,
        specificProducts: Array.from(document.querySelectorAll('#product-select input:checked')).map(cb => cb.value),
        ntfyAppEnabled: document.getElementById('ntfy-enabled').checked,
        ntfyEmailEnabled: document.getElementById('email-enabled').checked,
        ntfyTopic: document.getElementById('ntfy-topic').value.trim(),
        ntfyServer: document.getElementById('ntfy-server').value.trim() || DEFAULT_SETTINGS.ntfyServer,
        ntfyEmail: document.getElementById('ntfy-email').value.trim(),
        enableProductLinks: document.getElementById('enable-product-links').checked
      };

      // Update Ntfy config
      NTFY_CONFIG.appEnabled = newSettings.ntfyAppEnabled;
      NTFY_CONFIG.emailEnabled = newSettings.ntfyEmailEnabled;
      NTFY_CONFIG.topic = newSettings.ntfyTopic;
      NTFY_CONFIG.server = newSettings.ntfyServer;
      NTFY_CONFIG.email = newSettings.ntfyEmail;

      // Log the settings being saved
      console.log('Saving settings:', newSettings);

      saveSettings(newSettings);
      closeSettingsModal();
    }

    // Event listeners for the multiple selects
    document.addEventListener('DOMContentLoaded', () => {
      const tierSelect = document.getElementById('notification-tier');
      const weightSelect = document.getElementById('notification-weight');

      function handleAllOption(selectElement) {
        selectElement.addEventListener('change', (e) => {
          const allOption = selectElement.querySelector('option[value="all"]');
          const otherOptions = Array.from(selectElement.options).filter(opt => opt.value !== 'all');
          
          if (allOption.selected) {
            // If 'all' is selected, deselect other options
            otherOptions.forEach(opt => opt.selected = false);
          } else if (Array.from(selectElement.selectedOptions).length === 0) {
            // If nothing is selected, select 'all'
            allOption.selected = true;
          } else {
            // If other options are selected, deselect 'all'
            allOption.selected = false;
          }
        });
      }

      handleAllOption(tierSelect);
      handleAllOption(weightSelect);
    });



    // Dynamic suffix positioning
    function updateMinutesSuffixPosition() {
      const input = document.getElementById('check-interval');
      const suffix = input.nextElementSibling;
      const valueLength = input.value.length;
      const basePosition = 28; // Base position for single digit
      const digitWidth = 8; // Approximate width per digit
      
      // Calculate new position based on number of digits
      const newPosition = basePosition + (valueLength - 1) * digitWidth;
      suffix.style.left = `${newPosition}px`;
    }

    // Event listeners for the check interval input
    document.addEventListener('DOMContentLoaded', () => {
      const checkIntervalInput = document.getElementById('check-interval');
      
      // Update position on any input change
      checkIntervalInput.addEventListener('input', updateMinutesSuffixPosition);
      
      // Initial position
      updateMinutesSuffixPosition();
    });

    // Test Ntfy notification
    let testButtonCooldown = false;
    const COOLDOWN_PERIOD = 30000; // 10 seconds in milliseconds

    async function testNtfyNotification() {
      if (testButtonCooldown) {
        return;
      }

      // Get current form values instead of using saved settings
      const appEnabled = document.getElementById('ntfy-enabled').checked;
      const emailEnabled = document.getElementById('email-enabled').checked;
      const topic = document.getElementById('ntfy-topic').value.trim();
      const server = document.getElementById('ntfy-server').value.trim() || DEFAULT_SETTINGS.ntfyServer;
      const email = document.getElementById('ntfy-email').value.trim();

      if (!appEnabled && !emailEnabled) {
        alert('Please enable at least one notification method');
        return;
      }

      if (appEnabled && !topic) {
        alert('Please set a topic for app notifications');
        return;
      }

      if (emailEnabled && !email) {
        alert('Please set an email address for email notifications');
        return;
      }

      const testButton = document.getElementById('test-ntfy');
      testButton.disabled = true;
      testButton.textContent = 'Sending...';

      // Set cooldown flag
      testButtonCooldown = true;

      try {
        // Create temporary config for test
        const tempConfig = {
          appEnabled: appEnabled,
          emailEnabled: emailEnabled,
          topic: topic,
          server: server,
          email: email
        };

        // Store current config
        const originalConfig = { ...NTFY_CONFIG };
        
        // Temporarily set config to form values
        Object.assign(NTFY_CONFIG, tempConfig);

        const testMessage = ` NEW PRODUCTS (2) 

 Blue Dream THCA Flower
    Essential 28g
      $49.99

 Purple Punch THCA Flower
    Supreme 28g
      $89.99


 STOCK CHANGES (2) 

 Gelato THCA Flower

    NOW IN STOCK:
       Essential 28g
         $49.99

    NOW OUT OF STOCK:
       Preferred 28g
         $69.99


 Wedding Cake THCA Flower

    NOW IN STOCK:
       Supreme 28g
         $89.99


 REMOVED PRODUCTS (1) 

 Northern Lights THCA Flower


 Updated: ${new Date().toLocaleString()}`;

        await sendNtfyNotification(
          'LitFarms Test Notification',
          testMessage
        );
        testButton.textContent = 'Notification Sent!';

        // Restore original config
        Object.assign(NTFY_CONFIG, originalConfig);
      } catch (error) {
        console.error('Failed to send test notification:', error);
        testButton.textContent = 'Error!';
        
        // Restore original config in case of error
        Object.assign(NTFY_CONFIG, originalConfig);
      }

      // Start cooldown timer
      setTimeout(() => {
        testButtonCooldown = false;
        testButton.disabled = false;
        testButton.textContent = 'Test Notifications';
      }, COOLDOWN_PERIOD);

      // Countdown timer
      let remainingTime = COOLDOWN_PERIOD / 1000;
      const countdownInterval = setInterval(() => {
        remainingTime--;
        if (remainingTime > 0) {
          testButton.textContent = `Wait ${remainingTime}s`;
        } else {
          clearInterval(countdownInterval);
        }
      }, 1000);
    }

    // Update selected products count
    function updateSelectedProductsCount() {
      const selectedCount = document.querySelectorAll('#product-select input:checked').length;
      const countElement = document.getElementById('products-selected-count');
      countElement.textContent = `${selectedCount} product${selectedCount === 1 ? '' : 's'} selected`;
    }

    // Deselect all products
    function deselectAllProducts() {
      const checkboxes = document.querySelectorAll('#product-select input[type="checkbox"]');
      checkboxes.forEach(checkbox => {
        checkbox.checked = false;
      });
      updateSelectedProductsCount();
    }

    // Update the updateProductSelectList function to include count updates
    function updateProductSelectList() {
      const productSelect = document.getElementById('product-select');
      productSelect.innerHTML = '';

      // Sort products alphabetically by title
      const sortedProducts = [...products].sort((a, b) => 
        a.title.toLowerCase().localeCompare(b.title.toLowerCase())
      );

      sortedProducts.forEach(product => {
        const item = document.createElement('div');
        item.className = 'product-select-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `product-${product.handle}`;
        checkbox.value = product.handle;
        checkbox.checked = currentSettings.specificProducts.includes(product.handle);
        
        // Update count
        checkbox.addEventListener('change', updateSelectedProductsCount);
        
        const label = document.createElement('label');
        label.htmlFor = `product-${product.handle}`;
        label.textContent = product.title;
        
        item.appendChild(checkbox);
        item.appendChild(label);
        productSelect.appendChild(item);
      });

      // Update initial count
      updateSelectedProductsCount();

      // Search functionality
      const searchInput = document.getElementById('product-search');
      
      function filterProducts(searchTerm) {
        const items = productSelect.getElementsByClassName('product-select-item');
        const term = searchTerm.toLowerCase();
        
        Array.from(items).forEach(item => {
          const label = item.querySelector('label');
          const title = label.textContent.toLowerCase();
          
          if (title.includes(term)) {
            item.classList.remove('hidden');
          } else {
            item.classList.add('hidden');
          }
        });
      }

      // Search event listener
      searchInput.addEventListener('input', (e) => {
        filterProducts(e.target.value);
      });

      // Clear search when modal is opened
      searchInput.value = '';
      filterProducts('');
    }

    // Topic name arrays
    const ADJECTIVES = ['swift', 'bright', 'cosmic', 'mystic', 'golden', 'silver', 'crystal', 'azure', 'crimson', 'emerald'];
    const NOUNS = ['phoenix', 'dragon', 'falcon', 'tiger', 'wolf', 'eagle', 'lion', 'hawk', 'panther', 'bear'];
    
    // Force refresh function - clears cache and reloads
    function forceRefresh() {
      // Clear all caches if available
      if ('caches' in window) {
        caches.keys().then(function(names) {
          for (let name of names) {
            caches.delete(name);
          }
        });
      }
      
      // Clear service worker if registered
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
          for (let registration of registrations) {
            registration.unregister();
          }
        });
      }
      
      // Add timestamp to URL to force reload
      const url = new URL(window.location.href);
      url.searchParams.set('_refresh', Date.now());
      
      // Hard reload with cache bypass
      window.location.href = url.href;
      window.location.reload(true);
    }

    // Random topic name generator
    function generateRandomTopic() {
      // Get random elements from arrays
      const adjective = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
      const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
      
      // Generate random numbers (4 digits)
      const numbers = Math.floor(1000 + Math.random() * 9000);
      
      // Generate random letters (2 characters)
      const letters = String.fromCharCode(65 + Math.floor(Math.random() * 26)) + 
                     String.fromCharCode(65 + Math.floor(Math.random() * 26));
      
      // Combine everything with dashes
      const topic = `litfarms-${adjective}-${noun}-${numbers}${letters}`;
      
      // Set the value in the input field
      document.getElementById('ntfy-topic').value = topic;
    }

    // Clear search functionality
    const clearSearchButton = document.getElementById('clear-search');
    const searchInput = document.getElementById('product-search-filter');

    // Show/hide clear button based on search input content
    searchInput.addEventListener('input', () => {
      clearSearchButton.style.display = searchInput.value ? 'flex' : 'none';
      filterProducts();
      saveFilterState();
    });

    // Move cursor to end when input receives focus
    searchInput.addEventListener('focus', () => {
      const length = searchInput.value.length;
      searchInput.setSelectionRange(length, length);
    });

    // Close keyboard on enter key press
    searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        searchInput.blur(); // This will close the keyboard on mobile
      }
    });

    // Clear search when button is clicked
    clearSearchButton.addEventListener('click', () => {
      searchInput.value = '';
      clearSearchButton.style.display = 'none';
      filterProducts();
      saveFilterState();
    });

    // Utility Functions
    const WEIGHTS = ['28g', '3.5g', '7g', '28g (Smalls)'];
    const TIERS = ['Essential', 'Preferred', 'Supreme'];
    
    const utils = {
      isWeight: (value) => value && WEIGHTS.includes(value),
      isTier: (value) => value && TIERS.includes(value),
      hasValidPrice: (variant) => variant.price && !isNaN(parseFloat(variant.price)) && parseFloat(variant.price) > 0,
      
      standardizeWeight: (weightStr) => {
        if (!weightStr) return null;
        weightStr = weightStr.trim();
        // Handle "28g (Smalls)" as a special case
        if (weightStr.toLowerCase().includes('smalls')) {
          return '28g (Smalls)';
        }
        if (weightStr.match(/^\d+\.?\d*$/)) weightStr += 'g';
        if (weightStr === '3.5') weightStr = '3.5g';
        return weightStr;
      },
      
      processVariants: (product) => {
        return product.variants.map(v => {
          const weight = utils.isWeight(v.option1) ? v.option1 : utils.isWeight(v.option2) ? v.option2 : null;
          let tier = utils.isTier(v.option1) ? v.option1 : utils.isTier(v.option2) ? v.option2 : null;
          if (weight && !tier) tier = 'Essential';
          // Check if on sale: compare_at_price exists, is not null/empty, and is greater than price
          const comparePrice = v.compare_at_price ? parseFloat(v.compare_at_price) : 0;
          const currentPrice = parseFloat(v.price);
          const isOnSale = v.compare_at_price && comparePrice > currentPrice;
          
          return {
            ...v,
            correctedWeight: weight,
            correctedTier: tier,
            hasPrice: utils.hasValidPrice(v),
            isOnSale: isOnSale,
            compareAtPrice: v.compare_at_price
          };
        }).filter(v => v.correctedWeight && v.hasPrice);
      },
      
      getVariantKey: (variant) => 
        `${variant.correctedTier}-${variant.correctedWeight}-${variant.price}-${variant.available}`,
        
      extractTierAndWeight: (str) => {
        const parts = str.split('/').map(s => s.trim());
        const weightPart = parts.find(p => utils.isWeight(utils.standardizeWeight(p)));
        const tierPart = parts.find(p => TIERS.includes(p));
        return { 
          weight: weightPart ? utils.standardizeWeight(weightPart) : null, 
          tier: tierPart 
        };
      },

      sortProducts: (products, sortFilter, strainFilter, weightFilter) => {
        return [...products].sort((a, b) => {
          switch (sortFilter) {
            case 'alpha-asc':
              return a.title.localeCompare(b.title);
            case 'alpha-desc':
              return b.title.localeCompare(a.title);
            case 'date-desc':
              return new Date(b.published_at) - new Date(a.published_at);
            case 'date-asc':
              return new Date(a.published_at) - new Date(b.published_at);
            case 'price-asc':
            case 'price-desc': {
              // Get valid variants for both products
              const aVariants = utils.processVariants(a);
              const bVariants = utils.processVariants(b);

              // Filter variants based on current filters
              let relevantAVariants = aVariants;
              let relevantBVariants = bVariants;

              if (weightFilter !== 'all') {
                relevantAVariants = relevantAVariants.filter(v => v.correctedWeight === weightFilter);
                relevantBVariants = relevantBVariants.filter(v => v.correctedWeight === weightFilter);
              }
              if (strainFilter !== 'all') {
                relevantAVariants = relevantAVariants.filter(v => v.correctedTier === strainFilter);
                relevantBVariants = relevantBVariants.filter(v => v.correctedTier === strainFilter);
              }
              
              // If in "In Stock Only" mode, only consider available variants
              if (!domElements.stockFilter.classList.contains('active')) {
                relevantAVariants = relevantAVariants.filter(v => v.available);
                relevantBVariants = relevantBVariants.filter(v => v.available);
              }

              // If no relevant variants after filtering, push to end of sort
              if (relevantAVariants.length === 0) return 1;
              if (relevantBVariants.length === 0) return -1;

              // Get the min/max prices for comparison
              const aPrice = relevantAVariants.length ? 
                (sortFilter === 'price-asc' ? 
                  Math.min(...relevantAVariants.map(v => parseFloat(v.price))) : 
                  Math.max(...relevantAVariants.map(v => parseFloat(v.price)))) : 
                Infinity;
              const bPrice = relevantBVariants.length ? 
                (sortFilter === 'price-asc' ? 
                  Math.min(...relevantBVariants.map(v => parseFloat(v.price))) : 
                  Math.max(...relevantBVariants.map(v => parseFloat(v.price)))) : 
                Infinity;

              // If prices are equal, sort alphabetically
              if (aPrice === bPrice) {
                return a.title.localeCompare(b.title);
              }

              return sortFilter === 'price-asc' ? aPrice - bPrice : bPrice - aPrice;
            }
            default:
              return 0;
          }
        });
      }
    };

    // Cache frequently accessed DOM elements
    const domElements = {
      productGrid: document.getElementById('product-grid'),
      productCount: document.getElementById('product-count'),
      strainFilter: document.getElementById('strain-filter'),
      strainTypeFilter: document.getElementById('strain-type-filter'),
      weightFilter: document.getElementById('weight-filter'),
      sortFilter: document.getElementById('sort-filter'),
      stockFilter: document.getElementById('stock-filter'),
      saleFilter: document.getElementById('sale-filter'),
      searchInput: document.getElementById('product-search-filter'),
      clearSearch: document.getElementById('clear-search'),
      loader: document.getElementById('loader'),
      settingsModal: document.getElementById('settings-modal')
    };

    // Constants for logging
    const LOG_LEVELS = {
      INFO: 'INFO',
      WARN: 'WARN',
      ERROR: 'ERROR'
    };

    function log(level, message, data = null) {
      const logMessage = `${message}`;
      
      switch(level) {
        case LOG_LEVELS.ERROR:
          data ? console.error(logMessage, data) : console.error(logMessage);
          break;
        case LOG_LEVELS.WARN:
          data ? console.warn(logMessage, data) : console.warn(logMessage);
          break;
        default:
          data ? console.log(logMessage, data) : console.log(logMessage);
      }
    }

    // Update startCountdownTimer function for better state management
    function startCountdownTimer(intervalMs) {
      const countdownEl = document.querySelector('.countdown-time');
      const tooltipTimeEl = document.querySelector('.tooltip-time');
      const progressCircle = document.querySelector('.progress');
      const circumference = 2 * Math.PI * 16; // r = 16
      
      // Reset all visual elements first
      progressCircle.style.strokeDasharray = circumference;
      progressCircle.style.strokeDashoffset = 0;
      countdownEl.textContent = '';
      tooltipTimeEl.textContent = '';
      
      let timeLeft = intervalMs;
      let timerId = null;
      let isActive = true; // Track if this timer instance is active
      
      function updateCountdown() {
        // Only update if this timer instance is still active
        if (!isActive) return;
        
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        countdownEl.textContent = display;
        tooltipTimeEl.textContent = display;
        
        // Update progress circle
        const progress = (timeLeft / intervalMs) * 100;
        const offset = circumference - (progress / 100) * circumference;
        progressCircle.style.strokeDashoffset = offset;
        
        timeLeft -= 1000;
        
        if (timeLeft < 0) {
          timeLeft = intervalMs;
        }
      }
      
      // Initial update
      updateCountdown();
      
      // Start the interval
      timerId = setInterval(updateCountdown, 1000);
      
      // Return cleanup function
      return () => {
        isActive = false; // Mark this timer instance as inactive
        if (timerId) {
          clearInterval(timerId);
          timerId = null;
        }
        // Reset visual elements on cleanup
        countdownEl.textContent = '';
        tooltipTimeEl.textContent = '';
        progressCircle.style.strokeDashoffset = 0;
      };
    }

    // Virtual Cart State
    const virtualCart = {
      items: [],
      
      addItem(product, variant, buttonElement) {
        // Add visual feedback to the clicked button
        if (buttonElement && buttonElement.classList.contains('add-to-cart-button')) {
          buttonElement.classList.add('clicked');
          setTimeout(() => buttonElement.classList.remove('clicked'), 400);
        }

        const existingItemIndex = this.items.findIndex(item => item.variantId === variant.id);
        
        if (existingItemIndex !== -1) {
          // Update quantity of existing item
          this.items[existingItemIndex].quantity += 1;
        } else {
          // Add new item with quantity 1
          this.items.push({
            productId: product.id,
            productTitle: product.title,
            variantId: variant.id,
            variantTitle: `${variant.correctedTier} ${variant.correctedWeight}`,
            price: parseFloat(variant.price),
            available: variant.available,
            quantity: 1
          });
        }

        // Add visual feedback to the cart icon
        const cartButton = document.getElementById('virtual-cart-button');
        cartButton.classList.add('pulse');
        setTimeout(() => cartButton.classList.remove('pulse'), 500);

        this.updateUI();
        this.saveToLocalStorage();
      },

      updateQuantity(index, newQuantity) {
        if (newQuantity > 0) {
          this.items[index].quantity = newQuantity;
          this.updateUI();
          this.saveToLocalStorage();
        } else {
          this.removeItem(index);
        }
      },

      removeItem(index) {
        this.items.splice(index, 1);
        this.updateUI();
        this.saveToLocalStorage();
      },

      clearCart() {
        this.items = [];
        this.updateUI();
        this.saveToLocalStorage();
      },

      updateUI() {
        // Update cart count (sum of all quantities)
        const cartCount = document.querySelector('.cart-count');
        const totalItems = this.items.reduce((sum, item) => sum + item.quantity, 0);
        cartCount.textContent = totalItems;

        // Update cart modal contents
        const cartItems = document.getElementById('cart-items');
        const cartTotal = document.getElementById('cart-total');
        
        if (this.items.length === 0) {
          cartItems.innerHTML = '<div class="empty-cart-message">Your cart is empty</div>';
          cartTotal.textContent = '0.00';
          return;
        }

        cartItems.innerHTML = this.items.map((item, index) => {
          // Extract tier from variant title
          const tier = item.variantTitle.includes('Essential') ? 'Essential' : 
                      item.variantTitle.includes('Preferred') ? 'Preferred' : 
                      item.variantTitle.includes('Supreme') ? 'Supreme' : '';
          
          // Remove tier name from variant title to avoid redundancy
          let cleanVariantTitle = item.variantTitle;
          if (tier) {
            cleanVariantTitle = cleanVariantTitle.replace(tier, '').trim();
          }
          
          // Get tier icon SVG
          const getTierIcon = (tier) => {
            if (tier === 'Essential') {
              return '<svg width="12" height="12" viewBox="-351 153 256 256" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M-177.7,334.5c6.3-2.3,12.6-5.2,19.8-8.6c31.9-16.4,51.7-41.7,51.7-41.7s-32.5,0.6-64.4,17c-4,1.7-7.5,4-10.9,5.7c5.7-7.5,12.1-16.4,18.7-25c25-37.1,31.3-77.3,31.3-77.3s-34.8,21-59.2,58.6c-5.2,7.5-9.8,14.9-13.8,22.7c1.1-10.3,1.1-22.1,1.1-33.6c0-50-19.8-91.1-19.8-91.1s-19.8,40.5-19.8,91.1c0,12.1,0.6,23.3,1.1,33.6c-4-7.5-8.6-14.9-13.8-22.7c-25-37.1-59.2-58.6-59.2-58.6s6.3,40,31.3,77.3c6.3,9.2,12.1,17.5,18.7,25c-3.4-2.3-7.5-4-10.9-5.7c-31.9-16.4-64.4-17-64.4-17s19.8,25.6,51.7,41.7c6.9,3.4,13.2,6.3,19.8,8.6c-4,0.6-8,1.1-12.1,2.3c-30.5,6.4-53.2,23.9-53.2,23.9s27.3,7.5,58.6,1.1c9.8-2.3,19.8-4.6,27.3-7.5c-1.1,1.1,15.8-8.6,21.6-14.4v60.4h8.6v-61.8c6.3,6.3,22.7,16.4,22.1,14.9c8,2.9,17.5,5.2,27.3,7.5c30.8,6.3,58.6-1.1,58.6-1.1s-22.1-17.5-53.4-23.8C-169.6,335.7-173.7,335.1-177.7,334.5z" fill="currentColor"/></svg>';
            } else if (tier === 'Preferred') {
              return '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.15316 5.40838C10.4198 3.13613 11.0531 2 12 2C12.9469 2 13.5802 3.13612 14.8468 5.40837L15.1745 5.99623C15.5345 6.64193 15.7144 6.96479 15.9951 7.17781C16.2757 7.39083 16.6251 7.4699 17.3241 7.62805L17.9605 7.77203C20.4201 8.32856 21.65 8.60682 21.9426 9.54773C22.2352 10.4886 21.3968 11.4691 19.7199 13.4299L19.2861 13.9372C18.8096 14.4944 18.5713 14.773 18.4641 15.1177C18.357 15.4624 18.393 15.8341 18.465 16.5776L18.5306 17.2544C18.7841 19.8706 18.9109 21.1787 18.1449 21.7602C17.3788 22.3417 16.2273 21.8115 13.9243 20.7512L13.3285 20.4768C12.6741 20.1755 12.3469 20.0248 12 20.0248C11.6531 20.0248 11.3259 20.1755 10.6715 20.4768L10.0757 20.7512C7.77268 21.8115 6.62118 22.3417 5.85515 21.7602C5.08912 21.1787 5.21588 19.8706 5.4694 17.2544L5.53498 16.5776C5.60703 15.8341 5.64305 15.4624 5.53586 15.1177C5.42868 14.773 5.19043 14.4944 4.71392 13.9372L4.2801 13.4299C2.60325 11.4691 1.76482 10.4886 2.05742 9.54773C2.35002 8.60682 3.57986 8.32856 6.03954 7.77203L6.67589 7.62805C7.37485 7.4699 7.72433 7.39083 8.00494 7.17781C8.28555 6.96479 8.46553 6.64194 8.82547 5.99623L9.15316 5.40838Z" fill="currentColor"/></svg>';
            } else if (tier === 'Supreme') {
              return '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21.609 13.5616L21.8382 11.1263C22.0182 9.2137 22.1082 8.25739 21.781 7.86207C21.604 7.64823 21.3633 7.5172 21.106 7.4946C20.6303 7.45282 20.0329 8.1329 18.8381 9.49307C18.2202 10.1965 17.9113 10.5482 17.5666 10.6027C17.3757 10.6328 17.1811 10.6018 17.0047 10.5131C16.6865 10.3529 16.4743 9.91812 16.0499 9.04851L13.8131 4.46485C13.0112 2.82162 12.6102 2 12 2C11.3898 2 10.9888 2.82162 10.1869 4.46486L7.95007 9.04852C7.5257 9.91812 7.31351 10.3529 6.99526 10.5131C6.81892 10.6018 6.62434 10.6328 6.43337 10.6027C6.08872 10.5482 5.77977 10.1965 5.16187 9.49307C3.96708 8.1329 3.36968 7.45282 2.89399 7.4946C2.63666 7.5172 2.39598 7.64823 2.21899 7.86207C1.8918 8.25739 1.9818 9.2137 2.16181 11.1263L2.391 13.5616C2.76865 17.5742 2.95748 19.5805 4.14009 20.7902C5.32271 22 7.09517 22 10.6401 22H13.3599C16.9048 22 18.6773 22 19.8599 20.7902C21.0425 19.5805 21.2313 17.5742 21.609 13.5616Z" fill="currentColor"/></svg>';
            }
            return '';
          };
          
          const tierBadge = tier ? `<span class="cart-tier-badge tier-${tier.toLowerCase()}">${getTierIcon(tier)}${tier}</span>` : '';
          
          // Format price display: show breakdown if quantity > 1
          const priceDisplay = item.quantity > 1 
            ? `<span class="price-unit">$${item.price.toFixed(2)}</span> <span class="price-multiply"></span> <span class="price-qty">${item.quantity}</span> <span class="price-equals">=</span> <span class="price-total">$${(item.price * item.quantity).toFixed(2)}</span>`
            : `<span class="price-single">$${item.price.toFixed(2)}</span>`;
          
          return `
          <div class="cart-item" data-tier="${tier}">
            <div class="cart-item-info">
              <div class="cart-item-title">${item.productTitle}</div>
              <div class="cart-item-variant">
                ${tierBadge}
                <span>${cleanVariantTitle}</span>
              </div>
              <div class="cart-item-price">${priceDisplay}</div>
            </div>
            <div class="cart-item-controls">
              <div class="quantity-controls">
                <button class="quantity-btn" onclick="virtualCart.updateQuantity(${index}, ${item.quantity - 1})">-</button>
                <span class="quantity-display">${item.quantity}</span>
                <button class="quantity-btn" onclick="virtualCart.updateQuantity(${index}, ${item.quantity + 1})">+</button>
              </div>
              <button class="remove-from-cart" onclick="virtualCart.removeItem(${index})"></button>
            </div>
          </div>
        `;
        }).join('');

        // Update total
        const total = this.items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
        cartTotal.textContent = total.toFixed(2);
      },

      saveToLocalStorage() {
        localStorage.setItem('virtualCart', JSON.stringify(this.items));
      },

      loadFromLocalStorage() {
        const saved = localStorage.getItem('virtualCart');
        if (saved) {
          this.items = JSON.parse(saved);
          this.updateUI();
        }
      }
    };

    // openCartModal already includes virtualCart.updateUI() and checkScrollIndicator
    // No need to wrap it again

    function checkout() {
      if (virtualCart.items.length === 0) return;
      
      // Build a Shopify cart permalink
      const cartItems = virtualCart.items.map(item => 
        item.variantId + ':' + item.quantity
      ).join(',');
      
      const params = new URLSearchParams();
      params.append('sca_ref', REFERRAL_PARAMS.sca_ref);
      params.append('sca_crp', REFERRAL_PARAMS.sca_crp);

      // Build the cart URL with referral params
      const cartUrl = 'https://litfarms.com/cart/' + cartItems + '?' + params.toString();
      
      // Safari iOS has strict popup blocking, so we need to open the window immediately
      // We'll just go directly to the cart with params - Shopify should handle the tracking
      const isSafariIOS = /iPhone|iPad|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent) && !/Chrome|CriOS|FxiOS/.test(navigator.userAgent);
      
      if (isSafariIOS) {
        // For Safari iOS: Open window immediately to avoid popup blocking
        // Then try to initialize tracking in the background
        const newWindow = window.open(cartUrl, '_blank');
        
        // Try to load tracking in background using fetch (won't affect the opened window)
        // This is best-effort - the URL params should still work
        try {
          fetch('https://litfarms.com/?' + params.toString(), { 
            mode: 'no-cors',
            credentials: 'include'
          }).catch(() => {
            // Silently fail - the URL params should still work
          });
        } catch (e) {
          // Ignore errors
        }
      } else {
        // For other browsers: Use the two-step approach for better tracking
        const homeUrl = 'https://litfarms.com/?' + params.toString();
        const newWindow = window.open(homeUrl, '_blank');

        // After a delay, redirect to the cart with items
        setTimeout(() => {
          if (newWindow && !newWindow.closed) {
            newWindow.location.href = cartUrl;
          }
        }, 1500);
      }

      // Clear the virtual cart
      virtualCart.clearCart();
      closeCartModal();
    }

    // Initialize cart
    document.addEventListener('DOMContentLoaded', () => {
      virtualCart.loadFromLocalStorage();
      
      // Cart button event listener already attached at top of file

      // Track mousedown position for cart modal
      let cartModalMouseDown = false;
      const cartModal = document.getElementById('cart-modal');
      
      cartModal.addEventListener('mousedown', (e) => {
        if (e.target === cartModal) {
          cartModalMouseDown = true;
        }
      });

      cartModal.addEventListener('mouseup', (e) => {
        if (e.target === cartModal && cartModalMouseDown) {
          closeCartModal();
        }
        cartModalMouseDown = false;
      });
      
      // Touch support for cart modal - prevent background scrolling
      cartModal.addEventListener('touchstart', (e) => {
        if (e.target === cartModal) {
          cartModalMouseDown = true;
        }
      }, { passive: true });

      cartModal.addEventListener('touchmove', (e) => {
        // Only prevent if touching the overlay itself, not modal content
        if (e.target === cartModal) {
          e.preventDefault();
        }
      }, { passive: false });

      cartModal.addEventListener('touchend', (e) => {
        if (e.target === cartModal && cartModalMouseDown) {
          closeCartModal();
        }
        cartModalMouseDown = false;
      }, { passive: true });

      // Reset flag when mouse leaves modal
      cartModal.addEventListener('mouseleave', () => {
        cartModalMouseDown = false;
      });
      
      // Track mousedown position for settings modal
      let settingsModalMouseDown = false;
      const settingsModal = document.getElementById('settings-modal');
      
      settingsModal.addEventListener('mousedown', (e) => {
        if (e.target === settingsModal) {
          settingsModalMouseDown = true;
        }
      });

      settingsModal.addEventListener('mouseup', (e) => {
        if (e.target === settingsModal && settingsModalMouseDown) {
          closeSettingsModal();
        }
        settingsModalMouseDown = false;
      });
      
      // Touch support for settings modal - prevent background scrolling
      settingsModal.addEventListener('touchstart', (e) => {
        if (e.target === settingsModal) {
          settingsModalMouseDown = true;
        }
      }, { passive: true });

      settingsModal.addEventListener('touchmove', (e) => {
        // Only prevent if touching the overlay itself, not modal content
        if (e.target === settingsModal) {
          e.preventDefault();
        }
      }, { passive: false });

      settingsModal.addEventListener('touchend', (e) => {
        if (e.target === settingsModal && settingsModalMouseDown) {
          closeSettingsModal();
        }
        settingsModalMouseDown = false;
      }, { passive: true });

      // Reset flag when mouse leaves modal
      settingsModal.addEventListener('mouseleave', () => {
        settingsModalMouseDown = false;
      });
    });

    // Helper function to update product image based on tier variants
    function updateProductImage(productCard, product, tierVariants, skipTransition = false) {
      const imageElement = productCard.querySelector('.product-image');
      if (!imageElement || !product.images || product.images.length === 0) return;

      // Get variant IDs for this tier
      const tierVariantIds = new Set(tierVariants.map(v => v.id));
      
      // Find suitable image that matches any variant in this tier, skipping logo
      const tierImage = findSuitableImage(product.images, tierVariantIds);
      
      // Update image
      if (tierImage && tierImage.src !== imageElement.src) {
        if (skipTransition) {
          // Immediate update without transition (for initial load)
          imageElement.src = tierImage.src;
        } else {
          // Smooth transition for user interactions
          imageElement.style.opacity = '0.5';
          imageElement.style.transition = 'opacity 0.2s ease';
          
          setTimeout(() => {
            imageElement.src = tierImage.src;
            imageElement.style.opacity = '1';
          }, 200);
        }
      }
    }

    // Update createPriceContainer to add "Add to Cart" buttons with tabs
    function createPriceContainer(product, variants, strainFilter, weightFilter, stockFilter, productCard) {
      const container = document.createElement('div');
      container.className = 'price-container';

      // Group variants by tier
      const variantsByTier = {};
      TIERS.forEach(tier => {
        variantsByTier[tier] = [];
      });

      variants.forEach(variant => {
        if (variant.correctedTier && variant.correctedWeight) {
          variantsByTier[variant.correctedTier].push(variant);
        }
      });

      // Filter tiers based on filters
      const availableTiers = TIERS.filter(tier => {
        if (strainFilter !== 'all' && tier !== strainFilter) {
          return false;
        }

        const tierVariants = variantsByTier[tier];
        if (!tierVariants || tierVariants.length === 0) {
          return false;
        }

        const filteredVariants = tierVariants.filter(variant => {
          if (weightFilter !== 'all' && variant.correctedWeight !== weightFilter) {
            return false;
          }
          if (!stockFilter && !variant.available) {
            return false;
          }
          return true;
        });

        return filteredVariants.length > 0;
      });

      // If multiple tiers, create tabs
      if (availableTiers.length > 1) {
        const tabsContainer = document.createElement('div');
        tabsContainer.className = 'variant-tabs-container';

        const tabs = document.createElement('div');
        tabs.className = 'variant-tabs';

        // Create tab buttons
        availableTiers.forEach((tier, index) => {
          const tab = document.createElement('button');
          tab.className = `variant-tab tab-${tier.toLowerCase()}`;
          if (index === 0) tab.classList.add('active');
          tab.dataset.tier = tier;

          // Add icon based on tier
          const icon = document.createElement('span');
          icon.className = 'variant-tab-icon';
          if (tier === 'Essential') {
            icon.innerHTML = '<svg width="18" height="18" viewBox="-351 153 256 256" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M-177.7,334.5c6.3-2.3,12.6-5.2,19.8-8.6c31.9-16.4,51.7-41.7,51.7-41.7s-32.5,0.6-64.4,17c-4,1.7-7.5,4-10.9,5.7c5.7-7.5,12.1-16.4,18.7-25c25-37.1,31.3-77.3,31.3-77.3s-34.8,21-59.2,58.6c-5.2,7.5-9.8,14.9-13.8,22.7c1.1-10.3,1.1-22.1,1.1-33.6c0-50-19.8-91.1-19.8-91.1s-19.8,40.5-19.8,91.1c0,12.1,0.6,23.3,1.1,33.6c-4-7.5-8.6-14.9-13.8-22.7c-25-37.1-59.2-58.6-59.2-58.6s6.3,40,31.3,77.3c6.3,9.2,12.1,17.5,18.7,25c-3.4-2.3-7.5-4-10.9-5.7c-31.9-16.4-64.4-17-64.4-17s19.8,25.6,51.7,41.7c6.9,3.4,13.2,6.3,19.8,8.6c-4,0.6-8,1.1-12.1,2.3c-30.5,6.4-53.2,23.9-53.2,23.9s27.3,7.5,58.6,1.1c9.8-2.3,19.8-4.6,27.3-7.5c-1.1,1.1,15.8-8.6,21.6-14.4v60.4h8.6v-61.8c6.3,6.3,22.7,16.4,22.1,14.9c8,2.9,17.5,5.2,27.3,7.5c30.8,6.3,58.6-1.1,58.6-1.1s-22.1-17.5-53.4-23.8C-169.6,335.7-173.7,335.1-177.7,334.5z" fill="currentColor"/></svg>';
          } else if (tier === 'Preferred') {
            icon.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.15316 5.40838C10.4198 3.13613 11.0531 2 12 2C12.9469 2 13.5802 3.13612 14.8468 5.40837L15.1745 5.99623C15.5345 6.64193 15.7144 6.96479 15.9951 7.17781C16.2757 7.39083 16.6251 7.4699 17.3241 7.62805L17.9605 7.77203C20.4201 8.32856 21.65 8.60682 21.9426 9.54773C22.2352 10.4886 21.3968 11.4691 19.7199 13.4299L19.2861 13.9372C18.8096 14.4944 18.5713 14.773 18.4641 15.1177C18.357 15.4624 18.393 15.8341 18.465 16.5776L18.5306 17.2544C18.7841 19.8706 18.9109 21.1787 18.1449 21.7602C17.3788 22.3417 16.2273 21.8115 13.9243 20.7512L13.3285 20.4768C12.6741 20.1755 12.3469 20.0248 12 20.0248C11.6531 20.0248 11.3259 20.1755 10.6715 20.4768L10.0757 20.7512C7.77268 21.8115 6.62118 22.3417 5.85515 21.7602C5.08912 21.1787 5.21588 19.8706 5.4694 17.2544L5.53498 16.5776C5.60703 15.8341 5.64305 15.4624 5.53586 15.1177C5.42868 14.773 5.19043 14.4944 4.71392 13.9372L4.2801 13.4299C2.60325 11.4691 1.76482 10.4886 2.05742 9.54773C2.35002 8.60682 3.57986 8.32856 6.03954 7.77203L6.67589 7.62805C7.37485 7.4699 7.72433 7.39083 8.00494 7.17781C8.28555 6.96479 8.46553 6.64194 8.82547 5.99623L9.15316 5.40838Z" fill="currentColor"/></svg>';
          } else if (tier === 'Supreme') {
            icon.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21.609 13.5616L21.8382 11.1263C22.0182 9.2137 22.1082 8.25739 21.781 7.86207C21.604 7.64823 21.3633 7.5172 21.106 7.4946C20.6303 7.45282 20.0329 8.1329 18.8381 9.49307C18.2202 10.1965 17.9113 10.5482 17.5666 10.6027C17.3757 10.6328 17.1811 10.6018 17.0047 10.5131C16.6865 10.3529 16.4743 9.91812 16.0499 9.04851L13.8131 4.46485C13.0112 2.82162 12.6102 2 12 2C11.3898 2 10.9888 2.82162 10.1869 4.46486L7.95007 9.04852C7.5257 9.91812 7.31351 10.3529 6.99526 10.5131C6.81892 10.6018 6.62434 10.6328 6.43337 10.6027C6.08872 10.5482 5.77977 10.1965 5.16187 9.49307C3.96708 8.1329 3.36968 7.45282 2.89399 7.4946C2.63666 7.5172 2.39598 7.64823 2.21899 7.86207C1.8918 8.25739 1.9818 9.2137 2.16181 11.1263L2.391 13.5616C2.76865 17.5742 2.95748 19.5805 4.14009 20.7902C5.32271 22 7.09517 22 10.6401 22H13.3599C16.9048 22 18.6773 22 19.8599 20.7902C21.0425 19.5805 21.2313 17.5742 21.609 13.5616Z" fill="currentColor"/></svg>';
          }
          tab.appendChild(icon);

          const text = document.createElement('span');
          text.textContent = tier;
          tab.appendChild(text);

          tab.addEventListener('click', (e) => {
            e.stopPropagation();
            // Remove active class from all tabs and sections
            tabs.querySelectorAll('.variant-tab').forEach(t => t.classList.remove('active'));
            container.querySelectorAll('.variant-section').forEach(s => s.classList.remove('active'));
            
            // Add active class to clicked tab and corresponding section
            tab.classList.add('active');
            const section = container.querySelector(`.variant-section-${tier.toLowerCase()}`);
            if (section) section.classList.add('active');
            
            // Update product image for this tier
            if (productCard) {
              updateProductImage(productCard, product, variantsByTier[tier]);
            }
          });

          tabs.appendChild(tab);
        });

        tabsContainer.appendChild(tabs);
        container.appendChild(tabsContainer);
      }

      // Create sections for each tier
      availableTiers.forEach((tier, index) => {
        const tierVariants = variantsByTier[tier];
        const filteredVariants = tierVariants.filter(variant => {
          if (weightFilter !== 'all' && variant.correctedWeight !== weightFilter) {
            return false;
          }
          if (!stockFilter && !variant.available) {
            return false;
          }
          return true;
        });

        const section = document.createElement('div');
        section.className = `variant-section variant-section-${tier.toLowerCase()}`;
        
        // Only show first section by default if there are tabs
        if (availableTiers.length > 1) {
          if (index === 0) section.classList.add('active');
        } else {
          section.classList.add('active');
        }

        // Check if any variant in this tier is on sale and add ribbon
        const hasAnySale = filteredVariants.some(v => v.isOnSale);
        if (hasAnySale) {
          const saleRibbon = document.createElement('div');
          saleRibbon.className = 'sale-ribbon';
          saleRibbon.textContent = 'SALE';
          section.appendChild(saleRibbon);
        }

        const title = document.createElement('div');
        title.className = `variant-title variant-title-${tier.toLowerCase()}`;
        title.textContent = tier;
        section.appendChild(title);

        const weights = document.createElement('div');
        weights.className = 'variant-weights';

        filteredVariants.forEach(variant => {
          const row = document.createElement('div');
          row.className = variant.available ? 'weight-row in-stock' : 'weight-row out-of-stock';
          
          // Add click handler to stop event propagation
          row.addEventListener('click', (e) => {
            e.stopPropagation();
          });

          const infoRow = document.createElement('div');
          infoRow.className = 'weight-info-row';

          const info = document.createElement('div');
          info.className = 'weight-info';

          const label = document.createElement('span');
          label.className = 'weight-label';
          label.textContent = variant.correctedWeight;

          const priceWrapper = document.createElement('div');
          priceWrapper.className = 'price-wrapper';

          const priceContainer = document.createElement('div');
          priceContainer.className = 'price-display';

          // Show original price if on sale
          if (variant.isOnSale && variant.compareAtPrice) {
            const originalPrice = document.createElement('span');
            originalPrice.className = 'original-price';
            originalPrice.textContent = `$${variant.compareAtPrice}`;
            priceContainer.appendChild(originalPrice);
          }

          const price = document.createElement('span');
          price.className = variant.isOnSale ? 'weight-price sale-price' : 'weight-price';
          price.textContent = `$${variant.price}`;
          priceContainer.appendChild(price);

          priceWrapper.appendChild(priceContainer);

          info.appendChild(label);
          info.appendChild(priceWrapper);
          infoRow.appendChild(info);

          const stockBadge = document.createElement('span');
          stockBadge.className = `stock-badge ${variant.available ? 'in-stock-badge' : 'out-of-stock-badge'}`;
          stockBadge.textContent = variant.available ? 'In Stock' : 'Out of Stock';

          row.appendChild(infoRow);
          row.appendChild(stockBadge);

          if (variant.available) {
            const addButton = document.createElement('button');
            addButton.className = 'add-to-cart-button';
            addButton.textContent = 'Add to Cart';
            addButton.onclick = (e) => {
              e.stopPropagation();
              virtualCart.addItem(product, variant, e.currentTarget);
            };
            row.appendChild(addButton);
          }

          weights.appendChild(row);
        });

        section.appendChild(weights);
        container.appendChild(section);
      });

      return container;
    }
  </script>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settings-modal">
    <div class="modal settings-modal">
      <div class="modal-header">
        <h2 class="modal-title">Settings</h2>
        <button class="close-modal">&times;</button>
      </div>
      
      <!-- Settings Tabs -->
      <div class="settings-tabs">
        <button class="settings-tab active" data-tab="general">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M12 1v6m0 6v6"></path>
            <path d="M17 12h6M1 12h6"></path>
            <path d="m16.24 7.76 4.24-4.24M3.52 20.48l4.24-4.24"></path>
            <path d="m16.24 16.24 4.24 4.24M3.52 3.52l4.24 4.24"></path>
          </svg>
          <span>General</span>
        </button>
        <button class="settings-tab" data-tab="notifications">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
            <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
          </svg>
          <span>Notifications</span>
        </button>
        <button class="settings-tab" data-tab="filters">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
          </svg>
          <span>Filters</span>
        </button>
        <button class="settings-tab" data-tab="products">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
          </svg>
          <span>Products</span>
        </button>
      </div>

      <div class="modal-content">
        <!-- General Tab -->
        <div class="settings-tab-content active" data-content="general">
          <div class="settings-section">
            <h3>Update Frequency</h3>
            <div class="settings-input-group">
              <input type="number" id="check-interval" class="settings-input" min="1" value="5" placeholder="5">
              <span class="settings-input-suffix">minutes</span>
            </div>
            <small class="settings-help-text">How often to check for product updates</small>
          </div>
          
          <div class="settings-section">
            <h3>Product Interaction</h3>
            <div class="settings-toggle-group">
              <div class="settings-toggle">
                <input type="checkbox" id="enable-product-links" class="toggle-input" checked>
                <label for="enable-product-links" class="toggle-label">
                  <div class="toggle-content">
                    <div class="toggle-title">Enable Product Links</div>
                    <div class="toggle-description">Click on products to open the product page</div>
                  </div>
                  <div class="toggle-switch"></div>
                </label>
              </div>
            </div>
            <small class="settings-help-text">When disabled, you can only view images without opening product pages</small>
          </div>
          
          <div class="settings-section">
            <h3>App Management</h3>
            <button id="force-refresh-btn" onclick="forceRefresh()" class="settings-button secondary">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
              </svg>
              Force Refresh App
            </button>
            <small class="settings-help-text">Clear cache and reload the latest version</small>
          </div>
        </div>

        <!-- Notifications Tab -->
        <div class="settings-tab-content" data-content="notifications">
          <div class="settings-section">
            <h3>Notification Types</h3>
            
            <div class="settings-toggle-group">
              <div class="settings-toggle">
                <input type="checkbox" id="ntfy-enabled" class="toggle-input">
                <label for="ntfy-enabled" class="toggle-label">
                  <div class="toggle-content">
                    <div class="toggle-title">App Notifications</div>
                    <div class="toggle-description">Receive notifications via Ntfy app</div>
                  </div>
                  <div class="toggle-switch"></div>
                </label>
              </div>

              <div class="settings-toggle">
                <input type="checkbox" id="email-enabled" class="toggle-input">
                <label for="email-enabled" class="toggle-label">
                  <div class="toggle-content">
                    <div class="toggle-title">Email Notifications</div>
                    <div class="toggle-description">Receive notifications via email</div>
                  </div>
                  <div class="toggle-switch"></div>
                </label>
              </div>
            </div>
          </div>

          <div class="settings-section">
            <h3>Notification Configuration</h3>
            
            <div class="settings-field">
              <label for="ntfy-topic" class="settings-label">Ntfy Topic</label>
              <div class="settings-input-with-button">
                <input type="text" id="ntfy-topic" class="settings-input" placeholder="Enter your unique topic name">
                <button onclick="generateRandomTopic()" class="settings-button-inline">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"></path>
                  </svg>
                  Generate
                </button>
              </div>
              <small class="settings-help-text">Your private notification channel (required for app notifications)</small>
            </div>

            <div class="settings-field">
              <label for="ntfy-email" class="settings-label">Email Address</label>
              <input type="email" id="ntfy-email" class="settings-input" placeholder="your@email.com">
              <small class="settings-help-text">Required for email notifications</small>
            </div>

            <div class="settings-field">
              <label for="ntfy-server" class="settings-label">Ntfy Server (Optional)</label>
              <input type="text" id="ntfy-server" class="settings-input" placeholder="https://ntfy.sh">
              <small class="settings-help-text">Leave as default unless using a self-hosted server</small>
            </div>

            <button id="test-ntfy" onclick="testNtfyNotification()" class="settings-button primary">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
              </svg>
              Test Notifications
            </button>
          </div>

          <div class="settings-info-box">
            <div class="info-box-title">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="16" x2="12" y2="12"></line>
                <line x1="12" y1="8" x2="12.01" y2="8"></line>
              </svg>
              Setup Instructions
            </div>
            <ol class="info-box-list">
              <li>Download Ntfy for <a href="https://apps.apple.com/us/app/ntfy/id1625396347" target="_blank">iOS</a> or <a href="https://play.google.com/store/apps/details?id=io.heckel.ntfy" target="_blank">Android</a></li>
              <li>Open the app and tap "Add subscription"</li>
              <li>Enter your topic name exactly as above</li>
              <li>Save and wait for notifications!</li>
            </ol>
          </div>
        </div>

        <!-- Filters Tab -->
        <div class="settings-tab-content" data-content="filters">
          <div class="settings-section">
            <h3>Product Filters</h3>
            
            <div class="settings-field">
              <label class="settings-label">Tiers</label>
              <div class="filter-chips" id="tier-chips-new">
                <label class="filter-chip">
                  <input type="checkbox" value="all" data-group="tier">
                  <span>All Tiers</span>
                </label>
                <label class="filter-chip">
                  <input type="checkbox" value="Essential" data-group="tier">
                  <span>Essential</span>
                </label>
                <label class="filter-chip">
                  <input type="checkbox" value="Preferred" data-group="tier">
                  <span>Preferred</span>
                </label>
                <label class="filter-chip">
                  <input type="checkbox" value="Supreme" data-group="tier">
                  <span>Supreme</span>
                </label>
              </div>
            </div>

            <div class="settings-field">
              <label class="settings-label">Weights</label>
              <div class="filter-chips" id="weight-chips-new">
                <label class="filter-chip">
                  <input type="checkbox" value="all" data-group="weight">
                  <span>All Weights</span>
                </label>
                <label class="filter-chip">
                  <input type="checkbox" value="28g" data-group="weight">
                  <span>28g</span>
                </label>
                <label class="filter-chip">
                  <input type="checkbox" value="3.5g" data-group="weight">
                  <span>3.5g</span>
                </label>
              </div>
            </div>

            <!-- Keep old selects hidden for compatibility -->
            <select id="notification-tier" class="settings-select" multiple size="4" style="display: none;">
              <option value="all">All Tiers</option>
              <option value="Essential">Essential</option>
              <option value="Preferred">Preferred</option>
              <option value="Supreme">Supreme</option>
            </select>
            <select id="notification-weight" class="settings-select" multiple size="3" style="display: none;">
              <option value="all">All Weights</option>
              <option value="28g">28g</option>
              <option value="3.5g">3.5g</option>
            </select>
          </div>

          <div class="settings-section">
            <h3>Notification Events</h3>
            <div class="settings-toggle-group">
              <div class="settings-toggle">
                <input type="checkbox" id="notify-new" class="toggle-input" checked>
                <label for="notify-new" class="toggle-label">
                  <div class="toggle-content">
                    <div class="toggle-title">New Products</div>
                    <div class="toggle-description">Get notified when new products are added</div>
                  </div>
                  <div class="toggle-switch"></div>
                </label>
              </div>

              <div class="settings-toggle">
                <input type="checkbox" id="notify-stock" class="toggle-input" checked>
                <label for="notify-stock" class="toggle-label">
                  <div class="toggle-content">
                    <div class="toggle-title">Stock Changes</div>
                    <div class="toggle-description">Get notified when items come back in stock</div>
                  </div>
                  <div class="toggle-switch"></div>
                </label>
              </div>

              <div class="settings-toggle">
                <input type="checkbox" id="notify-removed" class="toggle-input" checked>
                <label for="notify-removed" class="toggle-label">
                  <div class="toggle-content">
                    <div class="toggle-title">Removed Products</div>
                    <div class="toggle-description">Get notified when products are removed</div>
                  </div>
                  <div class="toggle-switch"></div>
                </label>
              </div>
            </div>
          </div>
        </div>

        <!-- Products Tab -->
        <div class="settings-tab-content" data-content="products">
          <div class="settings-section">
            <h3>Specific Products</h3>
            <div class="settings-products-header">
              <span id="products-selected-count" class="products-count">0 products selected</span>
              <button id="deselect-all-products" onclick="deselectAllProducts()" class="settings-button-text">
                Deselect All
              </button>
            </div>
            <div class="product-search">
              <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
              </svg>
              <input type="text" id="product-search" class="settings-input" placeholder="Search products...">
            </div>
            <div class="product-select-container" id="product-select">
              <!-- Product checkboxes will be dynamically added here -->
            </div>
          </div>
        </div>
      </div>

      <div class="modal-footer">
        <button class="save-settings">Save Settings</button>
      </div>
    </div>
  </div>

  <!-- Cart Modal -->
  <div id="cart-modal" class="cart-modal">
    <div class="cart-modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Shopping Cart</h2>
        <button class="close-modal" onclick="closeCartModal()">&times;</button>
      </div>
      <div class="modal-content" id="cart-items">
        <!-- Cart items will be dynamically inserted here -->
      </div>
      <div class="modal-footer">
        <div class="cart-total">
          Total: $<span id="cart-total">0.00</span>
        </div>
        <button id="checkout-button" class="checkout-button" onclick="checkout()">
          Proceed to Checkout
        </button>
      </div>
    </div>
  </div>
</body>
</html>