<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>LitFarms Product List</title>
  <!-- Replace favicon with inline SVG -->
  <link rel="icon" href="data:image/svg+xml,<?xml version='1.0' encoding='UTF-8' standalone='no'?><svg width='4.6079073in' height='2.5213542in' viewBox='0 0 117.04084 64.042396' version='1.1' id='svg1' xml:space='preserve' xmlns='http://www.w3.org/2000/svg'><defs id='defs1'/><g id='layer1' transform='translate(-46.479583,-116.4788)'><rect style='display:inline;opacity:1;fill:none;fill-opacity:1;stroke:%23ffffff;stroke-width:6;stroke-dasharray:none;stroke-opacity:1' id='rect2' width='111.04084' height='58.0424' x='49.47958' y='119.4788'/><g id='g6' style='opacity:1;fill:%23ffffff;fill-opacity:1' transform='matrix(1,0,0,1.0224587,0.56861157,30.651474)'><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:6.57396;stroke-dasharray:none;stroke-opacity:1' id='rect5' width='25.801872' height='5.860003' x='119.94384' y='98.674728' ry='0'/><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:6.03661;stroke-dasharray:none;stroke-opacity:1' id='rect6' width='6' height='30.334635' x='130.05539' y='101.46412'/></g><path style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:5.81338;stroke-dasharray:none;stroke-opacity:1' d='m 100.03961,131.46649 h 6 v 33.97218 h -6 z' id='path4'/><g id='g9' transform='matrix(1,0,0,1.0199169,-0.14807164,31.087934)'><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:5.43999;stroke-dasharray:none;stroke-opacity:1' id='rect8' width='6' height='33.229393' x='64.364632' y='98.429321'/><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:5.84555;stroke-dasharray:none;stroke-opacity:1' id='rect9' width='21.184687' height='5.8828321' x='64.373192' y='125.75582'/></g></g></svg>">
  <link rel="stylesheet" href="style.css">
  <style>
  
  </style>
  <div class="countdown-container">
    <div class="countdown-tooltip">Next check in: <span class="tooltip-time">5:00</span></div>
    <div class="countdown-circle">
      <svg viewBox="0 0 36 36">
        <circle class="progress-bg" r="16" cx="18" cy="18"></circle>
        <circle class="progress" r="16" cx="18" cy="18" stroke-dasharray="100.53" stroke-dashoffset="0"></circle>
      </svg>
      <div class="countdown-time">5:00</div>
    </div>
  </div>
</head>
<body>
  <div id="site-status" class="site-status">
    <span id="status-message"></span>
    <button id="retry-button" class="retry-button" style="display: none;">Retry Now</button>
  </div>
  <div class="header">
    <a href="https://www.litfarms.com" class="header-link">
      <svg width="75" height="75" viewBox="0 0 117.04084 64.042396" version="1.1" id="svg1" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
        <defs id="defs1"></defs>
        <g id="layer1" transform="translate(-46.479583,-116.4788)">
          <rect style="display:inline;opacity:1;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:6;stroke-dasharray:none;stroke-opacity:1" id="rect2" width="111.04084" height="58.0424" x="49.47958" y="119.4788"></rect>
          <g id="g6" style="opacity:1;fill:#ffffff;fill-opacity:1" transform="matrix(1,0,0,1.0224587,0.56861157,30.651474)">
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:6.57396;stroke-dasharray:none;stroke-opacity:1" id="rect5" width="25.801872" height="5.860003" x="119.94384" y="98.674728" ry="0"></rect>
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:6.03661;stroke-dasharray:none;stroke-opacity:1" id="rect6" width="6" height="30.334635" x="130.05539" y="101.46412"></rect>
          </g>
          <path style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:5.81338;stroke-dasharray:none;stroke-opacity:1" d="m 100.03961,131.46649 h 6 v 33.97218 h -6 z" id="path4"></path>
          <g id="g9" transform="matrix(1,0,0,1.0199169,-0.14807164,31.087934)">
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:5.43999;stroke-dasharray:none;stroke-opacity:1" id="rect8" width="6" height="33.229393" x="64.364632" y="98.429321"></rect>
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:5.84555;stroke-dasharray:none;stroke-opacity:1" id="rect9" width="21.184687" height="5.8828321" x="64.373192" y="125.75582"></rect>
          </g>
        </g>
      </svg>
    </a>
    <a href="https://www.litfarms.com" class="header-link">
      <h1>Farms Products</h1>
    </a>
  </div>
  <div class="filters-container">
    <button id="filters-toggle" class="filters-toggle" aria-label="Toggle filters">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
      </svg>
      <span class="filters-toggle-text">Filters</span>
      <svg class="filters-toggle-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="6 9 12 15 18 9"></polyline>
      </svg>
    </button>
    <div class="filters" id="filters">
      <div class="search-container">
        <input type="text" id="product-search-filter" class="search-input" placeholder="Search products...">
        <button id="clear-search" class="clear-search">&times;</button>
      </div>
      <select id="strain-filter">
        <option value="all">All Tiers</option>
        <option value="Essential">Essential</option>
        <option value="Preferred">Preferred</option>
        <option value="Supreme">Supreme</option>
      </select>
      <select id="strain-type-filter">
        <option value="all">All Types</option>
        <option value="sativa">Sativa</option>
        <option value="indica">Indica</option>
        <option value="hybrid">Hybrid</option>
        <option value="unknown">Unknown</option>
      </select>
      <select id="weight-filter">
        <option value="all">All Weights</option>
        <option value="28g">28g</option>
        <option value="28g (Smalls)">28g (Smalls)</option>
        <option value="3.5g">3.5g</option>
      </select>
      <select id="sort-filter">
        <option value="alpha-asc">A-Z</option>
        <option value="alpha-desc">Z-A</option>
        <option value="price-asc">Price: Low to High</option>
        <option value="price-desc">Price: High to Low</option>
        <option value="date-desc">Newest First</option>
        <option value="date-asc">Oldest First</option>
      </select>
      <button id="stock-filter" class="stock-filter-btn active">Show All</button>
    </div>
    <div id="product-count" style="text-align: center; margin: 8px 0; color: var(--text-secondary);text-shadow: 0 2px 5px rgb(0 0 0 / 50%);">
      Showing 0 products
    </div>
  </div>
  <div class="product-grid" id="product-grid">
    <!-- Product cards will be dynamically inserted here -->
  </div>

  <div id="loader" class="loader-container" style="display: none;">
    <span class="loader"></span>
    <div class="loader-text">Loading products...</div>
  </div>

  <!-- Lightbox for images -->
  <div id="image-lightbox" class="lightbox" style="display: none;">
    <span class="lightbox-close">&times;</span>
    <img class="lightbox-content" id="lightbox-img">
    <div class="lightbox-caption" id="lightbox-caption"></div>
  </div>

  <script>
    // Define the URL for the products.json endpoint
    const shopifyStoreUrl = 'https://litfarms.com/products.json';
    
    // Ntfy configuration
    const NTFY_CONFIG = {
      appEnabled: false, // App notifications enabled
      emailEnabled: false, // Email notifications enabled
      topic: '', // Will be set in settings
      server: 'https://ntfy.sh', // Default server, can be changed in settings
      email: '' // Email for notifications
    };

    // Declare updateCheckerId at the top level
    let updateCheckerId = null;

    // Hardcoded referral parameters
    const REFERRAL_PARAMS = {
      sca_ref: '9871506.3QN5sUKgOM',
      sca_crp: 'MjMzMjUw'
    };

    // Settings Management
    const DEFAULT_SETTINGS = {
      checkInterval: 5, // minutes
      notificationTiers: ['all'],
      notificationWeights: ['all'],
      notifyNew: true,
      notifyStock: true,
      notifyRemoved: true,
      specificProducts: [], // Array of product handles
      ntfyAppEnabled: false,
      ntfyEmailEnabled: false,
      ntfyTopic: '',
      ntfyServer: 'https://ntfy.sh',
      ntfyEmail: ''
    };

    let currentSettings = { ...DEFAULT_SETTINGS };

    function loadSettings() {
      const savedSettings = localStorage.getItem('litFarmsNotificationSettings');
      if (savedSettings) {
        currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(savedSettings) };
      }
      // Update Ntfy config
      NTFY_CONFIG.appEnabled = currentSettings.ntfyAppEnabled;
      NTFY_CONFIG.emailEnabled = currentSettings.ntfyEmailEnabled;
      NTFY_CONFIG.topic = currentSettings.ntfyTopic;
      NTFY_CONFIG.server = currentSettings.ntfyServer;
      NTFY_CONFIG.email = currentSettings.ntfyEmail;
      return currentSettings;
    }

    // Update saveSettings function to properly handle timer reset
    function saveSettings(settings) {
      const oldInterval = currentSettings.checkInterval;
      const newInterval = settings.checkInterval;
      
      localStorage.setItem('litFarmsNotificationSettings', JSON.stringify(settings));
      currentSettings = settings;
      
      // Only restart timers if the interval changed
      if (oldInterval !== newInterval) {
        // Clear existing intervals
        if (updateCheckerId) {
          clearInterval(updateCheckerId);
          updateCheckerId = null;
        }
        
        // Clear all existing cleanup handlers
        pageCleanupHandlers.forEach(handler => {
          try {
            handler();
          } catch (error) {
            console.warn('Cleanup handler error:', error);
          }
        });
        pageCleanupHandlers = [];
        
        // Start new product checker and countdown
        startProductUpdateChecker();
      }
    }

    // Strain data
    const MANUAL_STRAIN_DATA = {
  "zereal": {
    "description": "Zerealz is a slightly indica dominant hybrid strain (60% indica/40% sativa) created through crossing the powerful Zkittlez X Cereal Milk strains. Looking for an insanely delicious flavor and a super euphoric yet relaxing high? Zerealz is definitely made for you. This bud packs a sweet and creamy fruity berry flavor into each and every toke, sharpened slightly by a sour citrus exhale. The aroma is earthy and herbal at the onset before settling into a sweet and fruity effect as the nugs are broken apart and burned away.",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738172569453
  },
  "white linen": {
    "description": "White Linen is an indica dominant hybrid strain (70% indica/30% sativa) created through crossing the delicious Wedding Cake #13 X Melonade strains. Named for its gorgeous appearance and soft, soothing high, White Linen is the perfect choice for any lover of classic flavorful indicas. This bud has beautiful fat heart-shaped bright neon green nugs with minty green undertones, lots of thin yellow-orange hairs and a frosty thick coating of slightly golden-white crystal trichomes.",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738172600552
  },
  "lit og": {
    "description": "LIT OG: Where Tahoe OG meets Runtz in a legendary clash of titans. This unforgettable strain packs a powerful punch, leaving you feeling euphoric and blissful. But LIT OG isn't just about brute force. Its flavor profile is a delightful surprise, exploding with gassy OG terps that linger on the palate. It's the perfect choice for experienced users seeking a potent and flavorful experience that lives up to its name.",
    "category": "sativa",
    "phenotype": "sativa",
    "lastUpdate": 1738172799107
  },
  "lemon cherry belts": {
    "description": "Delivers a vibrant blend of sweet lemon zest and ripe cherries, with a smooth, creamy finish.",
    "category": "hybrid",
    "phenotype": "hybrid",
    "lastUpdate": 1738179317058
  },
  "glitter bomb": {
    "description": "Glitter Bomb THCa Flower will enchant you with its dazzling trichomes and hypnotic purple buds! It is a 70/30 indica dominant hybrid type 1 hemp flower that was indoor grown with living soil. This genetic gem of a strain is from crossing Grape Gas with OG Kush Breath Blueberry Headband, and exhibits notes of sweet, gas, and berries! This strain will have you dimension hopping with euphoria, transcendental thinking, and powerful relaxation!",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738179386321
  },
  "apple banana zoap": {
    "description": "Apple Banana Zoap from LIT Farms is a cannabis strain that combines the flavors of apples, bananas, and zoap. The strain''s unique flavor profile blends sweet, creamy notes of apples and bananas with earthy, floral undertones of zoap, creating a rich and aromatic experience. This combination makes Apple Banana highly appealing to cannabis users. This strain offers a balanced high, combining relaxation and a gentle cerebral stimulation, making it suitable for both recreational and medicinal use. The potent levels of THC in Apple Banana provide a strong and long-lasting effect, helping to relieve stress, anxiety, and chronic pain.",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738179467896
  },
  "bubblegum runtz": {
    "description": "Bubble Runtz, also known as Bubblegum Runtz and Bubble Gum Runtz,, is a hybrid weed strain made by crossing Runtz and Bubble Gum. ",
    "category": "hybrid",
    "phenotype": "hybrid",
    "lastUpdate": 1738172799107
  }
};

    // Simplify loadStrainData to just use the constant
    async function loadStrainData() {
      try {
        //console.log('Loading strain data...');
        strainData = MANUAL_STRAIN_DATA;
        //console.log('Loaded strain data:', strainData);
        return strainData;
      } catch (error) {
        console.error('Error in loadStrainData:', error);
        return {};
      }
    }

    // Update getStrainType to use the new strain data
    function getStrainType(description, productHandle, productTitle) {
      //console.log(`Getting strain type for ${productTitle}`);
      
      // Clean the title first since we need it for both checks
      const cleanTitle = productTitle
        .replace(/\s*-?\s*THCA\s+Flower\s*$/i, '')
        .replace(/\s*-?\s*Flower\s*$/i, '')
        .replace(/\s*-?\s*\d+\.?\d*g\s*$/i, '')
        .replace(/-/g, '')
        .trim()
        .toLowerCase();

      // First check if product description explicitly mentions strain type
      if (description) {
        const temp = document.createElement('div');
        temp.innerHTML = description;
        const plainText = temp.textContent.toLowerCase();
        
        if (plainText.includes('sativa')) return 'sativa';
        if (plainText.includes('indica')) return 'indica';
        if (plainText.includes('hybrid')) return 'hybrid';
      }

      // If no strain type in product description, use manual strain type
      let strainInfo = strainData[cleanTitle];
      
      // If not found, try removing trailing 's' if present
      if (!strainInfo && cleanTitle.endsWith('s')) {
        const singularForm = cleanTitle.slice(0, -1);
        strainInfo = strainData[singularForm];
      }

      // Return the manual strain type if available
      if (strainInfo?.category) {
        return strainInfo.category.toLowerCase();
      }
      
      return 'unknown';
    }

    // Function to show/hide loader
    function toggleLoader(show) {
      if (show) {
        domElements.loader.style.display = 'flex';
        domElements.productGrid.style.display = 'none';
      } else {
        domElements.loader.style.display = 'none';
        domElements.productGrid.style.display = 'grid';
      }
    }

    // Define global products variable
    let products = [];

    // Cache constants
    const CACHE_KEY = 'litFarmsProducts';
    const CACHE_TIMESTAMP_KEY = 'litFarmsLastUpdate';
    const CACHE_DURATION = 1 * 60 * 1000; // 1 minutes in milliseconds

    // Function to handle caching and fetching products
    async function getProducts(immediate = false) {
      const now = Date.now();
      const lastUpdate = localStorage.getItem(CACHE_TIMESTAMP_KEY);
      const cachedData = localStorage.getItem(CACHE_KEY);

      try {
        // Check for valid cached data
        if (cachedData && lastUpdate) {
          const parsedCache = JSON.parse(cachedData);
          const isValidCache = Array.isArray(parsedCache) && 
                              parsedCache.length > 0 && 
                              parsedCache[0].hasOwnProperty('title');

          if (isValidCache) {
            // Clear any stored error state since we have valid cache
            localStorage.removeItem('lastFetchError');
            
            // If this is an immediate request, return cached data regardless of age
            if (immediate) {
              return filterTHCAProducts(parsedCache);
            }
            
            // For background updates, check if cache is fresh enough
            if (now - parseInt(lastUpdate) < CACHE_DURATION) {
              return filterTHCAProducts(parsedCache);
            }
          }
        }

        // If we get here, we need fresh data
        console.log('Fetching fresh product data');
        const freshProducts = await fetchAllProducts();
        
        if (!Array.isArray(freshProducts) || freshProducts.length === 0) {
          throw new Error('Invalid or empty product data received');
        }

        // Clear any stored error state on successful fetch
        localStorage.removeItem('lastFetchError');

        const thcaProducts = filterTHCAProducts(freshProducts);
        
        if (thcaProducts.length > 0) {
          localStorage.setItem(CACHE_KEY, JSON.stringify(thcaProducts));
          localStorage.setItem(CACHE_TIMESTAMP_KEY, now.toString());
        }
        
        return thcaProducts;
      } catch (error) {
        console.error('Error in getProducts:', error);
        
        // Store the error state for maintenance mode detection
        if (error.message && error.message.includes('401')) {
          localStorage.setItem('lastFetchError', error.message);
        }
        
        // If this is an immediate request and we have any cached data, use it
        if (immediate && cachedData) {
          try {
            const parsedCache = JSON.parse(cachedData);
            if (Array.isArray(parsedCache) && parsedCache.length > 0) {
              return filterTHCAProducts(parsedCache);
            }
          } catch (e) {
            console.error('Failed to parse cached data:', e);
          }
        }
        
        throw error;
      }
    }

    // Update the fetchAllProducts function to include logging
    async function fetchAllProducts() {
      let allProducts = [];
      
      try {
        // Fetch first page
        const response = await fetch(`${shopifyStoreUrl}?page=1&limit=250`);
        const data = await response.json();
        
        if (data.products && data.products.length > 0) {
          allProducts = data.products;
          console.log(`Found ${data.products.length} products on page 1`);
          
          // Only continue fetching if we got the maximum number of products (250)
          if (data.products.length === 250) {
            let page = 2;
            let hasMore = true;
            
            while (hasMore) {
              try {
                const nextResponse = await fetch(`${shopifyStoreUrl}?page=${page}&limit=250`);
                const nextData = await nextResponse.json();
                
                if (nextData.products && nextData.products.length > 0) {
                  console.log(`Found ${nextData.products.length} products on page ${page}`);
                  allProducts = allProducts.concat(nextData.products);
                  page++;
                  
                  // If we got less than 250 products, we've reached the end
                  if (nextData.products.length < 250) {
                    hasMore = false;
                  }
                } else {
                  hasMore = false;
                }
              } catch (error) {
                console.error('Error fetching page', page, ':', error);
                hasMore = false;
              }
            }
          }
        }
      } catch (error) {
        console.error('Error fetching first page:', error);
      }

      console.log('Total products fetched:', allProducts.length);
      return allProducts;
    }

    function renderProducts(filteredProducts) {
      const productGrid = domElements.productGrid;
      domElements.productCount.textContent = `Showing ${filteredProducts.length} products`;

      // First, mark existing cards for fade out
      const existingCards = productGrid.querySelectorAll('.product-card');
      existingCards.forEach(card => card.classList.add('fade-out'));

      // Wait for fade out animation
      setTimeout(() => {
        // Clear the grid but maintain the few-items class if it should stay
        const shouldHaveFewItems = filteredProducts.length < 4;
        const hadFewItems = productGrid.classList.contains('few-items');
        
        // Only remove the few-items class if we're transitioning from few to many
        if (hadFewItems && !shouldHaveFewItems) {
          productGrid.classList.remove('few-items');
        }
        
        productGrid.innerHTML = '';

        if (!hadFewItems && shouldHaveFewItems) {
          productGrid.classList.add('few-items');
        }

        // Calculate initial load count
        const productWidth = 250;
        const gap = 20;
        const containerWidth = productGrid.offsetWidth;
        const productsPerRow = Math.floor(containerWidth / (productWidth + gap));
        const initialLoadCount = productsPerRow * 2;

        // Function to render a batch of products with staggered animation
        const renderBatch = (products, startIndex, endIndex) => {
          products.slice(startIndex, endIndex).forEach((product, index) => {
            const productCard = document.createElement('div');
            productCard.className = 'product-card';
            productCard.style.animationDelay = `${index * 50}ms`; // Stagger the animations
            
            // Get filtered variants based on current filters
            const processedVariants = utils.processVariants(product);
            let relevantVariants = processedVariants;
            
            if (domElements.strainFilter.value !== 'all') {
              relevantVariants = relevantVariants.filter(v => v.correctedTier === domElements.strainFilter.value);
            }
            if (domElements.weightFilter.value !== 'all') {
              relevantVariants = relevantVariants.filter(v => v.correctedWeight === domElements.weightFilter.value);
            }
            if (!domElements.stockFilter.classList.contains('active')) {
              relevantVariants = relevantVariants.filter(v => v.available);
            }

            productCard.addEventListener('click', (e) => {
              // Check if the click was on the COA button
              if (e.target.classList.contains('coa-button')) {
                return; // Do nothing, let the COA button handle the click
              }

              // Regular click behavior - go to product page
              let url = `https://litfarms.com/products/${product.handle}`;
              const params = new URLSearchParams();
              
              if (relevantVariants.length === 1) {
                params.append('variant', relevantVariants[0].id);
              }
              
              // Add referral parameters
              params.append('sca_ref', REFERRAL_PARAMS.sca_ref);
              params.append('sca_crp', REFERRAL_PARAMS.sca_crp);
              
              if (params.toString()) {
                url += `?${params.toString()}`;
              }
              
              window.open(url, '_blank');
            });

            // Strain type badge
            const strainType = getStrainType(product.body_html, product.handle, product.title);
            const strainTypeBadge = createStrainTypeBadge(strainType);
            productCard.appendChild(strainTypeBadge);
            productCard.style.position = 'relative';

            // Create and add product image
            const imageContainer = createProductImage(product, relevantVariants);
            productCard.appendChild(imageContainer);

            const productTitle = createProductTitle(product);
            productCard.appendChild(productTitle);

            const priceContainer = createPriceContainer(product, relevantVariants, domElements.strainFilter.value, domElements.weightFilter.value, domElements.stockFilter.classList.contains('active'));
            productCard.appendChild(priceContainer);

            const productDescription = createProductDescription(product);
            productCard.appendChild(productDescription);

            productGrid.appendChild(productCard);
          });
        };

        // Render first two rows immediately
        renderBatch(filteredProducts, 0, initialLoadCount);

        // Render the rest after a short delay
        if (filteredProducts.length > initialLoadCount) {
          setTimeout(() => {
            renderBatch(filteredProducts, initialLoadCount, filteredProducts.length);
          }, 300); // Wait for initial batch animations to complete
        }
      }, 200); // Match this with the fade-out transition duration
    }

    // Helper functions for rendering
    function createStrainTypeBadge(strainType) {
      const badge = document.createElement('div');
      badge.className = 'strain-type-badge';
      
      // Set badge color based on strain type
      switch(strainType) {
        case 'sativa':
          badge.style.backgroundColor = 'var(--strain-sativa)';
          badge.style.color = '#000';
          break;
        case 'indica':
          badge.style.backgroundColor = 'var(--strain-indica)';
          badge.style.color = '#fff';
          break;
        case 'hybrid':
          badge.style.backgroundColor = 'var(--strain-hybrid)';
          badge.style.color = '#fff';
          break;
        default:
          badge.style.backgroundColor = 'var(--strain-unknown)';
          badge.style.color = '#fff';
      }
      
      badge.textContent = strainType;
      return badge;
    }

    function createProductImage(product, relevantVariants) {
      const imageContainer = document.createElement('div');
      imageContainer.className = 'product-image-container';
      
      const imageWrapper = document.createElement('div');
      imageWrapper.className = 'image-wrapper';
      
      const image = document.createElement('img');
      image.className = 'product-image';
      image.alt = product.title;
      
      imageWrapper.appendChild(image);
      imageContainer.appendChild(imageWrapper);

      // Filter images based on variants
      let filteredImages = [];
      if (product.images && product.images.length > 0) {
        if (relevantVariants.length === product.variants.length) {
          // Show all images if all variants are selected
          filteredImages = [product.images[0]]; // Just use first image
        } else {
          // Get set of relevant variant IDs
          const relevantVariantIds = new Set(relevantVariants.map(v => v.id));
          
          // Try to find first image that matches a variant
          const variantImage = product.images.find(img => 
            img.variant_ids && 
            img.variant_ids.some(id => relevantVariantIds.has(id))
          );
          
          // Use variant image if found, otherwise use first product image
          filteredImages = [variantImage || product.images[0]];
        }
      }

      // Use placeholder if no images available
      if (filteredImages.length === 0) {
        filteredImages = [{ src: 'https://via.placeholder.com/300' }];
      }

      // Set the image source
      image.src = filteredImages[0].src;

      // Add click handler to open lightbox with original high-res image
      image.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent card click
        try {
          // Pass the original image source for highest quality
          const originalSrc = filteredImages[0].src;
          openLightbox(originalSrc, product.title);
        } catch (error) {
          console.error('Error opening lightbox:', error);
        }
      });

      // Add visual indicator that image is clickable
      image.style.cursor = 'zoom-in';

      return imageContainer;
    }

    function createProductTitle(product) {
      const title = document.createElement('h2');
      title.className = 'product-title';
      title.textContent = product.title;
      return title;
    }

    function createPriceContainer(product, variants, strainFilter, weightFilter, stockFilter) {
      const container = document.createElement('div');
      container.className = 'price-container';

      // Group variants by tier
      const variantsByTier = {};
      TIERS.forEach(tier => {
        variantsByTier[tier] = [];
      });

      variants.forEach(variant => {
        if (variant.correctedTier && variant.correctedWeight) {
          variantsByTier[variant.correctedTier].push(variant);
        }
      });

      // Create sections for each tier
      TIERS.forEach(tier => {
        if (strainFilter !== 'all' && tier !== strainFilter) {
          return;
        }

        const tierVariants = variantsByTier[tier];
        if (tierVariants && tierVariants.length > 0) {
          const filteredVariants = tierVariants.filter(variant => {
            if (weightFilter !== 'all' && variant.correctedWeight !== weightFilter) {
              return false;
            }
            if (!stockFilter && !variant.available) {
              return false;
            }
            return true;
          });

          if (filteredVariants.length > 0) {
            const section = document.createElement('div');
            section.className = `variant-section variant-section-${tier.toLowerCase()}`;

            const title = document.createElement('div');
            title.className = `variant-title variant-title-${tier.toLowerCase()}`;
            title.textContent = tier;
            section.appendChild(title);

            const weights = document.createElement('div');
            weights.className = 'variant-weights';

            filteredVariants.forEach(variant => {
              const row = document.createElement('div');
              row.className = variant.available ? 'weight-row in-stock' : 'weight-row out-of-stock';
              
              // Add click handler to stop event propagation
              row.addEventListener('click', (e) => {
                e.stopPropagation();
              });

              const infoRow = document.createElement('div');
              infoRow.className = 'weight-info-row';

              const info = document.createElement('div');
              info.className = 'weight-info';

              const label = document.createElement('span');
              label.className = 'weight-label';
              label.textContent = variant.correctedWeight;

              const price = document.createElement('span');
              price.className = 'weight-price';
              price.textContent = `$${variant.price}`;

              info.appendChild(label);
              info.appendChild(price);
              infoRow.appendChild(info);

              const stockBadge = document.createElement('span');
              stockBadge.className = `stock-badge ${variant.available ? 'in-stock-badge' : 'out-of-stock-badge'}`;
              stockBadge.textContent = variant.available ? 'In Stock' : 'Out of Stock';

              row.appendChild(infoRow);
              row.appendChild(stockBadge);

              if (variant.available) {
                const addButton = document.createElement('button');
                addButton.className = 'add-to-cart-button';
                addButton.textContent = 'Add to Cart';
                addButton.onclick = (e) => {
                  e.stopPropagation();
                  virtualCart.addItem(product, variant);
                };
                row.appendChild(addButton);
              }

              weights.appendChild(row);
            });

            section.appendChild(weights);
            container.appendChild(section);
          }
        }
      });

      return container;
    }

    function createProductDescription(product) {
      const description = document.createElement('p');
      description.className = 'product-description';
      
      if (product.body_html) {
        const temp = document.createElement('div');
        temp.innerHTML = product.body_html;
        
        // Find any link that contains the text "Click here for product COA"
        const links = temp.getElementsByTagName('a');
        for (const link of links) {
          if (link.textContent.toLowerCase().includes('click here for product coa')) {
            link.className = 'coa-button';
            link.textContent = 'View COA';
            link.target = '_blank';
            
            // Get the original href
            const originalUrl = link.href;
            
            // Check if it's a PDF link (look for .pdf anywhere in the URL)
            if (originalUrl.toLowerCase().includes('.pdf')) {
              // Use Google Docs viewer for PDFs
              // Extract the base URL without query parameters
              const baseUrl = originalUrl.split('?')[0];
              link.href = `https://docs.google.com/viewer?url=${encodeURIComponent(baseUrl)}&embedded=true`;
            }
            
            // Add event listener to stop propagation
            link.addEventListener('click', (e) => {
              e.stopPropagation(); // Stop the event from bubbling up
            });
          }
        }
        
        const plainText = temp.textContent
          .replace(/click here for product coa/gi, '')
          .replace(/\s+/g, ' ')
          .trim();
          
        if (plainText.length > 10) {
          description.innerHTML = temp.innerHTML;
          return description;
        }
      }
      
      // Only fall back to manual strain description if no product description
      const cleanStrainName = product.title
        .replace(/\s*-?\s*THCA\s+Flower\s*$/i, '')
        .replace(/\s*-?\s*Flower\s*$/i, '')
        .replace(/\s*-?\s*\d+\.?\d*g\s*$/i, '')
        .replace(/-/g, '')
        .trim()
        .toLowerCase();

      const leaflyData = strainData[cleanStrainName];
      description.innerHTML = leaflyData?.description || 'No description available.';
      return description;
    }

    // Update filter function
    function filterProducts() {
      const strainFilter = domElements.strainFilter.value;
      const strainTypeFilter = domElements.strainTypeFilter.value;
      const weightFilter = domElements.weightFilter.value;
      const stockFilter = domElements.stockFilter.classList.contains('active');
      const searchQuery = domElements.searchInput.value.toLowerCase().trim();
      const sortFilter = domElements.sortFilter.value;

      const filteredProducts = products.filter((product) => {
        // Process variants with utility function first
        const correctedVariants = utils.processVariants(product);
        
        // Check search query - search in title AND variant options
        if (searchQuery) {
          const titleMatch = product.title.toLowerCase().includes(searchQuery);
          const variantMatch = correctedVariants.some(v => 
            v.correctedWeight?.toLowerCase().includes(searchQuery) ||
            v.correctedTier?.toLowerCase().includes(searchQuery) ||
            v.title?.toLowerCase().includes(searchQuery)
          );
          
          if (!titleMatch && !variantMatch) {
            return false;
          }
        }

        // If no valid variants at all, filter out the product
        if (correctedVariants.length === 0) {
          return false;
        }

        // Check if any variant matches the weight filter AND has a valid price
        if (weightFilter !== 'all') {
          const validWeightVariants = correctedVariants.filter(v => 
            v.correctedWeight === weightFilter && 
            v.hasPrice
          );
          if (validWeightVariants.length === 0) {
            return false;
          }
        }

        // Check if any variant matches the strain filter
        if (strainFilter !== 'all') {
          const validStrainVariants = correctedVariants.filter(v => 
            v.correctedTier === strainFilter && 
            (weightFilter === 'all' || v.correctedWeight === weightFilter) &&
            v.hasPrice
          );
          if (validStrainVariants.length === 0) {
            return false;
          }
        }

        // Check strain type
        if (strainTypeFilter !== 'all') {
          const productStrainType = getStrainType(product.body_html, product.handle, product.title);
          if (productStrainType !== strainTypeFilter) {
            return false;
          }
        }

        // Check stock status
        if (!stockFilter) {
          let stockCheckVariants = correctedVariants;
          if (weightFilter !== 'all') {
            stockCheckVariants = stockCheckVariants.filter(v => 
              v.correctedWeight === weightFilter && 
              v.hasPrice
            );
          }
          if (strainFilter !== 'all') {
            stockCheckVariants = stockCheckVariants.filter(v => v.correctedTier === strainFilter);
          }
          
          const hasInStockVariant = stockCheckVariants.some(variant => variant.available);
          if (!hasInStockVariant) {
            return false;
          }
        }

        return true;
      });

      // Sort the filtered products
      const sortedProducts = utils.sortProducts(filteredProducts, sortFilter, strainFilter, weightFilter);
      
      // Render the sorted products
      renderProducts(sortedProducts);
    }

    // Functions to handle filter state persistence
    function saveFilterState() {
      const filterState = {
        strainFilter: document.getElementById('strain-filter').value,
        strainTypeFilter: document.getElementById('strain-type-filter').value,
        weightFilter: document.getElementById('weight-filter').value,
        sortFilter: document.getElementById('sort-filter').value,
        stockFilter: document.getElementById('stock-filter').classList.contains('active')
      };
      localStorage.setItem('litFarmsFilterState', JSON.stringify(filterState));
    }

    function loadFilterState() {
      const savedState = localStorage.getItem('litFarmsFilterState');
      if (savedState) {
        const filterState = JSON.parse(savedState);
        
        // Restore select filters and update their styles
        const selects = {
          'strain-filter': filterState.strainFilter,
          'strain-type-filter': filterState.strainTypeFilter,
          'weight-filter': filterState.weightFilter,
          'sort-filter': filterState.sortFilter
        };

        Object.entries(selects).forEach(([id, value]) => {
          const select = document.getElementById(id);
          select.value = value;
          updateSelectStyle(select);
        });
        
        // Restore stock filter button state
        const stockButton = document.getElementById('stock-filter');
        if (filterState.stockFilter) {
          stockButton.classList.add('active');
          stockButton.textContent = 'Show All Items';
        } else {
          stockButton.classList.remove('active');
          stockButton.textContent = 'In Stock Only';
        }
      } else {
        // Set default state for first-time users: In Stock Only
        const stockButton = document.getElementById('stock-filter');
        stockButton.classList.remove('active');
        stockButton.textContent = 'In Stock Only';
      }

      // Always reset search input
      const searchInput = document.getElementById('product-search-filter');
      const clearSearchButton = document.getElementById('clear-search');
      searchInput.value = '';
      clearSearchButton.style.display = 'none';
    }

    // Event listeners for filters
    document.getElementById('strain-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    document.getElementById('strain-type-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    document.getElementById('weight-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    document.getElementById('sort-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    // Function to update select element style based on selection
    function updateSelectStyle(selectElement) {
      // Don't apply styles to the sort filter since it has no default option
      if (selectElement.id === 'sort-filter') {
        return;
      }
      
      if (selectElement.value === 'all') {
        selectElement.classList.remove('has-selection');
      } else {
        selectElement.classList.add('has-selection');
      }
    }

    document.getElementById('stock-filter').addEventListener('click', () => {
      const button = document.getElementById('stock-filter');
      button.classList.toggle('active');
      button.textContent = button.classList.contains('active') ? 'Show All Items' : 'In Stock Only';
      filterProducts();
      saveFilterState();
    });

    // Function to compare products and detect changes
    function detectProductChanges(oldProducts, newProducts) {
      log(LOG_LEVELS.INFO, '=== Starting Product Change Detection ===');
      log(LOG_LEVELS.INFO, `Old products count: ${oldProducts.length}`);
      log(LOG_LEVELS.INFO, `New products count: ${newProducts.length}`);

      // Check for maintenance mode
      if (newProducts.length === 0 && oldProducts.length > 0) {
        // This might be maintenance mode rather than actual product removal
        // We'll check the last error in the fetch
        const lastError = localStorage.getItem('lastFetchError');
        if (lastError && lastError.includes('401')) {
          log(LOG_LEVELS.WARN, 'Site appears to be in maintenance mode, skipping change detection');
          return {
            new: [],
            stockChanged: [],
            removed: [],
            maintenanceMode: true
          };
        }
      }

      // Helper function to check if a product matches current filters
      function matchesFilters(product) {
        const variants = utils.processVariants(product);
        
        // If specific products are selected, only check those
        if (currentSettings.specificProducts.length > 0) {
          return currentSettings.specificProducts.includes(product.handle);
        }

        // Check if any variant matches the tier and weight filters
        return variants.some(variant => {
          const matchesTier = currentSettings.notificationTiers.includes('all') ||
                            currentSettings.notificationTiers.includes(variant.correctedTier);
          const matchesWeight = currentSettings.notificationWeights.includes('all') ||
                              currentSettings.notificationWeights.includes(variant.correctedWeight);
          return matchesTier && matchesWeight;
        });
      }

      const changes = {
        new: [],
        stockChanged: [],
        removed: []
      };

      // Check for new products
      if (currentSettings.notifyNew) {
        const oldHandles = new Set(oldProducts.map(p => p.handle));
        const newlyAdded = newProducts.filter(p => !oldHandles.has(p.handle));
        
        newlyAdded.forEach(newProduct => {
          if (matchesFilters(newProduct)) {
            log(LOG_LEVELS.INFO, `New product detected: ${newProduct.title}`);
            changes.new.push(newProduct);
          }
        });
      }

      // Check for stock changes and variant changes
      if (currentSettings.notifyStock) {
        newProducts.forEach(newProduct => {
          const oldProduct = oldProducts.find(p => p.handle === newProduct.handle);
          if (oldProduct && matchesFilters(newProduct)) {
            const oldVariants = utils.processVariants(oldProduct);
            const newVariants = utils.processVariants(newProduct);

            let hasChanges = false;
            const changedVariants = [];

            // Check for changes in existing variants
            newVariants.forEach(newVariant => {
              const oldVariant = oldVariants.find(v => 
                v.correctedTier === newVariant.correctedTier && 
                v.correctedWeight === newVariant.correctedWeight
              );

              if (oldVariant) {
                // Check for availability changes
                const availabilityChanged = oldVariant.available !== newVariant.available;
                // Only track price changes if the item is currently in stock or was in stock
                const priceChanged = oldVariant.price !== newVariant.price && (oldVariant.available || newVariant.available);
                
                if (availabilityChanged || priceChanged) {
                  hasChanges = true;
                  changedVariants.push({
                    ...newVariant,
                    oldPrice: oldVariant.price,
                    oldAvailable: oldVariant.available
                  });
                  log(LOG_LEVELS.INFO, `Variant change detected for ${newProduct.title}`, {
                    tier: newVariant.correctedTier,
                    weight: newVariant.correctedWeight,
                    oldPrice: oldVariant.price,
                    newPrice: newVariant.price,
                    oldAvailable: oldVariant.available,
                    newAvailable: newVariant.available
                  });
                }
              } else {
                // New variant added
                hasChanges = true;
                changedVariants.push(newVariant);
                log(LOG_LEVELS.INFO, `New variant added to ${newProduct.title}`, {
                  tier: newVariant.correctedTier,
                  weight: newVariant.correctedWeight,
                  price: newVariant.price,
                  available: newVariant.available
                });
              }
            });

            if (hasChanges) {
              changes.stockChanged.push({
                ...newProduct,
                changedVariants
              });
            }
          }
        });
      }

      // Check for removed products
      if (currentSettings.notifyRemoved) {
        const newHandles = new Set(newProducts.map(p => p.handle));
        oldProducts.forEach(oldProduct => {
          if (!newHandles.has(oldProduct.handle) && matchesFilters(oldProduct)) {
            log(LOG_LEVELS.INFO, `Product removed: ${oldProduct.title}`);
            changes.removed.push(oldProduct);
          }
        });
      }

      // Log summary of changes
      log(LOG_LEVELS.INFO, '=== Change Detection Summary ===', {
        newProducts: changes.new.length,
        stockChanges: changes.stockChanged.length,
        removedProducts: changes.removed.length
      });

      return changes;
    }

    // Function to send Ntfy notification
    async function sendNtfyNotification(title, message, priority = 3) {
      if (!NTFY_CONFIG.appEnabled && !NTFY_CONFIG.emailEnabled) {
        console.log('No notification methods enabled');
        return;
      }

      if (NTFY_CONFIG.appEnabled && !NTFY_CONFIG.topic) {
        console.log('App notifications enabled but no topic set');
        return;
      }

      if (NTFY_CONFIG.emailEnabled && !NTFY_CONFIG.email) {
        console.log('Email notifications enabled but no email set');
        return;
      }

      try {
        const headers = {
          'X-Title': title,
          'X-Priority': priority.toString(),
          'X-Tags': 'cannabis,stock'
        };

        // Email header
        if (NTFY_CONFIG.emailEnabled && NTFY_CONFIG.email) {
          headers['X-Email'] = NTFY_CONFIG.email;
        }

        // Send notification - we need a topic even for email-only notifications
        const topic = NTFY_CONFIG.appEnabled ? NTFY_CONFIG.topic : 'email-only-' + Math.random().toString(36).substring(7);
        
        const response = await fetch(`${NTFY_CONFIG.server}/${topic}`, {
          method: 'POST',
          headers: headers,
          body: message
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        console.log('Notification sent successfully');
      } catch (error) {
        console.error('Failed to send notification:', error);
      }
    }

    // Function to check if a variant matches notification settings
    function matchesNotificationFilters(variant) {
      const matchesTier = currentSettings.notificationTiers.includes('all') ||
                         currentSettings.notificationTiers.includes(variant.correctedTier);
      const matchesWeight = currentSettings.notificationWeights.includes('all') ||
                         currentSettings.notificationWeights.includes(variant.correctedWeight);
      return matchesTier && matchesWeight;
    }

    // Update handleNotifications function to filter based on settings
    async function handleNotifications(changes) {
      if (changes.maintenanceMode) {
        // Only send maintenance mode notification if notifications are enabled
        if (NTFY_CONFIG.appEnabled || NTFY_CONFIG.emailEnabled) {
          const message = ` MAINTENANCE MODE 

LitFarms website is currently in maintenance mode.
The product list will be updated once the site is back online.

Using cached data from: ${new Date(parseInt(localStorage.getItem(CACHE_TIMESTAMP_KEY))).toLocaleString()}

 Status checked: ${new Date().toLocaleString()}`;

          await sendNtfyNotification('LitFarms Maintenance Mode', message, 3);
        }
        return;
      }

      if (!changes.new.length && !changes.stockChanged.length && !changes.removed.length) {
        return;
      }

      // Filter changes based on notification settings
      const filteredChanges = {
        new: changes.new.filter(product => {
          const variants = utils.processVariants(product);
          return variants.some(variant => matchesNotificationFilters(variant));
        }),
        stockChanged: changes.stockChanged.filter(product => {
          // Only include products where changed variants match filters
          const filteredVariants = product.changedVariants.filter(variant => 
            matchesNotificationFilters(variant)
          );
          if (filteredVariants.length > 0) {
            // Update changedVariants to only include matching variants
            product.changedVariants = filteredVariants;
            return true;
          }
          return false;
        }),
        removed: changes.removed.filter(product => {
          const variants = utils.processVariants(product);
          return variants.some(variant => matchesNotificationFilters(variant));
        })
      };

      // Log all changes for record keeping
      log(LOG_LEVELS.INFO, '=== All Changes ===', changes);
      log(LOG_LEVELS.INFO, '=== Filtered Changes for Notifications ===', filteredChanges);

      // Only send notification if there are filtered changes and notifications are enabled
      if ((filteredChanges.new.length || filteredChanges.stockChanged.length || filteredChanges.removed.length) &&
          (NTFY_CONFIG.appEnabled || NTFY_CONFIG.emailEnabled)) {
        
        let ntfyMessage = '';
        
        if (filteredChanges.new.length && currentSettings.notifyNew) {
          ntfyMessage += ` NEW PRODUCTS (${filteredChanges.new.length}) \n\n`;
          filteredChanges.new.forEach(p => {
            const matchingVariants = utils.processVariants(p).filter(v => matchesNotificationFilters(v));
            ntfyMessage += ` ${p.title}\n`;
            matchingVariants.forEach(v => {
              ntfyMessage += `    ${v.correctedTier} ${v.correctedWeight}\n`;
              ntfyMessage += `      $${v.price} ${v.available ? '(In Stock)' : '(Out of Stock)'}\n`;
            });
            ntfyMessage += '\n';
          });
        }
        
        if (filteredChanges.stockChanged.length && currentSettings.notifyStock) {
          ntfyMessage += ` STOCK CHANGES (${filteredChanges.stockChanged.length}) \n\n`;
          filteredChanges.stockChanged.forEach(p => {
            ntfyMessage += ` ${p.title}\n\n`;
            
            // Get new variants (variants without oldPrice or oldAvailable)
            const newVariants = p.changedVariants.filter(v => !v.oldPrice && !v.oldAvailable);
            const nowInStock = p.changedVariants.filter(v => v.oldAvailable === false && v.available === true);
            const nowOutOfStock = p.changedVariants.filter(v => v.oldAvailable === true && v.available === false);
            const priceChanges = p.changedVariants.filter(v => v.oldPrice && v.price !== v.oldPrice);
            
            // New variants added
            if (newVariants.length > 0) {
              ntfyMessage += `    NEW VARIANTS ADDED:\n`;
              newVariants.forEach(v => {
                ntfyMessage += `       ${v.correctedTier} ${v.correctedWeight}\n`;
                if (v.available) {
                  ntfyMessage += `         $${v.price} (In Stock)\n`;
                } else {
                  ntfyMessage += `         $${v.price} (Out of Stock)\n`;
                }
              });
              ntfyMessage += '\n';
            }
            
            if (nowInStock.length > 0) {
              ntfyMessage += `    NOW IN STOCK:\n`;
              nowInStock.forEach(v => {
                ntfyMessage += `       ${v.correctedTier} ${v.correctedWeight}\n         $${v.price}\n`;
              });
              ntfyMessage += '\n';
            }
            
            if (nowOutOfStock.length > 0) {
              ntfyMessage += `    NOW OUT OF STOCK:\n`;
              nowOutOfStock.forEach(v => {
                ntfyMessage += `       ${v.correctedTier} ${v.correctedWeight}\n         $${v.price}\n`;
              });
              ntfyMessage += '\n';
            }

            if (priceChanges.length > 0) {
              ntfyMessage += `    PRICE CHANGES:\n`;
              priceChanges.forEach(v => {
                const priceChange = parseFloat(v.oldPrice) - parseFloat(v.price);
                const changeSymbol = priceChange > 0 ? '' : '';
                ntfyMessage += `       ${v.correctedTier} ${v.correctedWeight}\n`;
                ntfyMessage += `        Was: $${v.oldPrice}  Now: $${v.price} ${changeSymbol}\n`;
                ntfyMessage += `        ${Math.abs(priceChange).toFixed(2)} ${priceChange > 0 ? 'decrease' : 'increase'}\n`;
              });
              ntfyMessage += '\n';
            }
          });
        }
        
        if (filteredChanges.removed.length && currentSettings.notifyRemoved) {
          ntfyMessage += ` REMOVED PRODUCTS (${filteredChanges.removed.length}) \n\n`;
          filteredChanges.removed.forEach(p => {
            const matchingVariants = utils.processVariants(p).filter(v => matchesNotificationFilters(v));
            ntfyMessage += ` ${p.title}\n`;
            matchingVariants.forEach(v => {
              ntfyMessage += `    ${v.correctedTier} ${v.correctedWeight}\n`;
            });
            ntfyMessage += '\n';
          });
        }
        
        if (ntfyMessage) {
          ntfyMessage += `\n Updated: ${new Date().toLocaleString()}`;
          await sendNtfyNotification('LitFarms Update', ntfyMessage);
        }
      }
    }

    // Update the startProductUpdateChecker function
    function startProductUpdateChecker() {
      // Create a deep copy of products to avoid reference issues
      let lastProducts = JSON.parse(JSON.stringify(products));
      const intervalMs = currentSettings.checkInterval * 60 * 1000;

      console.log(`Starting product update checker - checking every ${currentSettings.checkInterval} minutes`);

      // Start the countdown timer and get cleanup function
      const countdownCleanup = startCountdownTimer(intervalMs);
      
      // Add countdown timer cleanup to pageCleanupHandlers
      pageCleanupHandlers.push(countdownCleanup);

      updateCheckerId = setInterval(async () => {
        try {
          const freshProducts = await getProducts();
          const changes = detectProductChanges(lastProducts, freshProducts);
          
          if (changes.new.length > 0 || changes.stockChanged.length > 0 || changes.removed.length > 0) {
            console.log('Changes detected, updating state and sending notifications...');
            await handleNotifications(changes);
            products = freshProducts;
            // Update lastProducts with a deep copy
            lastProducts = JSON.parse(JSON.stringify(freshProducts));
            filterProducts();
            updateProductSelectList();
          } else {
            // Even if no changes, update lastProducts to keep it in sync
            lastProducts = JSON.parse(JSON.stringify(freshProducts));
          }
        } catch (error) {
          console.error('Error checking for product updates:', error);
        }
      }, intervalMs);

      return updateCheckerId;
    }

    // Filter THCA products
    function filterTHCAProducts(products) {
      const thcaProducts = products.filter(product => 
        product.title.toLowerCase().includes('thca') || 
        product.tags.includes('thca') || 
        product.product_type === 'THCA Flower'
      );
      //console.log(`Filtered ${products.length} total products to ${thcaProducts.length} THCA products`);
      return thcaProducts;
    }

    // Update the preloadImages function to remove text updates
    function preloadImages(products) {
      return Promise.all(products.map(product => {
        if (!product.images[0]?.src) return Promise.resolve();
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => resolve();
          img.onerror = () => resolve();
          img.src = product.images[0].src;
        });
      }));
    }

    // Add cleanup handler for page unload
    let pageCleanupHandlers = [];
    
    window.addEventListener('beforeunload', () => {
      // Execute all cleanup handlers
      pageCleanupHandlers.forEach(handler => {
        try {
          handler();
        } catch (error) {
          console.warn('Cleanup handler error:', error);
        }
      });
    });

    // Add these utility functions for status management
    const statusManager = {
      show: (message, type = 'error') => {
        const statusBar = document.getElementById('site-status');
        const statusMessage = document.getElementById('status-message');
        const retryButton = document.getElementById('retry-button');
        
        statusBar.className = `site-status ${type}`;
        statusMessage.textContent = message;
        statusBar.style.display = 'block';
        
        // Show retry button for errors
        retryButton.style.display = type === 'error' ? 'inline-block' : 'none';
      },
      
      hide: () => {
        const statusBar = document.getElementById('site-status');
        statusBar.style.display = 'none';
      },
      
      update: (message) => {
        const statusMessage = document.getElementById('status-message');
        statusMessage.textContent = message;
      }
    };

    // Add maintenance mode check interval
    let maintenanceCheckerId = null;
    const MAINTENANCE_CHECK_INTERVAL = 5 * 60 * 1000; // 5 minutes in milliseconds

    // Update attemptLoad function with periodic maintenance check
    async function attemptLoad() {
      let retryCount = 0;
      const maxRetries = 3;
      let imagePreloadAbortController = new AbortController();
      
      // Add cleanup handler
      pageCleanupHandlers.push(() => {
        imagePreloadAbortController.abort();
        if (updateCheckerId) {
          clearInterval(updateCheckerId);
        }
        if (maintenanceCheckerId) {
          clearInterval(maintenanceCheckerId);
          maintenanceCheckerId = null;
        }
      });

      function startMaintenanceChecker() {
        if (maintenanceCheckerId) {
          clearInterval(maintenanceCheckerId);
        }

        // Update status message to show next check time
        const nextCheck = new Date(Date.now() + MAINTENANCE_CHECK_INTERVAL);
        statusManager.show(
          `LitFarms website is in maintenance mode. Next check at ${nextCheck.toLocaleTimeString()}. Using cached data.`,
          'warning'
        );

        maintenanceCheckerId = setInterval(async () => {
          try {
            console.log('Checking if site is back from maintenance...');
            const freshProducts = await getProducts(false);
            if (Array.isArray(freshProducts) && freshProducts.length > 0) {
              // Site is back! Clear maintenance checker and restart normal operation
              clearInterval(maintenanceCheckerId);
              maintenanceCheckerId = null;
              statusManager.hide();
              products = freshProducts;
              filterProducts();
              startProductUpdateChecker();
              console.log('Site is back online, resumed normal operation');
            }
          } catch (error) {
            console.log('Site still in maintenance mode');
            // Update status message with next check time
            const nextCheck = new Date(Date.now() + MAINTENANCE_CHECK_INTERVAL);
            statusManager.show(
              `LitFarms website is in maintenance mode. Next check at ${nextCheck.toLocaleTimeString()}. Using cached data.`,
              'warning'
            );
          }
        }, MAINTENANCE_CHECK_INTERVAL);
      }

      async function tryLoad() {
        try {
          // Hide any existing status messages
          statusManager.hide();
          
          // Load notification settings first
          loadSettings();
          
          // First try to load cached products immediately
          products = await getProducts(true);
          
          if (Array.isArray(products) && products.length > 0) {
            console.log(`Loaded ${products.length} cached THCA products`);
            loadFilterState();
            await loadStrainData();
            
            // Show products immediately
            toggleLoader(false);
            filterProducts();
            
            // Then check for updates in the background without re-rendering if unchanged
            try {
              const updatedProducts = await getProducts(false);
              // Only update if products actually changed (compare lengths and IDs)
              const productsChanged = products.length !== updatedProducts.length ||
                products.some((p, i) => p.id !== updatedProducts[i]?.id || 
                  p.variants.length !== updatedProducts[i]?.variants.length);
              
              if (productsChanged) {
                console.log('Products updated, refreshing display');
                products = updatedProducts;
                filterProducts();
              } else {
                console.log('Products unchanged, skipping re-render');
              }
            } catch (updateError) {
              console.warn('Background update failed:', updateError);
              if (updateError.message.includes('401')) {
                startMaintenanceChecker();
              }
            }
          } else {
            // No cached products, load fresh
            products = await getProducts(false);
            if (!Array.isArray(products) || products.length === 0) {
              throw new Error('No products loaded');
            }
            
            console.log(`Loaded ${products.length} fresh THCA products`);
            loadFilterState();
            await loadStrainData();
            
            toggleLoader(false);
            filterProducts();
          }

          // Start the update checker
          startProductUpdateChecker();
          
          return true; // Success
        } catch (error) {
          console.error('Error in initialization:', error);
          
          if (error.message.includes('401')) {
            if (products && products.length > 0) {
              // We have cached data, start maintenance checker
              startMaintenanceChecker();
            } else {
              statusManager.show('LitFarms website is currently in maintenance mode. Please try again later.', 'error');
            }
          } else {
            statusManager.show('Unable to load products. Please try again later.', 'error');
          }
          
          if (retryCount < maxRetries) {
            retryCount++;
            statusManager.update(`Retrying... Attempt ${retryCount} of ${maxRetries}`);
            
            // Clear cache before retrying
            localStorage.removeItem(CACHE_KEY);
            localStorage.removeItem(CACHE_TIMESTAMP_KEY);
            
            // Wait a bit before retrying
            await new Promise(resolve => setTimeout(resolve, 2000));
            return tryLoad();
          }
          
          if (!products || products.length === 0) {
            const productGrid = document.getElementById('product-grid');
            productGrid.innerHTML = `
              <div style="
                text-align: center;
                padding: 20px;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 100%;
                max-width: 400px;
              ">
                <p style="
                  color: var(--status-error);
                  margin-bottom: 15px;
                  font-size: 16px;
                  line-height: 1.4;
                ">
                  Unable to load products. The LitFarms website may be in maintenance mode.
                </p>
                <button onclick="window.location.reload()" style="
                  background-color: var(--accent-primary);
                  color: var(--bg-primary);
                  border: none;
                  padding: 10px 20px;
                  border-radius: 5px;
                  cursor: pointer;
                  font-size: 14px;
                  transition: opacity 0.2s;
                ">
                  Refresh Page
                </button>
              </div>`;
            toggleLoader(false);
          }
          
          // Start maintenance checker if it was a 401 error
          if (error.message.includes('401')) {
            startMaintenanceChecker();
          }
          
          return false;
        }
      }

      // Initial load attempt
      return tryLoad();
    }

    // Add retry button handler
    document.getElementById('retry-button').addEventListener('click', async () => {
      toggleLoader(true);
      await attemptLoad();
    });

    // Update preloadImages function to accept abort signal
    function preloadImages(products, signal) {
      return Promise.all(products.map(product => {
        if (!product.images[0]?.src) return Promise.resolve();
        return new Promise((resolve, reject) => {
          const img = new Image();
          
          // Handle abort signal
          if (signal) {
            signal.addEventListener('abort', () => {
              img.src = '';
              resolve(); // Resolve instead of reject to avoid error logging
            });
          }
          
          img.onload = () => resolve();
          img.onerror = () => resolve(); // Resolve on error to continue loading
          img.src = product.images[0].src;
        });
      }));
    }

    // Lightbox Functions
    function openLightbox(imageSrc, caption) {
      const lightbox = document.getElementById('image-lightbox');
      const lightboxImg = document.getElementById('lightbox-img');
      const lightboxCaption = document.getElementById('lightbox-caption');
      
      if (!lightbox || !lightboxImg || !lightboxCaption) {
        console.error('Lightbox elements not found');
        return;
      }
      
      // Get higher resolution image by removing size parameters from Shopify URLs
      let highResImageSrc = imageSrc;
      
      // Shopify images often have size parameters like _300x300 or _small
      // Remove these to get the original high-res image
      if (imageSrc && imageSrc.includes('cdn.shopify.com')) {
        // Remove size suffixes like _300x300, _small, _medium, _large, _compact, _grande
        highResImageSrc = imageSrc.replace(/_(pico|icon|thumb|small|compact|medium|large|grande|original|\d+x\d*|x\d+)(\.[a-z]+)/gi, '_2048x2048$2');
        // Or just get the master/original
        highResImageSrc = imageSrc.replace(/_(pico|icon|thumb|small|compact|medium|large|grande|\d+x\d*|x\d+)\./gi, '_master.');
      }
      
      lightbox.style.display = 'flex';
      lightboxImg.src = highResImageSrc;
      lightboxCaption.textContent = caption || '';
      document.body.style.overflow = 'hidden'; // Prevent background scrolling
    }

    function closeLightbox() {
      const lightbox = document.getElementById('image-lightbox');
      if (lightbox) {
        lightbox.style.display = 'none';
      }
      document.body.style.overflow = ''; // Restore scrolling
    }

    // Filters toggle functionality
    let lastScrollY = 0;
    let isFiltersManuallyToggled = false;

    function setupFiltersToggle() {
      const filtersToggle = document.getElementById('filters-toggle');
      const filtersContainer = document.querySelector('.filters-container');
      
      if (!filtersToggle) return;

      // Toggle on button click
      filtersToggle.addEventListener('click', () => {
        filtersContainer.classList.toggle('collapsed');
        isFiltersManuallyToggled = true;
        
        // Reset manual toggle flag after 3 seconds
        setTimeout(() => {
          isFiltersManuallyToggled = false;
        }, 3000);
      });

      // Auto-collapse on scroll down (mobile only)
      window.addEventListener('scroll', () => {
        // Only auto-collapse on mobile
        if (window.innerWidth > 700) return;
        if (isFiltersManuallyToggled) return;
        
        const currentScrollY = window.scrollY;
        
        // Collapse when scrolling down past 100px
        if (currentScrollY > 100 && currentScrollY > lastScrollY) {
          filtersContainer.classList.add('collapsed');
        }
        // Expand when scrolling back to top
        else if (currentScrollY < 50) {
          filtersContainer.classList.remove('collapsed');
        }
        
        lastScrollY = currentScrollY;
      });
    }

    // Document ready event listener
    document.addEventListener('DOMContentLoaded', async () => {
      toggleLoader(true);

      // Setup filters toggle
      setupFiltersToggle();

      // Lightbox event listeners - with null checks
      const lightbox = document.getElementById('image-lightbox');
      const lightboxClose = document.querySelector('.lightbox-close');
      
      if (lightboxClose) {
        lightboxClose.addEventListener('click', closeLightbox);
      }
      
      // Close lightbox when clicking anywhere (background, image, or close button)
      if (lightbox) {
        lightbox.addEventListener('click', (e) => {
          // Close on any click within the lightbox
          closeLightbox();
        });
      }
      
      // Also add click handler to the image itself
      const lightboxImg = document.getElementById('lightbox-img');
      if (lightboxImg) {
        lightboxImg.addEventListener('click', (e) => {
          closeLightbox();
        });
      }
      
      // Close lightbox with Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const lb = document.getElementById('image-lightbox');
          if (lb && lb.style.display === 'flex') {
            closeLightbox();
          }
        }
      });

      // Settings modal with event capture
      const settingsButton = document.getElementById('settings-button');
      settingsButton.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();
        openSettingsModal();
      }, true);
      
      // Prevent touch events from passing through
      settingsButton.addEventListener('touchstart', (e) => {
        e.stopPropagation();
      }, { capture: true, passive: true });
      
      settingsButton.addEventListener('touchend', (e) => {
        e.stopPropagation();
      }, { capture: true, passive: true });
      document.querySelector('.close-modal').addEventListener('click', closeSettingsModal);
      document.querySelector('.save-settings').addEventListener('click', saveSettingsFromForm);

      // Track mousedown position for modal
      let modalMouseDown = false;
      const modal = document.getElementById('settings-modal');
      
      modal.addEventListener('mousedown', (e) => {
        if (e.target === modal) {
          modalMouseDown = true;
        }
      });

      modal.addEventListener('mouseup', (e) => {
        if (e.target === modal && modalMouseDown) {
          closeSettingsModal();
        }
        modalMouseDown = false;
      });

      // Reset flag when mouse leaves modal
      modal.addEventListener('mouseleave', () => {
        modalMouseDown = false;
      });

      let retryCount = 0;
      const maxRetries = 3;

      await attemptLoad();
    });

    function updateProductSelectList() {
      const productSelect = document.getElementById('product-select');
      productSelect.innerHTML = '';

      // Sort products alphabetically by title
      const sortedProducts = [...products].sort((a, b) => 
        a.title.toLowerCase().localeCompare(b.title.toLowerCase())
      );

      sortedProducts.forEach(product => {
        const item = document.createElement('div');
        item.className = 'product-select-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `product-${product.handle}`;
        checkbox.value = product.handle;
        checkbox.checked = currentSettings.specificProducts.includes(product.handle);
        
        const label = document.createElement('label');
        label.htmlFor = `product-${product.handle}`;
        label.textContent = product.title;
        
        item.appendChild(checkbox);
        item.appendChild(label);
        productSelect.appendChild(item);
      });

      // Update count
      updateProductsSelectedCount();
    }

    function openSettingsModal() {
      // Load current settings into form
      document.getElementById('check-interval').value = currentSettings.checkInterval;
      document.getElementById('ntfy-topic').value = currentSettings.ntfyTopic;
      document.getElementById('ntfy-server').value = currentSettings.ntfyServer;
      document.getElementById('ntfy-email').value = currentSettings.ntfyEmail;
      document.getElementById('ntfy-enabled').checked = currentSettings.ntfyAppEnabled;
      document.getElementById('email-enabled').checked = currentSettings.ntfyEmailEnabled;
      
      // Set notification type checkboxes
      document.getElementById('notify-new').checked = currentSettings.notifyNew;
      document.getElementById('notify-stock').checked = currentSettings.notifyStock;
      document.getElementById('notify-removed').checked = currentSettings.notifyRemoved;
      
      // Update the minutes suffix position immediately after setting the value
      requestAnimationFrame(updateMinutesSuffixPosition);
      
      // Set multiple select values
      const tierSelect = document.getElementById('notification-tier');
      const weightSelect = document.getElementById('notification-weight');

      // Clear previous selections
      Array.from(tierSelect.options).forEach(option => option.selected = false);
      Array.from(weightSelect.options).forEach(option => option.selected = false);
      
      // Set new selections
      currentSettings.notificationTiers.forEach(tier => {
        const option = Array.from(tierSelect.options).find(opt => opt.value === tier);
        if (option) option.selected = true;
      });
      
      currentSettings.notificationWeights.forEach(weight => {
        const option = Array.from(weightSelect.options).find(opt => opt.value === weight);
        if (option) option.selected = true;
      });
      
      // If nothing is selected, select 'all' by default
      if (!Array.from(tierSelect.selectedOptions).length) {
        tierSelect.querySelector('option[value="all"]').selected = true;
      }
      if (!Array.from(weightSelect.selectedOptions).length) {
        weightSelect.querySelector('option[value="all"]').selected = true;
      }
      
      // Update product list and clear search
      updateProductSelectList();
      
      // Clear search input
      const searchInput = document.getElementById('product-search');
      searchInput.value = '';
      
      // Setup search functionality
      const productSelect = document.getElementById('product-select');
      
      // Remove old event listener if exists
      const newSearchInput = searchInput.cloneNode(true);
      searchInput.parentNode.replaceChild(newSearchInput, searchInput);
      
      newSearchInput.addEventListener('input', (e) => {
        const items = productSelect.getElementsByClassName('product-select-item');
        const term = e.target.value.toLowerCase();
        
        Array.from(items).forEach(item => {
          const label = item.querySelector('label');
          const title = label.textContent.toLowerCase();
          
          if (title.includes(term)) {
            item.classList.remove('hidden');
          } else {
            item.classList.add('hidden');
          }
        });
      });

      // Show modal
      const modal = document.getElementById('settings-modal');
      modal.style.display = 'flex';
      document.body.classList.add('modal-open');
      // Prevent background scrolling
      document.body.style.overflow = 'hidden';
      document.body.style.position = 'fixed';
      document.body.style.width = '100%';
    }

    function closeSettingsModal() {
      document.getElementById('settings-modal').style.display = 'none';
      document.body.classList.remove('modal-open');
      // Restore scrolling
      document.body.style.overflow = '';
      document.body.style.position = '';
      document.body.style.width = '';
    }

    function getSelectedValues(selectElement) {
      const selectedValues = Array.from(selectElement.selectedOptions).map(option => option.value);
      // If nothing is selected or only 'all' is selected, return ['all']
      return selectedValues.length === 0 ? ['all'] : selectedValues;
    }

    function saveSettingsFromForm() {
      const newSettings = {
        checkInterval: parseInt(document.getElementById('check-interval').value) || DEFAULT_SETTINGS.checkInterval,
        notificationTiers: getSelectedValues(document.getElementById('notification-tier')),
        notificationWeights: getSelectedValues(document.getElementById('notification-weight')),
        notifyNew: document.getElementById('notify-new').checked,
        notifyStock: document.getElementById('notify-stock').checked,
        notifyRemoved: document.getElementById('notify-removed').checked,
        specificProducts: Array.from(document.querySelectorAll('#product-select input:checked')).map(cb => cb.value),
        ntfyAppEnabled: document.getElementById('ntfy-enabled').checked,
        ntfyEmailEnabled: document.getElementById('email-enabled').checked,
        ntfyTopic: document.getElementById('ntfy-topic').value.trim(),
        ntfyServer: document.getElementById('ntfy-server').value.trim() || DEFAULT_SETTINGS.ntfyServer,
        ntfyEmail: document.getElementById('ntfy-email').value.trim()
      };

      // Update Ntfy config
      NTFY_CONFIG.appEnabled = newSettings.ntfyAppEnabled;
      NTFY_CONFIG.emailEnabled = newSettings.ntfyEmailEnabled;
      NTFY_CONFIG.topic = newSettings.ntfyTopic;
      NTFY_CONFIG.server = newSettings.ntfyServer;
      NTFY_CONFIG.email = newSettings.ntfyEmail;

      // Log the settings being saved
      console.log('Saving settings:', newSettings);

      saveSettings(newSettings);
      closeSettingsModal();
    }

    // Event listeners for the multiple selects
    document.addEventListener('DOMContentLoaded', () => {
      const tierSelect = document.getElementById('notification-tier');
      const weightSelect = document.getElementById('notification-weight');

      function handleAllOption(selectElement) {
        selectElement.addEventListener('change', (e) => {
          const allOption = selectElement.querySelector('option[value="all"]');
          const otherOptions = Array.from(selectElement.options).filter(opt => opt.value !== 'all');
          
          if (allOption.selected) {
            // If 'all' is selected, deselect other options
            otherOptions.forEach(opt => opt.selected = false);
          } else if (Array.from(selectElement.selectedOptions).length === 0) {
            // If nothing is selected, select 'all'
            allOption.selected = true;
          } else {
            // If other options are selected, deselect 'all'
            allOption.selected = false;
          }
        });
      }

      handleAllOption(tierSelect);
      handleAllOption(weightSelect);
    });



    // Dynamic suffix positioning
    function updateMinutesSuffixPosition() {
      const input = document.getElementById('check-interval');
      const suffix = input.nextElementSibling;
      const valueLength = input.value.length;
      const basePosition = 28; // Base position for single digit
      const digitWidth = 8; // Approximate width per digit
      
      // Calculate new position based on number of digits
      const newPosition = basePosition + (valueLength - 1) * digitWidth;
      suffix.style.left = `${newPosition}px`;
    }

    // Event listeners for the check interval input
    document.addEventListener('DOMContentLoaded', () => {
      const checkIntervalInput = document.getElementById('check-interval');
      
      // Update position on any input change
      checkIntervalInput.addEventListener('input', updateMinutesSuffixPosition);
      
      // Initial position
      updateMinutesSuffixPosition();
    });

    // Test Ntfy notification
    let testButtonCooldown = false;
    const COOLDOWN_PERIOD = 30000; // 10 seconds in milliseconds

    async function testNtfyNotification() {
      if (testButtonCooldown) {
        return;
      }

      // Get current form values instead of using saved settings
      const appEnabled = document.getElementById('ntfy-enabled').checked;
      const emailEnabled = document.getElementById('email-enabled').checked;
      const topic = document.getElementById('ntfy-topic').value.trim();
      const server = document.getElementById('ntfy-server').value.trim() || DEFAULT_SETTINGS.ntfyServer;
      const email = document.getElementById('ntfy-email').value.trim();

      if (!appEnabled && !emailEnabled) {
        alert('Please enable at least one notification method');
        return;
      }

      if (appEnabled && !topic) {
        alert('Please set a topic for app notifications');
        return;
      }

      if (emailEnabled && !email) {
        alert('Please set an email address for email notifications');
        return;
      }

      const testButton = document.getElementById('test-ntfy');
      testButton.disabled = true;
      testButton.textContent = 'Sending...';

      // Set cooldown flag
      testButtonCooldown = true;

      try {
        // Create temporary config for test
        const tempConfig = {
          appEnabled: appEnabled,
          emailEnabled: emailEnabled,
          topic: topic,
          server: server,
          email: email
        };

        // Store current config
        const originalConfig = { ...NTFY_CONFIG };
        
        // Temporarily set config to form values
        Object.assign(NTFY_CONFIG, tempConfig);

        const testMessage = ` NEW PRODUCTS (2) 

 Blue Dream THCA Flower
    Essential 28g
      $49.99

 Purple Punch THCA Flower
    Supreme 28g
      $89.99


 STOCK CHANGES (2) 

 Gelato THCA Flower

    NOW IN STOCK:
       Essential 28g
         $49.99

    NOW OUT OF STOCK:
       Preferred 28g
         $69.99


 Wedding Cake THCA Flower

    NOW IN STOCK:
       Supreme 28g
         $89.99


 REMOVED PRODUCTS (1) 

 Northern Lights THCA Flower


 Updated: ${new Date().toLocaleString()}`;

        await sendNtfyNotification(
          'LitFarms Test Notification',
          testMessage
        );
        testButton.textContent = 'Notification Sent!';

        // Restore original config
        Object.assign(NTFY_CONFIG, originalConfig);
      } catch (error) {
        console.error('Failed to send test notification:', error);
        testButton.textContent = 'Error!';
        
        // Restore original config in case of error
        Object.assign(NTFY_CONFIG, originalConfig);
      }

      // Start cooldown timer
      setTimeout(() => {
        testButtonCooldown = false;
        testButton.disabled = false;
        testButton.textContent = 'Test Notifications';
      }, COOLDOWN_PERIOD);

      // Countdown timer
      let remainingTime = COOLDOWN_PERIOD / 1000;
      const countdownInterval = setInterval(() => {
        remainingTime--;
        if (remainingTime > 0) {
          testButton.textContent = `Wait ${remainingTime}s`;
        } else {
          clearInterval(countdownInterval);
        }
      }, 1000);
    }

    // Update selected products count
    function updateSelectedProductsCount() {
      const selectedCount = document.querySelectorAll('#product-select input:checked').length;
      const countElement = document.getElementById('products-selected-count');
      countElement.textContent = `${selectedCount} product${selectedCount === 1 ? '' : 's'} selected`;
    }

    // Deselect all products
    function deselectAllProducts() {
      const checkboxes = document.querySelectorAll('#product-select input[type="checkbox"]');
      checkboxes.forEach(checkbox => {
        checkbox.checked = false;
      });
      updateSelectedProductsCount();
    }

    // Update the updateProductSelectList function to include count updates
    function updateProductSelectList() {
      const productSelect = document.getElementById('product-select');
      productSelect.innerHTML = '';

      // Sort products alphabetically by title
      const sortedProducts = [...products].sort((a, b) => 
        a.title.toLowerCase().localeCompare(b.title.toLowerCase())
      );

      sortedProducts.forEach(product => {
        const item = document.createElement('div');
        item.className = 'product-select-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `product-${product.handle}`;
        checkbox.value = product.handle;
        checkbox.checked = currentSettings.specificProducts.includes(product.handle);
        
        // Update count
        checkbox.addEventListener('change', updateSelectedProductsCount);
        
        const label = document.createElement('label');
        label.htmlFor = `product-${product.handle}`;
        label.textContent = product.title;
        
        item.appendChild(checkbox);
        item.appendChild(label);
        productSelect.appendChild(item);
      });

      // Update initial count
      updateSelectedProductsCount();

      // Search functionality
      const searchInput = document.getElementById('product-search');
      
      function filterProducts(searchTerm) {
        const items = productSelect.getElementsByClassName('product-select-item');
        const term = searchTerm.toLowerCase();
        
        Array.from(items).forEach(item => {
          const label = item.querySelector('label');
          const title = label.textContent.toLowerCase();
          
          if (title.includes(term)) {
            item.classList.remove('hidden');
          } else {
            item.classList.add('hidden');
          }
        });
      }

      // Search event listener
      searchInput.addEventListener('input', (e) => {
        filterProducts(e.target.value);
      });

      // Clear search when modal is opened
      searchInput.value = '';
      filterProducts('');
    }

    // Topic name arrays
    const ADJECTIVES = ['swift', 'bright', 'cosmic', 'mystic', 'golden', 'silver', 'crystal', 'azure', 'crimson', 'emerald'];
    const NOUNS = ['phoenix', 'dragon', 'falcon', 'tiger', 'wolf', 'eagle', 'lion', 'hawk', 'panther', 'bear'];
    
    // Random topic name generator
    function generateRandomTopic() {
      // Get random elements from arrays
      const adjective = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
      const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
      
      // Generate random numbers (4 digits)
      const numbers = Math.floor(1000 + Math.random() * 9000);
      
      // Generate random letters (2 characters)
      const letters = String.fromCharCode(65 + Math.floor(Math.random() * 26)) + 
                     String.fromCharCode(65 + Math.floor(Math.random() * 26));
      
      // Combine everything with dashes
      const topic = `litfarms-${adjective}-${noun}-${numbers}${letters}`;
      
      // Set the value in the input field
      document.getElementById('ntfy-topic').value = topic;
    }

    // Clear search functionality
    const clearSearchButton = document.getElementById('clear-search');
    const searchInput = document.getElementById('product-search-filter');

    // Show/hide clear button based on search input content
    searchInput.addEventListener('input', () => {
      clearSearchButton.style.display = searchInput.value ? 'flex' : 'none';
      filterProducts();
      saveFilterState();
    });

    // Move cursor to end when input receives focus
    searchInput.addEventListener('focus', () => {
      const length = searchInput.value.length;
      searchInput.setSelectionRange(length, length);
    });

    // Close keyboard on enter key press
    searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        searchInput.blur(); // This will close the keyboard on mobile
      }
    });

    // Clear search when button is clicked
    clearSearchButton.addEventListener('click', () => {
      searchInput.value = '';
      clearSearchButton.style.display = 'none';
      filterProducts();
      saveFilterState();
    });

    // Utility Functions
    const WEIGHTS = ['28g', '3.5g', '7g', '28g (Smalls)'];
    const TIERS = ['Essential', 'Preferred', 'Supreme'];
    
    const utils = {
      isWeight: (value) => value && WEIGHTS.includes(value),
      isTier: (value) => value && TIERS.includes(value),
      hasValidPrice: (variant) => variant.price && !isNaN(parseFloat(variant.price)) && parseFloat(variant.price) > 0,
      
      standardizeWeight: (weightStr) => {
        if (!weightStr) return null;
        weightStr = weightStr.trim();
        // Handle "28g (Smalls)" as a special case
        if (weightStr.toLowerCase().includes('smalls')) {
          return '28g (Smalls)';
        }
        if (weightStr.match(/^\d+\.?\d*$/)) weightStr += 'g';
        if (weightStr === '3.5') weightStr = '3.5g';
        return weightStr;
      },
      
      processVariants: (product) => {
        return product.variants.map(v => {
          const weight = utils.isWeight(v.option1) ? v.option1 : utils.isWeight(v.option2) ? v.option2 : null;
          let tier = utils.isTier(v.option1) ? v.option1 : utils.isTier(v.option2) ? v.option2 : null;
          if (weight && !tier) tier = 'Essential';
          return {
            ...v,
            correctedWeight: weight,
            correctedTier: tier,
            hasPrice: utils.hasValidPrice(v)
          };
        }).filter(v => v.correctedWeight && v.hasPrice);
      },
      
      getVariantKey: (variant) => 
        `${variant.correctedTier}-${variant.correctedWeight}-${variant.price}-${variant.available}`,
        
      extractTierAndWeight: (str) => {
        const parts = str.split('/').map(s => s.trim());
        const weightPart = parts.find(p => utils.isWeight(utils.standardizeWeight(p)));
        const tierPart = parts.find(p => TIERS.includes(p));
        return { 
          weight: weightPart ? utils.standardizeWeight(weightPart) : null, 
          tier: tierPart 
        };
      },

      sortProducts: (products, sortFilter, strainFilter, weightFilter) => {
        return [...products].sort((a, b) => {
          switch (sortFilter) {
            case 'alpha-asc':
              return a.title.localeCompare(b.title);
            case 'alpha-desc':
              return b.title.localeCompare(a.title);
            case 'date-desc':
              return new Date(b.published_at) - new Date(a.published_at);
            case 'date-asc':
              return new Date(a.published_at) - new Date(b.published_at);
            case 'price-asc':
            case 'price-desc': {
              // Get valid variants for both products
              const aVariants = utils.processVariants(a);
              const bVariants = utils.processVariants(b);

              // Filter variants based on current filters
              let relevantAVariants = aVariants;
              let relevantBVariants = bVariants;

              if (weightFilter !== 'all') {
                relevantAVariants = relevantAVariants.filter(v => v.correctedWeight === weightFilter);
                relevantBVariants = relevantBVariants.filter(v => v.correctedWeight === weightFilter);
              }
              if (strainFilter !== 'all') {
                relevantAVariants = relevantAVariants.filter(v => v.correctedTier === strainFilter);
                relevantBVariants = relevantBVariants.filter(v => v.correctedTier === strainFilter);
              }
              
              // If in "In Stock Only" mode, only consider available variants
              if (!domElements.stockFilter.classList.contains('active')) {
                relevantAVariants = relevantAVariants.filter(v => v.available);
                relevantBVariants = relevantBVariants.filter(v => v.available);
              }

              // If no relevant variants after filtering, push to end of sort
              if (relevantAVariants.length === 0) return 1;
              if (relevantBVariants.length === 0) return -1;

              // Get the min/max prices for comparison
              const aPrice = relevantAVariants.length ? 
                (sortFilter === 'price-asc' ? 
                  Math.min(...relevantAVariants.map(v => parseFloat(v.price))) : 
                  Math.max(...relevantAVariants.map(v => parseFloat(v.price)))) : 
                Infinity;
              const bPrice = relevantBVariants.length ? 
                (sortFilter === 'price-asc' ? 
                  Math.min(...relevantBVariants.map(v => parseFloat(v.price))) : 
                  Math.max(...relevantBVariants.map(v => parseFloat(v.price)))) : 
                Infinity;

              // If prices are equal, sort alphabetically
              if (aPrice === bPrice) {
                return a.title.localeCompare(b.title);
              }

              return sortFilter === 'price-asc' ? aPrice - bPrice : bPrice - aPrice;
            }
            default:
              return 0;
          }
        });
      }
    };

    // Cache frequently accessed DOM elements
    const domElements = {
      productGrid: document.getElementById('product-grid'),
      productCount: document.getElementById('product-count'),
      strainFilter: document.getElementById('strain-filter'),
      strainTypeFilter: document.getElementById('strain-type-filter'),
      weightFilter: document.getElementById('weight-filter'),
      sortFilter: document.getElementById('sort-filter'),
      stockFilter: document.getElementById('stock-filter'),
      searchInput: document.getElementById('product-search-filter'),
      clearSearch: document.getElementById('clear-search'),
      loader: document.getElementById('loader'),
      settingsModal: document.getElementById('settings-modal')
    };

    // Constants for logging
    const LOG_LEVELS = {
      INFO: 'INFO',
      WARN: 'WARN',
      ERROR: 'ERROR'
    };

    function log(level, message, data = null) {
      const logMessage = `${message}`;
      
      switch(level) {
        case LOG_LEVELS.ERROR:
          data ? console.error(logMessage, data) : console.error(logMessage);
          break;
        case LOG_LEVELS.WARN:
          data ? console.warn(logMessage, data) : console.warn(logMessage);
          break;
        default:
          data ? console.log(logMessage, data) : console.log(logMessage);
      }
    }

    // Update startCountdownTimer function for better state management
    function startCountdownTimer(intervalMs) {
      const countdownEl = document.querySelector('.countdown-time');
      const tooltipTimeEl = document.querySelector('.tooltip-time');
      const progressCircle = document.querySelector('.progress');
      const circumference = 2 * Math.PI * 16; // r = 16
      
      // Reset all visual elements first
      progressCircle.style.strokeDasharray = circumference;
      progressCircle.style.strokeDashoffset = 0;
      countdownEl.textContent = '';
      tooltipTimeEl.textContent = '';
      
      let timeLeft = intervalMs;
      let timerId = null;
      let isActive = true; // Track if this timer instance is active
      
      function updateCountdown() {
        // Only update if this timer instance is still active
        if (!isActive) return;
        
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        countdownEl.textContent = display;
        tooltipTimeEl.textContent = display;
        
        // Update progress circle
        const progress = (timeLeft / intervalMs) * 100;
        const offset = circumference - (progress / 100) * circumference;
        progressCircle.style.strokeDashoffset = offset;
        
        timeLeft -= 1000;
        
        if (timeLeft < 0) {
          timeLeft = intervalMs;
        }
      }
      
      // Initial update
      updateCountdown();
      
      // Start the interval
      timerId = setInterval(updateCountdown, 1000);
      
      // Return cleanup function
      return () => {
        isActive = false; // Mark this timer instance as inactive
        if (timerId) {
          clearInterval(timerId);
          timerId = null;
        }
        // Reset visual elements on cleanup
        countdownEl.textContent = '';
        tooltipTimeEl.textContent = '';
        progressCircle.style.strokeDashoffset = 0;
      };
    }

    // Virtual Cart State
    const virtualCart = {
      items: [],
      
      addItem(product, variant) {
        // Add visual feedback to the clicked button
        const clickedButton = document.activeElement;
        if (clickedButton && clickedButton.classList.contains('add-to-cart-button')) {
          clickedButton.classList.add('clicked');
          setTimeout(() => clickedButton.classList.remove('clicked'), 300);
        }

        const existingItemIndex = this.items.findIndex(item => item.variantId === variant.id);
        
        if (existingItemIndex !== -1) {
          // Update quantity of existing item
          this.items[existingItemIndex].quantity += 1;
        } else {
          // Add new item with quantity 1
          this.items.push({
            productId: product.id,
            productTitle: product.title,
            variantId: variant.id,
            variantTitle: `${variant.correctedTier} ${variant.correctedWeight}`,
            price: parseFloat(variant.price),
            available: variant.available,
            quantity: 1
          });
        }

        // Add visual feedback to the cart icon
        const cartButton = document.getElementById('virtual-cart-button');
        cartButton.classList.add('pulse');
        setTimeout(() => cartButton.classList.remove('pulse'), 500);

        this.updateUI();
        this.saveToLocalStorage();
      },

      updateQuantity(index, newQuantity) {
        if (newQuantity > 0) {
          this.items[index].quantity = newQuantity;
          this.updateUI();
          this.saveToLocalStorage();
        } else {
          this.removeItem(index);
        }
      },

      removeItem(index) {
        this.items.splice(index, 1);
        this.updateUI();
        this.saveToLocalStorage();
      },

      clearCart() {
        this.items = [];
        this.updateUI();
        this.saveToLocalStorage();
      },

      updateUI() {
        // Update cart count (sum of all quantities)
        const cartCount = document.querySelector('.cart-count');
        const totalItems = this.items.reduce((sum, item) => sum + item.quantity, 0);
        cartCount.textContent = totalItems;

        // Update cart modal contents
        const cartItems = document.getElementById('cart-items');
        const cartTotal = document.getElementById('cart-total');
        
        if (this.items.length === 0) {
          cartItems.innerHTML = '<div class="empty-cart-message">Your cart is empty</div>';
          cartTotal.textContent = '0.00';
          return;
        }

        cartItems.innerHTML = this.items.map((item, index) => `
          <div class="cart-item">
            <div class="cart-item-info">
              <div class="cart-item-title">${item.productTitle}</div>
              <div class="cart-item-variant">${item.variantTitle}</div>
              <div class="cart-item-price">$${(item.price * item.quantity).toFixed(2)}</div>
            </div>
            <div class="cart-item-controls">
              <div class="quantity-controls">
                <button class="quantity-btn" onclick="virtualCart.updateQuantity(${index}, ${item.quantity - 1})">-</button>
                <span class="quantity-display">${item.quantity}</span>
                <button class="quantity-btn" onclick="virtualCart.updateQuantity(${index}, ${item.quantity + 1})">+</button>
              </div>
              <button class="remove-from-cart" onclick="virtualCart.removeItem(${index})"></button>
            </div>
          </div>
        `).join('');

        // Update total
        const total = this.items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
        cartTotal.textContent = total.toFixed(2);
      },

      saveToLocalStorage() {
        localStorage.setItem('virtualCart', JSON.stringify(this.items));
      },

      loadFromLocalStorage() {
        const saved = localStorage.getItem('virtualCart');
        if (saved) {
          this.items = JSON.parse(saved);
          this.updateUI();
        }
      }
    };

    // Cart Modal Functions
    function openCartModal() {
      virtualCart.updateUI();
      document.getElementById('cart-modal').style.display = 'flex';
      document.body.classList.add('modal-open');
      // Prevent background scrolling
      document.body.style.overflow = 'hidden';
      document.body.style.position = 'fixed';
      document.body.style.width = '100%';
    }

    function closeCartModal() {
      document.getElementById('cart-modal').style.display = 'none';
      document.body.classList.remove('modal-open');
      // Restore scrolling
      document.body.style.overflow = '';
      document.body.style.position = '';
      document.body.style.width = '';
    }

    function checkout() {
      if (virtualCart.items.length === 0) return;
      
      // Build a Shopify cart permalink
      const cartItems = virtualCart.items.map(item => 
        item.variantId + ':' + item.quantity
      ).join(',');
      
      const params = new URLSearchParams();
      params.append('sca_ref', REFERRAL_PARAMS.sca_ref);
      params.append('sca_crp', REFERRAL_PARAMS.sca_crp);

      // Build the cart URL with referral params
      const cartUrl = 'https://litfarms.com/cart/' + cartItems + '?' + params.toString();
      
      // Safari iOS has strict popup blocking, so we need to open the window immediately
      // We'll just go directly to the cart with params - Shopify should handle the tracking
      const isSafariIOS = /iPhone|iPad|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent) && !/Chrome|CriOS|FxiOS/.test(navigator.userAgent);
      
      if (isSafariIOS) {
        // For Safari iOS: Open window immediately to avoid popup blocking
        // Then try to initialize tracking in the background
        const newWindow = window.open(cartUrl, '_blank');
        
        // Try to load tracking in background using fetch (won't affect the opened window)
        // This is best-effort - the URL params should still work
        try {
          fetch('https://litfarms.com/?' + params.toString(), { 
            mode: 'no-cors',
            credentials: 'include'
          }).catch(() => {
            // Silently fail - the URL params should still work
          });
        } catch (e) {
          // Ignore errors
        }
      } else {
        // For other browsers: Use the two-step approach for better tracking
        const homeUrl = 'https://litfarms.com/?' + params.toString();
        const newWindow = window.open(homeUrl, '_blank');

        // After a delay, redirect to the cart with items
        setTimeout(() => {
          if (newWindow && !newWindow.closed) {
            newWindow.location.href = cartUrl;
          }
        }, 1500);
      }

      // Clear the virtual cart
      virtualCart.clearCart();
      closeCartModal();
    }

    // Initialize cart
    document.addEventListener('DOMContentLoaded', () => {
      virtualCart.loadFromLocalStorage();
      
      // Add cart button click handler with event capture
      const cartButton = document.getElementById('virtual-cart-button');
      cartButton.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();
        openCartModal();
      }, true); // Use capture phase
      
      // Prevent any touch events from passing through
      cartButton.addEventListener('touchstart', (e) => {
        e.stopPropagation();
      }, { capture: true, passive: true });
      
      cartButton.addEventListener('touchend', (e) => {
        e.stopPropagation();
      }, { capture: true, passive: true });

      // Track mousedown position for cart modal
      let cartModalMouseDown = false;
      const cartModal = document.getElementById('cart-modal');
      
      cartModal.addEventListener('mousedown', (e) => {
        if (e.target === cartModal) {
          cartModalMouseDown = true;
        }
      });

      cartModal.addEventListener('mouseup', (e) => {
        if (e.target === cartModal && cartModalMouseDown) {
          closeCartModal();
        }
        cartModalMouseDown = false;
      });

      // Reset flag when mouse leaves modal
      cartModal.addEventListener('mouseleave', () => {
        cartModalMouseDown = false;
      });
    });

    // Update createPriceContainer to add "Add to Cart" buttons
    function createPriceContainer(product, variants, strainFilter, weightFilter, stockFilter) {
      const container = document.createElement('div');
      container.className = 'price-container';

      // Group variants by tier
      const variantsByTier = {};
      TIERS.forEach(tier => {
        variantsByTier[tier] = [];
      });

      variants.forEach(variant => {
        if (variant.correctedTier && variant.correctedWeight) {
          variantsByTier[variant.correctedTier].push(variant);
        }
      });

      // Create sections for each tier
      TIERS.forEach(tier => {
        if (strainFilter !== 'all' && tier !== strainFilter) {
          return;
        }

        const tierVariants = variantsByTier[tier];
        if (tierVariants && tierVariants.length > 0) {
          const filteredVariants = tierVariants.filter(variant => {
            if (weightFilter !== 'all' && variant.correctedWeight !== weightFilter) {
              return false;
            }
            if (!stockFilter && !variant.available) {
              return false;
            }
            return true;
          });

          if (filteredVariants.length > 0) {
            const section = document.createElement('div');
            section.className = `variant-section variant-section-${tier.toLowerCase()}`;

            const title = document.createElement('div');
            title.className = `variant-title variant-title-${tier.toLowerCase()}`;
            title.textContent = tier;
            section.appendChild(title);

            const weights = document.createElement('div');
            weights.className = 'variant-weights';

            filteredVariants.forEach(variant => {
              const row = document.createElement('div');
              row.className = variant.available ? 'weight-row in-stock' : 'weight-row out-of-stock';
              
              // Add click handler to stop event propagation
              row.addEventListener('click', (e) => {
                e.stopPropagation();
              });

              const infoRow = document.createElement('div');
              infoRow.className = 'weight-info-row';

              const info = document.createElement('div');
              info.className = 'weight-info';

              const label = document.createElement('span');
              label.className = 'weight-label';
              label.textContent = variant.correctedWeight;

              const price = document.createElement('span');
              price.className = 'weight-price';
              price.textContent = `$${variant.price}`;

              info.appendChild(label);
              info.appendChild(price);
              infoRow.appendChild(info);

              const stockBadge = document.createElement('span');
              stockBadge.className = `stock-badge ${variant.available ? 'in-stock-badge' : 'out-of-stock-badge'}`;
              stockBadge.textContent = variant.available ? 'In Stock' : 'Out of Stock';

              row.appendChild(infoRow);
              row.appendChild(stockBadge);

              if (variant.available) {
                const addButton = document.createElement('button');
                addButton.className = 'add-to-cart-button';
                addButton.textContent = 'Add to Cart';
                addButton.onclick = (e) => {
                  e.stopPropagation();
                  virtualCart.addItem(product, variant);
                };
                row.appendChild(addButton);
              }

              weights.appendChild(row);
            });

            section.appendChild(weights);
            container.appendChild(section);
          }
        }
      });

      return container;
    }
  </script>

  <!-- Settings Button -->
  <button id="settings-button" title="Notification Settings">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M12 15a3 3 0 100-6 3 3 0 000 6z" />
      <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z" />
    </svg>
  </button>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settings-modal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title">Notification Settings</h2>
        <button class="close-modal">&times;</button>
      </div>
      
      <div class="modal-content">
        <div class="settings-section">
        <h3>Update Frequency</h3>
        <div class="settings-input-group">
          <input type="number" id="check-interval" class="settings-input" min="1" value="5" placeholder="5">
          <span class="settings-input-suffix">minutes</span>
        </div>
      </div>

      <div class="settings-section">
        <h3>Notifications</h3>
        <div style="margin-bottom: 20px;">
          <div class="settings-checkbox">
            <input type="checkbox" id="ntfy-enabled">
            <label for="ntfy-enabled">Enable App Notifications</label>
          </div>
          <small style="color: var(--text-muted); display: block; margin-left: 25px;">
            Receive notifications on your phone via the Ntfy app
          </small>
        </div>

        <div style="margin-bottom: 20px;">
          <div class="settings-checkbox">
            <input type="checkbox" id="email-enabled">
            <label for="email-enabled">Enable Email Notifications</label>
          </div>
          <small style="color: var(--text-muted); display: block; margin-left: 25px;">
            Receive notifications via email
          </small>
        </div>
        
        <div style="margin-top: 10px;">
          <label for="ntfy-topic">Ntfy Topic:</label>
          <div style="display: flex; gap: 8px; margin-bottom: 4px;">
            <input type="text" id="ntfy-topic" class="settings-input notification-input" placeholder="Enter your unique topic name" style="flex: 1;">
            <button onclick="generateRandomTopic()" style="background-color: var(--accent-secondary); color: var(--bg-primary); border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; white-space: nowrap;">
              Generate Random
            </button>
          </div>
          <small style="color: var(--text-muted); display: block; margin-bottom: 10px;">
            This is your private notification channel. Required for app notifications. Use the generate button for a unique topic name.
          </small>
        </div>

        <div style="margin-top: 10px;">
          <label for="ntfy-email">Email Address:</label>
          <input type="email" id="ntfy-email" class="settings-input notification-input" placeholder="your@email.com">
          <small style="color: var(--text-muted); display: block; margin-bottom: 10px;">
            Required for email notifications.
          </small>
        </div>

        <div style="margin-top: 10px;">
          <label for="ntfy-server">Ntfy Server (optional):</label>
          <input type="text" id="ntfy-server" class="settings-input notification-input" placeholder="https://ntfy.sh">
          <small style="color: var(--text-muted); display: block; margin-bottom: 10px;">
            Leave as default unless you're using a self-hosted server.
          </small>
        </div>

        <button id="test-ntfy" onclick="testNtfyNotification()" style="background-color: var(--accent-primary); color: var(--bg-primary); border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-top: 10px;">
          Test Notifications
        </button>

        <div style="margin-top: 15px; padding: 10px; background: var(--bg-elevated); border-radius: 4px;">
          <p style="margin: 0 0 10px 0; color: var(--text-secondary);">To receive app notifications:</p>
          <ol style="margin: 0; padding-left: 20px; color: var(--text-muted);">
            <li>Download the Ntfy app for <a href="https://apps.apple.com/us/app/ntfy/id1625396347" target="_blank" style="color: var(--accent-primary);">iOS</a> or <a href="https://play.google.com/store/apps/details?id=io.heckel.ntfy" target="_blank" style="color: var(--accent-primary);">Android</a></li>
            <li>Open the app and tap "Add subscription"</li>
            <li>Enter your topic name exactly as above</li>
            <li>Save and wait for notifications!</li>
          </ol>
        </div>
      </div>

      <div class="settings-section">
        <h3>Product Filters</h3>
        <label for="notification-tier">Select Tiers (hold Ctrl/Cmd to select multiple):</label>
        <select id="notification-tier" class="settings-select" multiple size="4">
          <option value="all">All Tiers</option>
          <option value="Essential">Essential</option>
          <option value="Preferred">Preferred</option>
          <option value="Supreme">Supreme</option>
        </select>

        <label for="notification-weight">Select Weights (hold Ctrl/Cmd to select multiple):</label>
        <select id="notification-weight" class="settings-select" multiple size="3">
          <option value="all">All Weights</option>
          <option value="28g">28g</option>
          <option value="3.5g">3.5g</option>
        </select>

        <div class="settings-checkbox">
          <input type="checkbox" id="notify-new" checked>
          <label for="notify-new">Notify for new products</label>
        </div>

        <div class="settings-checkbox">
          <input type="checkbox" id="notify-stock" checked>
          <label for="notify-stock">Notify for stock changes</label>
        </div>

        <div class="settings-checkbox">
          <input type="checkbox" id="notify-removed" checked>
          <label for="notify-removed">Notify for removed products</label>
        </div>
      </div>

      <div class="settings-section">
        <h3>Specific Products</h3>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <span id="products-selected-count" style="color: var(--text-muted);">0 products selected</span>
          <button id="deselect-all-products" onclick="deselectAllProducts()" style="background: none; border: none; color: var(--accent-primary); cursor: pointer; font-size: 0.9em;">
            Deselect All
          </button>
        </div>
        <div class="product-search">
          <input type="text" id="product-search" placeholder="Search products...">
        </div>
        <div class="product-select-container" id="product-select">
          <!-- Product checkboxes will be dynamically added here -->
        </div>
      </div>
      </div>

      <div class="modal-footer">
        <button class="save-settings">Save Settings</button>
      </div>
    </div>
  </div>

  <!-- Virtual Cart Button -->
  <button id="virtual-cart-button" class="virtual-cart-button" title="View Cart">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="9" cy="21" r="1"></circle>
      <circle cx="20" cy="21" r="1"></circle>
      <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
    </svg>
    <span class="cart-count">0</span>
  </button>

  <!-- Cart Modal -->
  <div id="cart-modal" class="cart-modal">
    <div class="cart-modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Shopping Cart</h2>
        <button class="close-modal" onclick="closeCartModal()">&times;</button>
      </div>
      <div id="cart-items">
        <!-- Cart items will be dynamically inserted here -->
      </div>
      <div class="cart-total">
        Total: $<span id="cart-total">0.00</span>
      </div>
      <button id="checkout-button" class="checkout-button" onclick="checkout()">
        Proceed to Checkout
      </button>
    </div>
  </div>
</body>
</html>